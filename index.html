<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Armonía de las Esferas: Simulación de Órbitas y Trivia</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #webgl-output { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        .interactive-overlay { pointer-events: auto; }
        .hover-scale { transition: transform 0.1s; }
        .hover-scale:hover { transform: scale(1.05); }

        /* Estilos específicos para la interfaz */
        .sidebar { background-color: rgba(17, 24, 39, 0.9); backdrop-filter: blur(5px); }
        .modal { background-color: rgba(0, 0, 0, 0.9); backdrop-filter: blur(5px); }
        .draggable-planet { cursor: grab; }

        /* Clases para la trivia */
        .correct-answer { border: 2px solid #10b981; }
        .wrong-answer { border: 2px solid #ef4444; }

        /* Personalización del scrollbar para la inmersión */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
    </style>
</head>
<body>
    <div id="webgl-output"></div>

    <div id="loadingScreen" class="overlay flex flex-col items-center justify-center bg-black transition-opacity duration-500 z-50 interactive-overlay">
        <h1 class="text-4xl md:text-6xl text-white mb-8 font-extrabold">ARMÓNIA DE LAS ESFERAS</h1>
        <button id="startButton" class="px-8 py-4 bg-green-500 text-white text-xl font-bold rounded-lg hover:bg-green-600 transition duration-300 transform hover-scale">
            Iniciar Simulación
        </button>
    </div>

    <div id="mainInterface" class="overlay interactive-overlay p-4 hidden">

        <div class="flex justify-between items-start mb-4">
            <div id="actionButtons" class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-4">
                
                <button id="clearButton" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition duration-300 transform hover-scale text-sm sm:text-base sm:order-1">
                    Reiniciar Simulación
                </button>
                
                <button id="triviaButton" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition duration-300 transform hover-scale text-sm sm:text-base sm:order-4">
                    Iniciar Trivia
                </button>
            </div>
        </div>

        <div id="planetCatalog" class="sidebar p-4 rounded-xl shadow-2xl w-full max-w-xs absolute right-4 top-16 max-h-4/5 overflow-y-auto interactive-overlay pt-4">
            <h2 class="text-xl font-bold text-white mb-2">CATÁLOGO DE CUERPOS CELESTES</h2>
            <p class="text-lg text-gray-400 mt-4">Arrastra para crear órbita.</p> 

            <hr class="my-4 border-gray-700">

            <div id="celestialBodiesList" class="space-y-4">
                
                <div id="body-slow-low" class="draggable-planet bg-gray-700 p-3 rounded-lg flex items-center shadow-md hover:bg-gray-600 hover-scale" data-type="slow-low">
                    <div class="w-8 h-8 rounded-full bg-red-500 mr-3"></div>
                    <div>
                        <p class="text-white font-semibold">Cuerpo Tipo I (Rojo)</p>
                        <p class="text-sm text-gray-400">Gran Masa/Baja Velocidad</p>
                    </div>
                </div>

                <div id="body-medium-rhythm" class="draggable-planet bg-gray-700 p-3 rounded-lg flex items-center shadow-md hover:bg-gray-600 hover-scale" data-type="medium-rhythm">
                    <div class="w-8 h-8 rounded-full bg-yellow-500 mr-3"></div>
                    <div>
                        <p class="text-white font-semibold">Cuerpo Tipo II (Amarillo)</p>
                        <p class="text-sm text-gray-400">Masa Media/Velocidad Estándar</p>
                    </div>
                </div>

                <div id="body-fast-high" class="draggable-planet bg-gray-700 p-3 rounded-lg flex items-center shadow-md hover:bg-gray-600 hover-scale" data-type="fast-high">
                    <div class="w-8 h-8 rounded-full bg-blue-500 mr-3"></div>
                    <div>
                        <p class="text-white font-semibold">Cuerpo Tipo III (Azul)</p>
                        <p class="text-sm text-gray-400">Poca Masa/Alta Velocidad</p>
                    </div>
                </div>
            </div>

            <hr class="my-4 border-gray-700">

            <p class="text-sm text-gray-500">Arrastra para generar órbita.</p>

        </div>

        <div id="triviaModal" class="modal fixed inset-0 flex items-center justify-center p-4 hidden">
            <div class="bg-gray-900 p-8 rounded-xl shadow-2xl max-w-lg w-full text-white interactive-overlay">
                <h2 id="triviaTitle" class="text-2xl font-bold mb-4 text-green-400">Trivia del Sistema Solar</h2>
                <div id="triviaContent">
                    <p id="triviaQuestion" class="text-lg mb-6"></p>
                    <div id="triviaOptions" class="space-y-4">
                        </div>
                </div>
                <button id="nextQuestionButton" class="mt-6 px-6 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition duration-300 transform hover-scale hidden">
                    Siguiente Pregunta
                </button>
                <button id="closeTriviaButton" class="mt-6 px-6 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition duration-300 transform hover-scale">
                    Cerrar
                </button>
            </div>
        </div>

        <div id="welcomeModal" class="modal fixed inset-0 flex items-center justify-center p-4">
            <div class="bg-gray-900 p-10 rounded-xl shadow-2xl max-w-xl w-full text-white text-center interactive-overlay">
                <img src="./armonia-orbital.png" alt="Símbolo de Armonía Orbital" class="w-24 h-auto mx-auto mb-6">
                <h2 class="text-3xl font-bold mb-4 text-green-400">Armonía de las Esferas</h2>
                <p class="text-lg mb-6 text-gray-300">
                    Arrastra los cuerpos celestes desde el catálogo lateral para crear órbitas. 
                    Experimenta la física gravitacional en un entorno 3D.
                </p>
                <button id="closeWelcomeButton" class="px-8 py-3 bg-green-500 text-white text-lg font-bold rounded-lg hover:bg-green-600 transition duration-300 transform hover-scale">
                    ¡Comenzar!
                </button>
            </div>
        </div>
    </div>


    <script>
        // ==========================================================================================
        // CONFIGURACIÓN DE LA SIMULACIÓN
        // ==========================================================================================
        let scene, camera, renderer, controls;
        let ambientLight, directionalLight;
        let raycaster, mouse;

        const SUN_MASS = 1000;
        const G = 0.01; // Constante de gravedad ajustada para simulación visual
        const SCALE_FACTOR = 0.5; // Ajuste general de velocidad
        const TIME_STEP = 0.1; // Delta de tiempo para la física
        const MAX_ORBITS = 8; // Límite de planetas que se pueden crear

        let orbitingBodies = [];
        let isDragging = false;
        let initialClickPoint = new THREE.Vector3();
        let currentDragLine = null;
        let isSimulationRunning = false;
        let animationFrameId = null;

        // Estructura de un cuerpo celeste (sin ninguna referencia a Tone.js)
        class CelestialBody {
            constructor(mass, type, mesh, position, initialVelocity, color) {
                this.mass = mass;
                this.type = type;
                this.mesh = mesh;
                this.mesh.position.copy(position);
                this.velocity = initialVelocity; // Vector3
                this.color = color;
                this.trail = null;
                this.trailGeometry = null;
                this.trailMaterial = null;
                this.trailLength = 50; 
                this.trailIndex = 0;
                this.orbitPositions = new Array(this.trailLength).fill(new THREE.Vector3()); 
                this.isOrbiting = true;

                this.initTrail();
            }

            // Inicializa el rastro de órbita
            initTrail() {
                this.trailGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.trailLength * 3); 
                this.trailGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                this.trailMaterial = new THREE.LineBasicMaterial({ color: this.color, linewidth: 2 });
                this.trail = new THREE.Line(this.trailGeometry, this.trailMaterial);
                this.trail.frustumCulled = false;
                scene.add(this.trail);
            }

            // Actualiza la posición y el rastro del cuerpo
            update(deltaTime) {
                if (!this.isOrbiting) return;

                // 1. Calcular la fuerza gravitacional (hacia el centro 0,0,0)
                const position = this.mesh.position;
                const distanceSq = position.lengthSq();
                const distance = Math.sqrt(distanceSq);

                if (distance < 1.0) { 
                    this.isOrbiting = false; 
                    return; 
                }

                const forceMagnitude = (G * SUN_MASS * this.mass) / distanceSq;
                const direction = position.clone().negate().normalize();
                const acceleration = direction.multiplyScalar(forceMagnitude / this.mass);

                // 2. Integración de Euler/Verlet (Actualizar velocidad y posición)
                this.velocity.add(acceleration.multiplyScalar(deltaTime));
                this.mesh.position.add(this.velocity.clone().multiplyScalar(deltaTime * SCALE_FACTOR));

                // 3. Actualizar el rastro (Buffer Circular)
                this.updateTrail();
            }

            updateTrail() {
                const newPosition = this.mesh.position.clone();
                this.orbitPositions[this.trailIndex] = newPosition;
                
                this.trailIndex = (this.trailIndex + 1) % this.trailLength;

                const positionsAttribute = this.trailGeometry.getAttribute('position');
                const positionsArray = positionsAttribute.array;

                if (this.trailIndex === 0) {
                    for (let i = 0; i < this.trailLength; i++) {
                        const currentIdx = i; // Siempre desde el inicio 0

                        positionsArray[i * 3 + 0] = this.orbitPositions[currentIdx].x;
                        positionsArray[i * 3 + 1] = this.orbitPositions[currentIdx].y;
                        positionsArray[i * 3 + 2] = this.orbitPositions[currentIdx].z;
                    }

                } else {
                    for (let i = 0; i < this.trailIndex; i++) {
                        positionsArray[i * 3 + 0] = this.orbitPositions[i].x;
                        positionsArray[i * 3 + 1] = this.orbitPositions[i].y;
                        positionsArray[i * 3 + 2] = this.orbitPositions[i].z;
                    }
                    for (let i = this.trailIndex; i < this.trailLength; i++) {
                        positionsArray[i * 3 + 0] = this.mesh.position.x;
                        positionsArray[i * 3 + 1] = this.mesh.position.y;
                        positionsArray[i * 3 + 2] = this.mesh.position.z;
                    }
                }

                positionsAttribute.needsUpdate = true;
                this.trailGeometry.setDrawRange(0, this.trailIndex === 0 ? this.trailLength : this.trailIndex);
            }

            // Limpieza (sin referencias a Tone.js)
            dispose() {
                scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
                scene.remove(this.trail);
                this.trailGeometry.dispose();
                this.trailMaterial.dispose();
            }
        }

        // ==========================================================================================
        // LÓGICA DE TRIVIA
        // ==========================================================================================
        let triviaData = [
            {
                question: "¿Cuál es el planeta más grande de nuestro sistema solar?",
                options: [
                    { text: "Saturno", correct: false },
                    { text: "Júpiter", correct: true },
                    { text: "Urano", correct: false },
                    { text: "Tierra", correct: false }
                ]
            },
            {
                question: "¿Qué planeta es conocido como 'el planeta rojo'?",
                options: [
                    { text: "Venus", correct: false },
                    { text: "Marte", correct: true },
                    { text: "Mercurio", correct: false },
                    { text: "Júpiter", correct: false }
                ]
            },
            {
                question: "¿Qué cuerpo celeste es el centro de gravedad en la simulación?",
                options: [
                    { text: "El planeta más masivo", correct: false },
                    { text: "El Sol (centro)", correct: true },
                    { text: "El objeto más rápido", correct: false },
                    { text: "La Tierra", correct: false }
                ]
            }
        ];
        
        let currentQuestionIndex = 0;
        let isAnsweringTrivia = false;

        function startTrivia() {
            // No se requiere verificar el audio, solo las órbitas
            if (orbitingBodies.length === 0) {
                alert("¡Crea al menos una órbita para comenzar la trivia!");
                return;
            }

            isAnsweringTrivia = true;
            currentQuestionIndex = 0;
            document.getElementById('triviaModal').classList.remove('hidden');
            displayQuestion(currentQuestionIndex);
        }

        function displayQuestion(index) {
            const question = triviaData[index];
            const contentDiv = document.getElementById('triviaContent');
            const optionsDiv = document.getElementById('triviaOptions');
            const nextButton = document.getElementById('nextQuestionButton');

            document.getElementById('triviaTitle').textContent = `Pregunta ${index + 1} de ${triviaData.length}`;
            document.getElementById('triviaQuestion').textContent = question.question;
            optionsDiv.innerHTML = '';
            nextButton.classList.add('hidden');

            question.options.forEach((option, optionIndex) => {
                const button = document.createElement('button');
                button.textContent = option.text;
                button.className = 'w-full px-4 py-3 bg-gray-700 text-white rounded-lg text-left hover:bg-gray-600 transition duration-300 transform hover-scale';
                button.onclick = () => checkAnswer(option, button);
                optionsDiv.appendChild(button);
            });
        }

        function checkAnswer(selectedOption, buttonElement) {
            isAnsweringTrivia = false;
            const optionsDiv = document.getElementById('triviaOptions');
            const nextButton = document.getElementById('nextQuestionButton');
            
            Array.from(optionsDiv.children).forEach(btn => btn.disabled = true);

            if (selectedOption.correct) {
                buttonElement.classList.add('correct-answer', 'bg-green-500', 'hover:bg-green-500');
            } else {
                buttonElement.classList.add('wrong-answer', 'bg-red-500', 'hover:bg-red-500');
                const correctAnswer = triviaData[currentQuestionIndex].options.find(opt => opt.correct);
                const correctButton = Array.from(optionsDiv.children).find(btn => btn.textContent === correctAnswer.text);
                if (correctButton) {
                    correctButton.classList.add('correct-answer', 'bg-green-500');
                }
            }

            if (currentQuestionIndex < triviaData.length - 1) {
                nextButton.textContent = "Siguiente Pregunta";
                nextButton.onclick = () => {
                    currentQuestionIndex++;
                    displayQuestion(currentQuestionIndex);
                    isAnsweringTrivia = true;
                };
            } else {
                nextButton.textContent = "Trivia Finalizada (Cerrar)";
                nextButton.onclick = closeTrivia;
            }
            nextButton.classList.remove('hidden');
        }

        function closeTrivia() {
            document.getElementById('triviaModal').classList.add('hidden');
            isAnsweringTrivia = false;
        }


        // ==========================================================================================
        // INICIALIZACIÓN DE LA SIMULACIÓN
        // ==========================================================================================

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.001);

            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
            camera.position.set(0, 100, 200);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('webgl-output').appendChild(renderer.domElement);

            ambientLight = new THREE.AmbientLight(0x404040, 5); 
            scene.add(ambientLight);
            directionalLight = new THREE.DirectionalLight(0xffffff, 2);
            directionalLight.position.set(50, 50, 50);
            scene.add(directionalLight);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; 
            controls.dampingFactor = 0.05;
            controls.maxDistance = 500;
            controls.minDistance = 50;

            const sunGeometry = new THREE.SphereGeometry(10, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffa500 });
            const sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.position.set(0, 0, 0);
            scene.add(sun);
            
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 10000;
            const positions = new Float32Array(starCount * 3);
            for (let i = 0; i < starCount; i++) {
                const distance = 500 + Math.random() * 500;
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;

                positions[i * 3 + 0] = distance * Math.sin(theta) * Math.cos(phi);
                positions[i * 3 + 1] = distance * Math.sin(theta) * Math.sin(phi);
                positions[i * 3 + 2] = distance * Math.cos(theta);
            }
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1, sizeAttenuation: true });
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            window.addEventListener('resize', onWindowResize, false);
            
            renderer.domElement.addEventListener('mousedown', onMouseDown, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('mouseup', onMouseUp, false);
            
            setupEventListeners();
        }

        // ==========================================================================================
        // MANEJO DE EVENTOS DE USUARIO Y DRAG & DROP
        // ==========================================================================================

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function get3DMousePosition(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            const intersection = new THREE.Vector3();
            if (raycaster.ray.intersectPlane(plane, intersection)) {
                return intersection;
            }

            return null;
        }

        let dragBodyType = null;

        document.querySelectorAll('.draggable-planet').forEach(element => {
            element.addEventListener('dragstart', (e) => {
                dragBodyType = element.getAttribute('data-type');
                e.dataTransfer.setData('text/plain', dragBodyType);
                const img = new Image();
                img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
                e.dataTransfer.setDragImage(img, 0, 0);

                document.getElementById('planetCatalog').style.opacity = 0.3;
            });

            element.addEventListener('dragend', () => {
                dragBodyType = null;
                document.getElementById('planetCatalog').style.opacity = 1.0;
            });
        });

        renderer.domElement.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        renderer.domElement.addEventListener('drop', (e) => {
            e.preventDefault();
            
            if (orbitingBodies.length >= MAX_ORBITS) {
                alert(`Límite alcanzado: Máximo ${MAX_ORBITS} órbitas.`);
                return;
            }

            const type = e.dataTransfer.getData('text/plain'); 
            dragBodyType = type;

            const position = get3DMousePosition(e);
            if (position) {
                isDragging = true;
                initialClickPoint.copy(position);
                
                const geometry = new THREE.BufferGeometry().setFromPoints([initialClickPoint, initialClickPoint]);
                currentDragLine = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 3 }));
                scene.add(currentDragLine);
            }
        });


        function onMouseDown(event) {
            if (!dragBodyType) return;
        }

        function onMouseMove(event) {
            if (!isDragging) return;

            const currentPoint = get3DMousePosition(event);
            if (currentPoint && currentDragLine) {
                const positions = currentDragLine.geometry.attributes.position.array;
                positions[3] = currentPoint.x;
                positions[4] = currentPoint.y;
                positions[5] = currentPoint.z;
                currentDragLine.geometry.attributes.position.needsUpdate = true;
            }
        }

        function onMouseUp(event) {
            if (!isDragging || !dragBodyType) return;

            isDragging = false;
            controls.enabled = true;
            
            const releasePoint = get3DMousePosition(event);

            if (releasePoint && currentDragLine) {
                const initialVelocity = releasePoint.clone().sub(initialClickPoint).multiplyScalar(0.5); 
                createCelestialBody(initialClickPoint, initialVelocity, dragBodyType);
            }

            if (currentDragLine) {
                scene.remove(currentDragLine);
                currentDragLine.geometry.dispose();
                currentDragLine.material.dispose();
                currentDragLine = null;
            }

            dragBodyType = null;
        }

        // ==========================================================================================
        // LÓGICA DE CREACIÓN DE CUERPOS CELESTES
        // ==========================================================================================

        function createCelestialBody(position, velocity, type) {
            let bodyMass, color, size;

            switch(type) {
                case 'slow-low':
                    bodyMass = 10;
                    color = 0xff0000;
                    size = 5;
                    break;
                case 'medium-rhythm':
                    bodyMass = 5;
                    color = 0xffff00;
                    size = 3;
                    break;
                case 'fast-high':
                    bodyMass = 2;
                    color = 0x0000ff;
                    size = 2;
                    break;
                default:
                    return;
            }
            
            const geometry = new THREE.SphereGeometry(size, 16, 16);
            const material = new THREE.MeshLambertMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);

            const body = new CelestialBody(bodyMass, type, mesh, position, velocity, new THREE.Color(color));
            
            scene.add(mesh);
            orbitingBodies.push(body);
            
            if (orbitingBodies.length === 1 && !isSimulationRunning) {
                startSimulation();
            }

            updateCatalogDisplay();
        }

        function updateCatalogDisplay() {
            const usedTypes = new Set(orbitingBodies.map(b => b.type));
            
            document.querySelectorAll('.draggable-planet').forEach(element => {
                const type = element.getAttribute('data-type');
                if (usedTypes.has(type)) {
                    element.classList.add('opacity-50', 'cursor-not-allowed');
                    element.setAttribute('draggable', 'false');
                } else {
                    element.classList.remove('opacity-50', 'cursor-not-allowed');
                    element.setAttribute('draggable', 'true');
                }
            });
        }

        function clearSimulation() {
            stopSimulation(); 
            
            orbitingBodies.forEach(body => body.dispose());
            orbitingBodies = [];
            
            updateCatalogDisplay();
            controls.reset();
        }


        // ==========================================================================================
        // BUCLE DE ANIMACIÓN
        // ==========================================================================================

        function animate() {
            if (!isSimulationRunning) return;

            animationFrameId = requestAnimationFrame(animate);

            const deltaTime = TIME_STEP;

            orbitingBodies.forEach(body => {
                body.update(deltaTime);
            });

            controls.update();
            renderer.render(scene, camera);
        }

        function startSimulation() {
            if (isSimulationRunning) return;

            isSimulationRunning = true;
            animate();
            console.log("Simulación Iniciada.");
        }

        function stopSimulation() {
            if (!isSimulationRunning) return;
            
            cancelAnimationFrame(animationFrameId);
            isSimulationRunning = false;
            console.log("Simulación Detenida.");
        }


        // ==========================================================================================
        // CONFIGURACIÓN DE EVENTOS DE BOTONES
        // ==========================================================================================
        
        function setupEventListeners() {
            
            // Botón de Inicio (Reemplaza a la pantalla de carga MIDI)
            document.getElementById('startButton').addEventListener('click', () => {
                document.getElementById('loadingScreen').classList.add('opacity-0');
                setTimeout(() => {
                    document.getElementById('loadingScreen').classList.add('hidden');
                    document.getElementById('mainInterface').classList.remove('hidden');
                }, 500); 
                // La simulación se iniciará al arrastrar el primer cuerpo.
            });
            
            // Botón de Bienvenida (Armonía)
            document.getElementById('closeWelcomeButton').addEventListener('click', () => {
                document.getElementById('welcomeModal').classList.add('hidden');
            });
            
            // Botón de Reiniciar Simulación
            document.getElementById('clearButton').addEventListener('click', () => {
                if (confirm('¿Estás seguro de que quieres reiniciar la simulación y eliminar todas las órbitas?')) {
                    clearSimulation();
                }
            });

            // Botón de Iniciar Trivia
            document.getElementById('triviaButton').addEventListener('click', startTrivia);

            // Botón de Cerrar/Siguiente Trivia (se actualiza dinámicamente)
            document.getElementById('closeTriviaButton').addEventListener('click', closeTrivia);
        }

        // ==========================================================================================
        // INICIO DEL PROGRAMA
        // ==========================================================================================
        
        document.addEventListener('DOMContentLoaded', () => {
            init();
        });
    </script>
</body>
</html>
