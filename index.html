<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Armonía de las Esferas - Jeopardy</title>
    <!-- Carga de Tailwind CSS para estilos modernos y responsivos -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Configuración de Tailwind para incluir colores personalizados
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'space-dark': '#0d0d1a',
                        'space-blue': '#1a202c',
                        // Se define el naranja de la marca para usar en hover/focus
                        'brand-orange': '#f75b0f', 
                        // NUEVO: Color Turquesa para la Trivia
                        'trivia-teal': '#00c7b5',
                    }
                }
            }
        }
    </script>
    <!-- Carga de Three.js para la renderización 3D -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Carga de librerías para audio real/MIDI -->
    <script src="https://unpkg.com/tone@14.7.58/build/Tone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.2/build/Midi.min.js"></script>
    
    <style>
        /* Estilos personalizados para el cuerpo y el canvas */
        body {
            margin: 0;
            overflow: hidden; /* Evita barras de desplazamiento */
            font-family: 'Inter', sans-serif;
            background-color: #0d0d1a; /* Fondo oscuro espacial */
        }
        canvas {
            display: block;
            touch-action: none; /* Previene el comportamiento nativo del navegador al arrastrar */
        }
        /* Intenta aumentar el grosor de línea si el navegador lo permite */
        canvas.webgl-canvas {
            stroke-width: 2px;
        }
        /* Estilos específicos para la trivia */
        #jeopardyOverlay {
            /* Se aplica el color de la marca con una ligera opacidad */
            background-color: rgba(247, 91, 15, 0.95); /* #f75b0f */
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        .question-card {
            /* Estilo para los botones de las preguntas en el tablero */
            cursor: pointer;
            transition: transform 0.1s, opacity 0.3s;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 1px 1px 2px #000;
        }
        /* APLICA EL EFECTO HOVER DE COLOR TURQUESA */
        .point-cell:not(.answered):hover {
            transform: scale(1.05);
            background-color: #14b8a6; /* Usando teal-500 (Turquesa brillante) */
        }
        .answered {
            opacity: 0.5;
            cursor: default;
        }
        #questionDisplay {
            min-height: 20rem; /* Espacio mínimo para la pregunta */
        }
        /* Estilos para la tarjeta de pregunta (fondo blanco) */
        #questionDisplay {
            background-color: white;
            color: #1f2937; /* Texto oscuro */
        }
        /* Asegurar que el texto de las opciones sea negro por defecto en fondo blanco */
        .trivia-option-button {
             color: #1f2937;
        }
        /* Color hover de las celdas de pregunta turquesa brillante */
        .trivia-option-button:hover:not(:disabled) {
            background-color: #fcd34d !important; 
        }

    </style>
</head>
<body>

    <!-- Contenedor del Canvas y Overlay de Instrucciones -->
    <div id="container"></div>

    <!-- Overlay de Inicio -->
    <div id="overlay" style="background-color: #f75b0f;" class="fixed inset-0 flex flex-col items-center justify-center p-4 text-white transition-opacity duration-500 ease-in-out z-30">
        
        <div class="flex flex-col items-center text-center p-4">
            
            <!-- Título principal en color blanco, más grande y prominente -->
            <h1 class="text-6xl sm:text-7xl font-extrabold mb-12 text-white uppercase tracking-wider">
                Armonía de las Esferas
            </h1>
            
            <!-- Botón de inicio en blanco con texto naranja, más grande -->
            <button id="startButton" class="px-10 py-5 bg-white hover:bg-gray-200 text-brand-orange font-extrabold text-xl rounded-xl shadow-2xl transition transform hover:scale-105">
                ¡Empezar Simulación!
            </button>
        </div>
    </div>
    
    <!-- Controles Flotantes -->
    <div id="controls" class="fixed inset-x-0 bottom-4 flex flex-col items-center space-y-3 z-20 opacity-0 transition-opacity duration-500 pointer-events-none sm:flex-row sm:justify-between sm:bottom-auto sm:top-4 sm:space-y-0 sm:px-6">
        
        <!-- Botón Pausar/Reanudar -->
        <div class="sm:order-1 sm:w-auto">
            <button id="pauseButton" class="px-5 py-3 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-full shadow-lg transition transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-500 focus:ring-opacity-50">
                Pausar Simulación
            </button>
        </div>
        
        <!-- Menú de Selección de Entidad (Simplificado, la opción de pulso se elimina) -->
        <div class="w-full sm:w-auto sm:order-2">
            <label for="entitySelect" class="block text-sm font-medium text-white mb-1">Crear:</label>
            <select id="entitySelect" class="w-full sm:w-36 p-2 bg-gray-800 text-white rounded-lg border border-gray-700 focus:ring-brand-orange focus:border-brand-orange transition duration-150">
                <option value="planet">Planeta</option>
                <option value="sun">Sol</option>
            </select>
        </div>
        <!-- El antiguo selector de Pulso Planeta (sm:order-3) ha sido eliminado -->

        <!-- Botón Reiniciar Simulación (Bottom-Center) -->
        <div class="sm:order-4 sm:w-auto">
            <button id="clearButton" style="background-color: #f75b0f;" class="px-5 py-3 hover:bg-orange-700 text-white font-semibold rounded-full shadow-lg transition transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-orange-500 focus:ring-opacity-50">
                Reiniciar Simulación
            </button>
        </div>

        <!-- Botón Iniciar Trivia (NUEVO) -->
        <div class="sm:order-5 sm:w-auto">
            <button id="triviaButton" class="px-5 py-3 bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-semibold rounded-full shadow-lg transition transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-yellow-400 focus:ring-opacity-50">
                Iniciar Trivia
            </button>
        </div>
    </div>

    <!-- Overlay de JEOPARDY (Inicialmente Oculto) -->
    <div id="jeopardyOverlay" class="fixed inset-0 flex flex-col items-center justify-center p-4 text-white z-40 hidden">
        <div id="triviaContent" class="w-full max-w-6xl bg-gray-900/90 rounded-xl shadow-2xl p-6 space-y-6">
            
            <!-- Encabezado y Puntuación -->
            <div class="flex justify-between items-center border-b pb-3 border-gray-700">
                <!-- Título Simplificado -->
                <h2 class="text-3xl font-bold text-yellow-400">Armonía de las Esferas</h2>
                <div id="score" class="text-lg font-medium bg-gray-800 p-2 rounded-lg">
                    Puntos: <span id="currentScore" class="text-yellow-400">0</span>
                </div>
                <!-- Botón Regresar - Llama a resumeSimulation() -->
                <button id="resumeButton" class="px-4 py-2 bg-trivia-teal hover:bg-teal-600 rounded-lg text-white font-semibold transition">Regresar</button>
            </div>
            
            <!-- Contenedor del Tablero (Grid) -->
            <div id="jeopardyBoard" class="grid grid-cols-3 gap-3">
                <!-- Títulos de Categoría -->
                <div class="p-3 bg-trivia-teal font-extrabold text-xl text-center rounded-t-lg text-white">FÍSICA (Gravedad)</div>
                <div class="p-3 bg-trivia-teal font-extrabold text-xl text-center rounded-t-lg text-white">COMPOSICIÓN</div>
                <div class="p-3 bg-trivia-teal font-extrabold text-xl text-center rounded-t-lg text-white">DATOS DEL SISTEMA</div>
                
                <!-- Las celdas de puntos se inyectan aquí -->
            </div>
            
            <!-- Contenedor de la Pregunta Activa -->
            <div id="questionDisplay" class="hidden flex-col justify-center items-center p-6 bg-white text-gray-900 rounded-lg question-card">
                <div id="questionCategory" class="text-xl font-semibold text-yellow-600 mb-2"></div>
                <div id="questionValue" class="2xl font-bold mb-4"></div>
                <div id="currentQuestionText" class="text-2xl text-center mb-6"></div>
                
                <div id="optionsContainer" class="w-full grid grid-cols-1 md:grid-cols-2 gap-4">
                    <!-- Opciones de respuesta inyectadas aquí -->
                </div>
                
                <div id="feedbackMessage" class="mt-4 text-xl font-bold hidden"></div>
                <!-- Botón Volver al Tablero - Llama a renderJeopardyBoard() -->
                <button id="backToBoardButton" class="mt-6 px-6 py-3 bg-trivia-teal hover:bg-teal-600 rounded-lg text-white font-semibold transition hidden">Volver al Tablero</button>
            </div>
            

        </div>
    </div>


    <script>
        // Configuración global de Three.js
        let scene, camera, renderer;
        let ambientLight;
        let starField; // Variable para el campo de estrellas
        
        // --- ARRAYS GLOBALES PARA MÚLTIPLES OBJETOS ---
        const suns = []; 
        const planets = [];
        
        // =================================================================
        // CONSTANTES DE FÍSICA Y TIEMPO
        // =================================================================
        const GRAVITATIONAL_CONSTANT = 1.0; 
        const SUN_MASS = 1000.0; 
        const PLANET_MASS = 1.0; 
        const TIME_STEP = 0.05; 
        const MIN_DISTANCE = 25;
        const MAX_DISTANCE = 150;
        const COLLISION_DISTANCE = 18; 
        const MAX_SUN_DISTANCE = 100; 
        
        // NUEVO: Límite de expulsión más amplio para evitar pérdidas rápidas
        const MAX_EXPULSION_DISTANCE = 1000;
        
        // Aumentamos la longitud del rastro a 100 puntos (antes 50)
        const TRAIL_LENGTH = 100; 
        
        // NUEVA VARIABLE DE ESTADO
        let isPaused = false;
        
        // Objeto para ayudar en la conversión de coordenadas 2D a 3D
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        
        // Vectores temporales para evitar reasignaciones constantes y ahorrar memoria/rendimiento
        const tempVector = new THREE.Vector3();
        
        // =================================================================
        // VARIABLES DE CONTROL DE CÁMARA (MANUAL)
        // =================================================================
        let isDragging = false; 
        let isPointerActive = false;
        let pointerStart = { x: 0, y: 0 };
        let previousPointerPosition = { x: 0, y: 0 };
        const ORBIT_RADIUS = 250; // AUMENTADO A 250 para mejor vista inicial
        
        let theta = 0.5; // Ligera rotación inicial para ver el sol
        let phi = Math.PI / 2;
        
        const DAMPING_FACTOR = 0.9; 
        const ROTATION_MULTIPLIER = 0.005;
        let velocityX = 0;
        let velocityY = 0;
        
        const DRAG_THRESHOLD = 5;

        // =================================================================
        // CONFIGURACIÓN DE AUDIO (ESTRUCTURA PARA MIDI REAL)
        // =================================================================
        let isAudioContextStarted = false;
        let musicStarted = false;
        
        // PISTAS Y CANCIONES
        const TOTAL_SONGS = 10; 
        const TRACKS_PER_SONG = 10; // Pistas por canción (T1 a T10)

        let currentSongIndex = 0; 
        let currentMidiData = null; // Almacenará el objeto MIDI parseado
        const midiPlayers = []; // Arreglo de Tone.js Samplers para reproducir las pistas
        
        // --- FUNCIÓN PARA OBTENER LA RUTA DEL ARCHIVO MIDI PARA CADA PISTA ---
        // Ahora depende del índice de la canción y el índice de la pista
        const getTrackPath = (songIndex, trackIndex) => {
            const songNum = songIndex + 1; // C1, C2, C3...
            const trackNum = trackIndex + 1; // T1, T2, T3...
            // EL NOMBRE DEL ARCHIVO DEBE SER 'CX_TY.mid'
            // NOTA: Usaremos el mismo nombre de la pista para la carga de MIDI
            return `C${songNum}_T${trackNum}.mid`;
        };
        
        // Genera los nombres de las capas: CancionX_Y
        const generateLayerNames = (songNum) => {
            let layers = [];
            for (let i = 1; i <= TRACKS_PER_SONG; i++) {
                layers.push(`Cancion${songNum}_T${i}`);
            }
            return layers;
        };

        // Estructura de datos global que simula 10 canciones
        const SONG_DATA_STRUCTURES = [];
        for (let i = 1; i <= TOTAL_SONGS; i++) {
            SONG_DATA_STRUCTURES.push({
                name: `Cumbia Orquesta (Cancion ${i})`,
                layers: generateLayerNames(i)
            });
        }
        
        let INSTRUMENT_LAYERS = SONG_DATA_STRUCTURES[0].layers;
        let activePatterns = {}; // Mapa para silenciar/activar cada pista por planeta
        const activeNotes = {}; // Para visuales (ahora solo dummy)


        /**
         * Inicializa los Samplers de Tone.js (instrumentos reales).
         */
        async function setupMidiPlayers() {
            // Un mapa simple de Instrumentos General MIDI (GM) a sonidos de Sampler
            const GM_INSTRUMENT_MAP = {
                'piano': 'piano', 'bass': 'bass-electric', 'drums': 'drums', 'brass': 'trumpet', 
                'synth': 'synth_lead', 'strings': 'violin', 'guitar': 'guitar-acoustic'
            };
            
            const samplerPromises = [];
            
            // Solo necesitamos 10 Samplers, uno por cada posible pista activa
            for (let i = 0; i < TRACKS_PER_SONG; i++) {
                // Usamos una clave genérica para los Samplers (siempre se cargará piano por estabilidad)
                const sampler = new Tone.Sampler({
                    urls: { "C4": `piano-c4.mp3` }, 
                    baseUrl: "https://tonejs.github.io/audio/salamander/", 
                    onload: () => {
                        sampler.volume.value = -100; // Silenciado por defecto
                        sampler.toDestination();
                    },
                    onerror: (e) => {
                        console.error(`Error al cargar sampler:`, e);
                    }
                }).toDestination();
                
                midiPlayers.push(sampler);
                samplerPromises.push(new Promise(resolve => sampler.onload = resolve));
            }
            
            await Promise.all(samplerPromises);
            
            // Una vez cargados los 10 Samplers, procedemos a cargar la primera canción MIDI
            await loadMidiAndSetup(currentSongIndex);
        }
        
        /**
         * Inicia el secuenciador de Tone.js con los datos MIDI.
         */
        function startSequencer(midiArray) {
            Tone.Transport.cancel();
            
            // Usamos el BPM del primer archivo MIDI
            Tone.Transport.bpm.value = midiArray[0].header.tempos[0].bpm || 128; 

            midiArray.slice(0, TRACKS_PER_SONG).forEach((midi, i) => {
                const track = midi.tracks.length > 0 ? midi.tracks[0] : null; 
                if (!track) return;

                const notes = track.notes;
                const player = midiPlayers[i];

                const part = new Tone.Part((time, note) => {
                    // Solo reproducimos si la capa está activa (activada por un planeta)
                    if (activePatterns[INSTRUMENT_LAYERS[i]]) {
                        player.triggerAttackRelease(
                            note.name, 
                            note.duration, 
                            time, 
                            note.velocity
                        );

                        // Visualización rítmica (parpadeo del planeta)
                        Tone.Draw.schedule(() => {
                            activeNotes[INSTRUMENT_LAYERS[i]] = true;
                            setTimeout(() => activeNotes[INSTRUMENT_LAYERS[i]] = false, Tone.Time(note.duration).toMilliseconds() * 0.5);
                        }, time);
                    }
                }, notes).start(0);

                part.loop = true;
                part.loopEnd = midi.duration || "4m";
            });

            // Usamos la duración del primer MIDI como duración del loop principal
            Tone.Transport.loop = true;
            Tone.Transport.loopEnd = midiArray[0].duration || "4m";
            
            Tone.Transport.start();
            showMessage(`¡Música ${SONG_DATA_STRUCTURES[currentSongIndex].name} lista! Crea tu primer planeta.`, 2000, new THREE.Color(0x22c55e));
        }

        /**
         * Carga el archivo MIDI de forma asíncrona.
         */
        async function loadMidiAndSetup(songIndex) {
             showMessage(`Cargando partitura MIDI para ${SONG_DATA_STRUCTURES[songIndex].name}...`, 3000, new THREE.Color(0xfacc15));
             
             // 1. Crear 10 promesas de carga para las 10 pistas
             const midiPromises = [];
             for(let i = 0; i < TRACKS_PER_SONG; i++) {
                 const MIDI_PATH = getTrackPath(songIndex, i); 
                 
                 // Usamos fetch para asegurar que el navegador pueda acceder al archivo
                 const loadPromise = fetch(MIDI_PATH)
                     .then(response => {
                         if (!response.ok) {
                             // Si no se encuentra el archivo (Error 404), no lanzamos error fatal, devolvemos un MIDI vacío
                             console.warn(`Advertencia: Pista ${i + 1} (${MIDI_PATH}) no encontrada. La pista estará en silencio.`);
                             return { tracks: [], duration: 0, header: { tempos: [{ bpm: 128 }] } };
                         }
                         return response.arrayBuffer();
                     })
                     .then(arrayBuffer => Midi.fromBuffer(arrayBuffer))
                     .catch(e => {
                         console.error(`Fallo al procesar Pista ${i + 1}:`, e);
                         // Devolver un objeto MIDI vacío si hay un fallo en el procesamiento
                         return { tracks: [], duration: 0, header: { tempos: [{ bpm: 128 }] } }; 
                     });
                 
                 midiPromises.push(loadPromise);
             }
            
            // 2. Esperar a que todos los archivos MIDI carguen
            const loadedMidis = await Promise.all(midiPromises);
            
            // 3. Almacenar y comenzar la secuencia
            currentMidiData = loadedMidis; 
            
            // 4. Iniciar el secuenciador con el array de midis
            startSequencer(loadedMidis);
        }

        /**
         * Función dummy para mantener la estructura de planet.synth (ahora solo mute/unmute)
         */
        function createSynth() {
            return { synth: null, panner: null }; 
        }

        /**
         * Inicia el contexto de audio y la carga del MIDI.
         */
        function startAudioContext() {
            if (!isAudioContextStarted) {
                // Iniciar el Contexto de Audio con interacción del usuario
                Tone.start(); 
                isAudioContextStarted = true;
                
                // Iniciar la carga de Samplers y MIDI
                setupMidiPlayers();
            }
        }
        
        /**
         * Función que cambia la canción al crear un nuevo Sol.
         */
        function changeSong() {
            // Ciclo a la siguiente canción
            currentSongIndex = (currentSongIndex + 1) % TOTAL_SONGS; 
            
            // 1. Limpiar patrones visuales
            activePatterns = {};
            planets.forEach(p => p.assignedLayer = INSTRUMENT_LAYERS[0]);
            
            // 2. Actualizar las capas de instrumento disponibles (para la UI)
            INSTRUMENT_LAYERS = SONG_DATA_STRUCTURES[currentSongIndex].layers;

            // 3. Cargar la nueva canción MIDI
            // NOTA: No esperamos aquí, el resto de la app es asíncrona.
            loadMidiAndSetup(currentSongIndex); 
            
            // 4. Actualizar volumen (silenciar capas)
            updateAudioVolumes();
            
            showMessage(`Música cambiada a: ${SONG_DATA_STRUCTURES[currentSongIndex].name}`, 2000, new THREE.Color(0xfacc15));
        }
        
        /**
         * Controla qué patrones rítmicos están activos (solo lógica, sin audio).
         */
        function updateAudioVolumes() {
            // 1. Mapear qué capas están activas visualmente (para el MIDI)
            INSTRUMENT_LAYERS.forEach(layer => activePatterns[layer] = false);
            
            planets.forEach((planet, index) => {
                const layerIndex = index % TRACKS_PER_SONG;
                const layerName = INSTRUMENT_LAYERS[layerIndex];
                
                planet.assignedLayer = layerName;
                activePatterns[layerName] = true;
                
                // Controlar el volumen real del sampler (si existe)
                if (midiPlayers[layerIndex]) {
                    midiPlayers[layerIndex].volume.value = 0; // Activar (0dB)
                }
            });
            
            // Silenciar las capas sin planeta
            for (let i = planets.length; i < TRACKS_PER_SONG; i++) {
                 if (midiPlayers[i]) {
                    midiPlayers[i].volume.value = -100; // Silenciar
                 }
            }


            // 3. Controlar el estado general 
            if (planets.length > 0 && !musicStarted) {
                musicStarted = true;
                Tone.Master.mute = false; // Desmutear la música
            } else if (planets.length === 0 && musicStarted) {
                musicStarted = false;
                Tone.Master.mute = true; // Mutear todo
            }
        }


        // =================================================================
        // FUNCIONES DE FÍSICA
        // =================================================================

        /**
         * Calcula la aceleración gravitacional neta sobre el planeta causada por todos los soles.
         * F = G * M1 * M2 / r^2
         * A = F / M2 = G * M1 / r^2
         * @param {object} planet El objeto planeta con posición, masa y aceleración.
         */
        function calculateGravity(planet) {
            const netAcceleration = new THREE.Vector3(0, 0, 0);

            suns.forEach(sun => {
                // Vector que apunta del planeta al sol
                const direction = tempVector.copy(sun.mesh.position).sub(planet.mesh.position);
                const distanceSq = direction.lengthSq();

                // Evitar división por cero o fuerzas infinitas en colisión cercana
                if (distanceSq < 1) { 
                    return;
                }
                
                const distance = Math.sqrt(distanceSq);

                // Fuerza gravitacional: A = (G * M_sol / r^2) * (vector unitario)
                const magnitude = (GRAVITATIONAL_CONSTANT * SUN_MASS) / distanceSq;

                // Asegurar que la fuerza no sea demasiado grande a corta distancia
                const maxMagnitude = 5.0; // Límite de aceleración para estabilidad
                const finalMagnitude = Math.min(magnitude, maxMagnitude);

                direction.normalize().multiplyScalar(finalMagnitude);
                
                netAcceleration.add(direction);
            });

            planet.acceleration = netAcceleration;
        }

        /**
         * Aplica la integración de Euler para actualizar la velocidad y posición.
         * @param {object} planet El objeto planeta.
         * @param {number} deltaTime El paso de tiempo.
         */
        function updatePhysics(planet, deltaTime) {
            // Velocidad = Velocidad + Aceleración * dt
            planet.velocity.add(planet.acceleration.clone().multiplyScalar(deltaTime));
            
            // Posición = Posición + Velocidad * dt
            planet.mesh.position.add(planet.velocity.clone().multiplyScalar(deltaTime));
        }

        /**
         * Encuentra el Sol más cercano al punto de click.
         * @param {THREE.Vector3} clickPosition Posición 3D del click.
         * @returns {object} El objeto Sol más cercano.
         */
        function findNearestSun(clickPosition) {
            let minDistanceSq = Infinity;
            let nearestSun = null;
            
            suns.forEach(sun => {
                // Usamos subVectors y lengthSq para calcular la distancia.
                const diffVector = new THREE.Vector3().subVectors(sun.mesh.position, clickPosition);
                const distanceSq = diffVector.lengthSq(); 
                
                if (distanceSq < minDistanceSq) {
                    minDistanceSq = distanceSq;
                    nearestSun = sun;
                }
            });

            return nearestSun;
        }

        // =================================================================
        // UTILIDADES
        // =================================================================

        /**
         * Inicializa la escena, cámara, renderizador y luces.
         */
        function init() {
            // 1. Configuración de la Escena
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0d0d1a, 0.003); 

            // 2. Configuración de la Cámara (perspectiva para 3D)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, ORBIT_RADIUS); // Posición inicial aumentada a 250
            
            // 3. Configuración del Renderizador (WebGL)
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1);
            // Añadir una clase para apuntar con CSS si queremos aumentar el grosor de línea
            renderer.domElement.classList.add('webgl-canvas'); 
            document.getElementById('container').appendChild(renderer.domElement);
            
            // 4. Configuración de la Iluminación
            ambientLight = new THREE.AmbientLight(0x404040, 0.5); 
            scene.add(ambientLight);

            // 5. Crear el Sol Central Inicial y el Fondo de Estrellas
            createInitialSun(); 
            createStarField(); 
            
            // 6. Manejadores de Eventos
            window.addEventListener('resize', onWindowResize, false);
            setupPointerControls(renderer.domElement);
        }

        /**
         * Crea el primer Sol al iniciar la simulación.
         */
        function createInitialSun() {
            // Sol inicial ligeramente desplazado para evitar la singularidad de la órbita inicial
            const center = new THREE.Vector3(5, 0, 0); 
            createSunAtPosition(center);
        }

        /**
         * Crea un objeto Sol y lo añade a la escena y al array de Soles.
         * @param {THREE.Vector3} position Posición del nuevo sol.
         */
        function createSunAtPosition(position) {
            const sunRadius = 12;
            const sunGeometry = new THREE.SphereGeometry(sunRadius, 32, 32); 
            const sunMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                emissive: 0xff8800 
            }); 
            const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            sunMesh.position.copy(position);
            scene.add(sunMesh);
            
            const flareTexture = generateRadialTexture(); 

            const lightSprite = new THREE.Sprite(new THREE.SpriteMaterial({
                map: flareTexture,
                color: 0xff8800, 
                blending: THREE.AdditiveBlending, 
                transparent: true,
                opacity: 0.7 
            }));
            lightSprite.scale.set(50, 50, 1.0); 
            sunMesh.add(lightSprite);

            // Cada sol necesita una luz para iluminar a los planetas a su alrededor
            const sunLight = new THREE.PointLight(0xffffff, 3.0, 0, 0); 
            sunLight.position.copy(position);
            scene.add(sunLight);

            // Se almacena el mesh para acceder a su posición Vector3
            suns.push({ mesh: sunMesh, light: sunLight, mass: SUN_MASS });
            
            // --- NUEVA LÓGICA: CAMBIAR LA CANCIÓN AL CREAR UN NUEVO SOL ---
            if (suns.length > 1 && musicStarted) {
                changeSong();
            }
        }


        /**
         * Crea un campo de estrellas aleatorias para el fondo.
         */
        function createStarField() {
            const starCount = 1500;
            const starGeometry = new THREE.BufferGeometry();
            const positions = [];
            
            const radius = 500; 

            for (let i = 0; i < starCount; i++) {
                const x = THREE.MathUtils.randFloatSpread(radius * 2);
                const y = THREE.MathUtils.randFloatSpread(radius * 2);
                const z = THREE.MathUtils.randFloatSpread(radius * 2);

                positions.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1, 
                sizeAttenuation: true 
            });

            starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }
        
        /**
         * Genera una textura circular suave con degradado para simular un brillo (flare).
         */
        function generateRadialTexture() {
            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');

            const gradient = context.createRadialGradient(
                size / 2, size / 2, 0, 
                size / 2, size / 2, size / 2 
            );
            gradient.addColorStop(0, 'rgba(255,255,255,1)'); 
            gradient.addColorStop(1, 'rgba(255,255,255,0)'); 

            context.fillStyle = gradient;
            context.fillRect(0, 0, size, size);

            return new THREE.CanvasTexture(canvas);
        }

        /**
         * Configura los eventos de mouse y touch para el control de la cámara.
         */
        function setupPointerControls(element) {
            element.addEventListener('pointerdown', onPointerDown, false);
            element.addEventListener('pointermove', onPointerMove, false);
            element.addEventListener('pointerup', onPointerUp, false);
            element.addEventListener('pointerleave', onPointerUp, false);
        }

        /**
         * Evento al pulsar (clic o tocar).
         */
        function onPointerDown(event) {
            if (event.buttons === 1 || event.pointerType === 'touch') { 
                isPointerActive = true; 
                isDragging = false; 
                
                pointerStart.x = event.clientX;
                pointerStart.y = event.clientY;

                previousPointerPosition.x = event.clientX;
                previousPointerPosition.y = event.clientY;
                velocityX = 0;
                velocityY = 0;
            }
        }

        /**
         * Evento al mover el puntero (arrastrar).
         */
        function onPointerMove(event) {
            
            if (!isPointerActive) return; 

            if (!isDragging) {
                const deltaMovementX = event.clientX - pointerStart.x;
                const deltaMovementY = event.clientY - pointerStart.y;
                const distance = Math.sqrt(deltaMovementX * deltaMovementX + deltaMovementY * deltaMovementY); 
                
                if (distance > DRAG_THRESHOLD) {
                    isDragging = true; 
                }
            }

            if (isDragging) { 
                const deltaX = event.clientX - previousPointerPosition.x;
                const deltaY = event.clientY - previousPointerPosition.y;

                theta += deltaX * ROTATION_MULTIPLIER;
                phi -= deltaY * ROTATION_MULTIPLIER;
                
                velocityX = deltaX * ROTATION_MULTIPLIER * 0.5;
                velocityY = deltaY * ROTATION_MULTIPLIER * 0.5;

                previousPointerPosition.x = event.clientX;
                previousPointerPosition.y = event.clientY;
            }
        }

        /**
         * Evento al soltar (dejar de arrastrar o crear entidad).
         */
        function onPointerUp(event) {
            if (isPointerActive && !isDragging) { 
                const entitySelect = document.getElementById('entitySelect');
                const selectedEntity = entitySelect ? entitySelect.value : 'planet';
                
                if (selectedEntity === 'planet') {
                    createPlanet(event);
                } else if (selectedEntity === 'sun') {
                    createSunOnClick(event);
                }
            }
            
            isDragging = false; 
            isPointerActive = false; 
        }

        /**
         * Intenta crear un Sol en la posición del click/toque.
         */
        function createSunOnClick(event) {
            // Mapeo de coordenadas de pantalla a un punto en el espacio 3D
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // Proyectar en el plano Y=0 (el "suelo" de la simulación)
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); 
            const intersection = new THREE.Vector3();
            
            raycaster.ray.intersectPlane(plane, intersection);

            // Limitar la distancia del Sol para evitar que aparezca muy lejos
            if (intersection.length() > MAX_SUN_DISTANCE) {
                intersection.normalize().multiplyScalar(MAX_SUN_DISTANCE);
                showMessage('Sol colocado en el límite de la zona central.', 2000, new THREE.Color(0xfacc15));
            }


            createSunAtPosition(intersection);
            showMessage('¡Nuevo Sol Creado! Ahora afecta la gravedad.', 2000, new THREE.Color(0xfacc15));
        }

        /**
         * Crea un nuevo planeta.
         * @param {PointerEvent} event El evento de puntero (contiene clientX/Y).
         */
        function createPlanet(event) {
            startAudioContext(); 

            if (suns.length === 0) {
                showMessage('No hay soles para orbitar. ¡Crea un Sol primero!', 3000, new THREE.Color(0xef4444));
                return;
            }
            
            // Mapeo de coordenadas de pantalla a un punto en el espacio 3D
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // Proyectar en el plano Y=0 (el "suelo" de la simulación)
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); 
            const intersection = new THREE.Vector3();
            
            raycaster.ray.intersectPlane(plane, intersection);
            const initialPosition = intersection.clone();

            // --- 1. ENCONTRAR EL SOL MÁS CERCANO PARA INICIALIZAR LA ÓRBITA ---
            const nearestSun = findNearestSun(initialPosition);
            
            // Usamos la posición del mesh del sol para la física
            const relativePosition = initialPosition.clone().sub(nearestSun.mesh.position);
            const distance = relativePosition.length();

            // VERIFICACIÓN DE SEGURIDAD CRÍTICA: La distancia NO debe ser 0.
            if (distance < COLLISION_DISTANCE) {
                showMessage('Demasiado cerca del Sol. Intenta más lejos.', 3000, new THREE.Color(0xfacc15));
                return;
            }

            // 2. CÁLCULO DE VELOCIDAD INICIAL (para órbita circular aproximada alrededor del Sol más cercano)
            
            // Magnitud de la velocidad orbital: v = sqrt(G*M/r)
            const orbitVelocityMag = Math.sqrt((GRAVITATIONAL_CONSTANT * SUN_MASS) / distance);
            
            // Dirección de la velocidad: perpendicular al vector posición (para iniciar la órbita)
            const positionUnit = relativePosition.clone().normalize();
            
            // Crea un vector perpendicular para la velocidad inicial (Vector3 perpendicular a positionUnit y Y-axis)
            let initialVelocity = new THREE.Vector3().crossVectors(positionUnit, new THREE.Vector3(0, 1, 0));
            
            // CORRECCIÓN CRÍTICA: Asegurar que el vector de velocidad no sea nulo si el producto cruz falla
            if (initialVelocity.lengthSq() < 0.001) {
                // Si falla (ej. el planeta está exactamente en el eje Y), usa una dirección arbitraria perpendicular (Eje X)
                 initialVelocity.set(1, 0, 0); 
            }
            
            // Velocidad inicial ajustada (0.99 a 1.01) para asegurar una órbita estable
            initialVelocity.normalize().multiplyScalar(orbitVelocityMag * THREE.MathUtils.randFloat(0.99, 1.01));

            // Añadir una pequeña componente Y para dar una inclinación 3D inicial
            initialVelocity.y = THREE.MathUtils.randFloatSpread(orbitVelocityMag * 0.1); 

            // 3. GENERAR EL RESTO DE PROPIEDADES
            const radius = THREE.MathUtils.randFloat(1, 4); 
            
            const baseColor = new THREE.Color(Math.random(), Math.random(), Math.random());
            const hsl = {};
            baseColor.getHSL(hsl);
            hsl.l = THREE.MathUtils.randFloat(0.7, 0.9);
            hsl.s = THREE.MathUtils.randFloat(0.4, 0.8); 
            const brightColor = new THREE.Color().setHSL(hsl.h, hsl.s, hsl.l);


            // 4. Configuración de AUDIO (Solo asignación de capa)
            
            // Asignación de Capa (El instrumento al que se asigna este planeta)
            // Asigna la siguiente capa del MIDI que no tenga un planeta activo
            const activeLayersCount = planets.filter(p => p.assignedLayer).length;
            const layerIndex = activeLayersCount % INSTRUMENT_LAYERS.length;
            const assignedLayer = INSTRUMENT_LAYERS[layerIndex];
            
            // Crear un objeto dummy para audio
            const { synth, panner } = createSynth(); 
            
            // 5. Malla y Rastro (similar al código anterior)
            const planetGeometry = new THREE.SphereGeometry(radius, 32, 32);
            const planetMaterial = new THREE.MeshLambertMaterial({ 
                color: brightColor, 
                emissive: brightColor.clone().multiplyScalar(0.1) 
            });
            const planetMesh = new THREE.Mesh(planetGeometry, planetMaterial);
            planetMesh.position.copy(initialPosition);

            const orbitPositions = new Float32Array(TRAIL_LENGTH * 3); 
            const drawingPositions = new Float32Array(TRAIL_LENGTH * 3);
            
            // Creación del Array de Colores (RGBA: 4 componentes por punto)
            const trailColors = new Float32Array(TRAIL_LENGTH * 4); 

            const trailGeometry = new THREE.BufferGeometry();
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(drawingPositions, 3)); 
            trailGeometry.setAttribute('color', new THREE.BufferAttribute(trailColors, 4)); // Añadir atributo de color/opacidad
            
            const trailMaterial = new THREE.LineBasicMaterial({
                color: brightColor, 
                transparent: true,
                opacity: 1.0,
                vertexColors: true // Usar colores definidos por el vértice
            });
            const orbitTrail = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(orbitTrail);

            // 6. Crear Objeto para el planeta (PROPIEDADES DE FÍSICA Y AUDIO)
            const planetObject = {
                mesh: planetMesh,
                trail: orbitTrail,
                orbitPositions: orbitPositions, 
                trailColors: trailColors, // Almacenar el array de colores
                planetColor: brightColor, // Color base del planeta
                trailIndex: 0,
                trailLength: TRAIL_LENGTH,
                trailCount: 0,
                // PROPIEDADES DE FÍSICA
                mass: PLANET_MASS,
                velocity: initialVelocity, // Vector3
                acceleration: new THREE.Vector3(0, 0, 0), // Vector3
                // PROPIEDADES DE AUDIO
                synth: synth,
                panner: panner, // Nuevo panner
                assignedLayer: assignedLayer, // Capa de la canción asignada (Ej: 'Cancion1_1')
                // PROPIEDADES DE TRIVIA
                id: planets.length + 1, // Asignar un ID para identificarlo en la trivia
                pulseTypeName: `Pista: ${assignedLayer}` // Nombre legible
            };

            scene.add(planetMesh);
            planets.push(planetObject);
            
            // --- ACTUALIZACIÓN DE VOLUMENES (Lógica visual de estado) ---
            updateAudioVolumes();
            // ---------------------------------------------
            
            // CAMBIO AQUÍ: Simplificamos el mensaje
            showMessage('¡Planeta Creado!', 1500, brightColor);
        }

        /**
         * Alterna el estado de pausa de la simulación y la música.
         */
        function togglePause() {
            isPaused = !isPaused;
            const button = document.getElementById('pauseButton');
            
            if (isPaused) {
                button.textContent = 'Reanudar Simulación';
                button.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                button.classList.add('bg-green-600', 'hover:bg-green-700');
                showMessage('Simulación PAUSADA.', 1500, new THREE.Color(0xfb923c));
                // Lógica para pausar el audio (si estuviera activo)
                if (musicStarted) { Tone.Transport.pause(); }
            } else {
                button.textContent = 'Pausar Simulación';
                button.classList.remove('bg-green-600', 'hover:bg-green-700');
                button.classList.add('bg-blue-600', 'hover:bg-blue-700');
                showMessage('Simulación REANUDADA.', 1500, new THREE.Color(0x22c55e));
                // Lógica para reanudar el audio (si estuviera activo)
                if (musicStarted) { Tone.Transport.start(); }
            }
        }

        /**
         * Elimina todos los planetas, soles, sus rastros y sus sintetizadores.
         */
        function clearSimulation() {
            const initialSuns = suns.length;
            
            // Limpieza de estados
            musicStarted = false;
            currentSongIndex = 0;
            INSTRUMENT_LAYERS = SONG_DATA_STRUCTURES[0].layers;
            
            // Detener el audio
            Tone.Transport.stop();
            Tone.Transport.cancel();
            Tone.Master.mute = true;


            // Limpieza de Planetas
            planets.forEach(planet => {
                scene.remove(planet.mesh);
                scene.remove(planet.trail);
            });
            planets.length = 0;

            // Limpieza de Soles
            suns.forEach(sun => {
                scene.remove(sun.mesh);
                scene.remove(sun.light);
            });
            suns.length = 0;
            
            // Vuelve a crear el sol inicial
            if (initialSuns === 0) {
                 createInitialSun(); 
            } else {
                // Si el audio estaba cargado, recargar la canción inicial
                if (isAudioContextStarted && currentMidiData) {
                    loadMidiAndSetup(0); // Recargar la primera canción
                }
            }
            
            showMessage('Simulación Reiniciada. ¡Crea nuevos sistemas!', 2500, new THREE.Color(0xef4444));
        }

        /**
         * Maneja el redimensionamiento de la ventana para mantener la vista correcta.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // =================================================================
        // LÓGICA MIDI REAL
        // =================================================================

        /**
         * Inicializa los Samplers de Tone.js (instrumentos reales).
         */
        async function setupMidiPlayers() {
            // Un mapa simple de Instrumentos General MIDI (GM) a sonidos de Sampler
            const GM_INSTRUMENT_MAP = {
                'piano': 'piano', 'bass': 'bass-electric', 'drums': 'drums', 'brass': 'trumpet', 
                'synth': 'synth_lead', 'strings': 'violin', 'guitar': 'guitar-acoustic'
            };
            
            const samplerPromises = [];
            
            // Solo necesitamos 10 Samplers, uno por cada posible pista activa
            for (let i = 0; i < TRACKS_PER_SONG; i++) {
                // Usamos una clave genérica para los Samplers (siempre se cargará piano por estabilidad)
                const sampler = new Tone.Sampler({
                    urls: { "C4": `piano-c4.mp3` }, 
                    baseUrl: "https://tonejs.github.io/audio/salamander/", 
                    onload: () => {
                        sampler.volume.value = -100; // Silenciado por defecto
                        sampler.toDestination();
                    },
                    onerror: (e) => {
                        console.error(`Error al cargar sampler:`, e);
                    }
                }).toDestination();
                
                midiPlayers.push(sampler);
                samplerPromises.push(new Promise(resolve => sampler.onload = resolve));
            }
            
            await Promise.all(samplerPromises);
            
            // Una vez cargados los 10 Samplers, procedemos a cargar la primera canción MIDI
            await loadMidiAndSetup(currentSongIndex);
        }
        
        /**
         * Inicia el secuenciador de Tone.js con los datos MIDI.
         * @param {number} songIndex Índice de la canción a cargar
         */
        function startSequencer(midiArray) {
            Tone.Transport.cancel();
            
            // Usamos el BPM del primer archivo MIDI
            Tone.Transport.bpm.value = midiArray[0].header.tempos[0].bpm || 128; 

            midiArray.slice(0, TRACKS_PER_SONG).forEach((midi, i) => {
                const track = midi.tracks.length > 0 ? midi.tracks[0] : null; 
                if (!track) return;

                const notes = track.notes;
                const player = midiPlayers[i];

                const part = new Tone.Part((time, note) => {
                    // Solo reproducimos si la capa está activa (activada por un planeta)
                    if (activePatterns[INSTRUMENT_LAYERS[i]]) {
                        player.triggerAttackRelease(
                            note.name, 
                            note.duration, 
                            time, 
                            note.velocity
                        );

                        // Visualización rítmica (parpadeo del planeta)
                        Tone.Draw.schedule(() => {
                            activeNotes[INSTRUMENT_LAYERS[i]] = true;
                            setTimeout(() => activeNotes[INSTRUMENT_LAYERS[i]] = false, Tone.Time(note.duration).toMilliseconds() * 0.5);
                        }, time);
                    }
                }, notes).start(0);

                part.loop = true;
                part.loopEnd = midi.duration || "4m";
            });

            // Usamos la duración del primer MIDI como duración del loop principal
            Tone.Transport.loop = true;
            Tone.Transport.loopEnd = midiArray[0].duration || "4m";
            
            Tone.Transport.start();
            showMessage(`¡Música ${SONG_DATA_STRUCTURES[currentSongIndex].name} lista! Crea tu primer planeta.`, 2000, new THREE.Color(0x22c55e));
        }

        /**
         * Carga el archivo MIDI de forma asíncrona.
         */
        async function loadMidiAndSetup(songIndex) {
             showMessage(`Cargando partitura MIDI para ${SONG_DATA_STRUCTURES[songIndex].name}...`, 3000, new THREE.Color(0xfacc15));
             
             // 1. Crear 10 promesas de carga para las 10 pistas
             const midiPromises = [];
             for(let i = 0; i < TRACKS_PER_SONG; i++) {
                 const MIDI_PATH = getTrackPath(songIndex, i); 
                 
                 // Usamos fetch para asegurar que el navegador pueda acceder al archivo
                 const loadPromise = fetch(MIDI_PATH)
                     .then(response => {
                         if (!response.ok) {
                             // Si no se encuentra el archivo (Error 404), no lanzamos error fatal, devolvemos un MIDI vacío
                             console.warn(`Advertencia: Pista ${i + 1} (${MIDI_PATH}) no encontrada. La pista estará en silencio.`);
                             return { tracks: [], duration: 0, header: { tempos: [{ bpm: 128 }] } };
                         }
                         return response.arrayBuffer();
                     })
                     .then(arrayBuffer => Midi.fromBuffer(arrayBuffer))
                     .catch(e => {
                         console.error(`Fallo al procesar Pista ${i + 1}:`, e);
                         // Devolver un objeto MIDI vacío si hay un fallo en el procesamiento
                         return { tracks: [], duration: 0, header: { tempos: [{ bpm: 128 }] } }; 
                     });
                 
                 midiPromises.push(loadPromise);
             }
            
            // 2. Esperar a que todos los archivos MIDI carguen
            const loadedMidis = await Promise.all(midiPromises);
            
            // 3. Almacenar y comenzar la secuencia
            currentMidiData = loadedMidis; 
            
            // 4. Iniciar el secuenciador con el array de midis
            startSequencer(loadedMidis);
        }

        /**
         * Función dummy para mantener la estructura de planet.synth (ahora solo mute/unmute)
         */
        function createSynth() {
            return { synth: null, panner: null }; 
        }

        /**
         * Inicia el contexto de audio y la carga del MIDI.
         */
        function startAudioContext() {
            if (!isAudioContextStarted) {
                // Iniciar el Contexto de Audio con interacción del usuario
                Tone.start(); 
                isAudioContextStarted = true;
                
                // Iniciar la carga de Samplers y MIDI
                setupMidiPlayers();
            }
        }
        
        /**
         * Función que cambia la canción al crear un nuevo Sol.
         */
        function changeSong() {
            // Ciclo a la siguiente canción
            currentSongIndex = (currentSongIndex + 1) % TOTAL_SONGS; 
            
            // 1. Limpiar patrones visuales
            activePatterns = {};
            planets.forEach(p => p.assignedLayer = INSTRUMENT_LAYERS[0]);
            
            // 2. Actualizar las capas de instrumento disponibles (para la UI)
            INSTRUMENT_LAYERS = SONG_DATA_STRUCTURES[currentSongIndex].layers;

            // 3. Cargar la nueva canción MIDI
            // NOTA: No esperamos aquí, el resto de la app es asíncrona.
            loadMidiAndSetup(currentSongIndex); 
            
            // 4. Actualizar volumen (silenciar capas)
            updateAudioVolumes();
            
            showMessage(`Música cambiada a: ${SONG_DATA_STRUCTURES[currentSongIndex].name}`, 2000, new THREE.Color(0xfacc15));
        }
        
        /**
         * Controla qué patrones rítmicos están activos (solo lógica, sin audio).
         */
        function updateAudioVolumes() {
            // 1. Mapear qué capas están activas visualmente (para el MIDI)
            INSTRUMENT_LAYERS.forEach(layer => activePatterns[layer] = false);
            
            planets.forEach((planet, index) => {
                const layerIndex = index % TRACKS_PER_SONG;
                const layerName = INSTRUMENT_LAYERS[layerIndex];
                
                planet.assignedLayer = layerName;
                activePatterns[layerName] = true;
                
                // Controlar el volumen real del sampler (si existe)
                if (midiPlayers[layerIndex]) {
                    midiPlayers[layerIndex].volume.value = 0; // Activar (0dB)
                }
            });
            
            // Silenciar las capas sin planeta
            for (let i = planets.length; i < TRACKS_PER_SONG; i++) {
                 if (midiPlayers[i]) {
                    midiPlayers[i].volume.value = -100; // Silenciar
                 }
            }


            // 3. Controlar el estado general 
            if (planets.length > 0 && !musicStarted) {
                musicStarted = true;
                Tone.Master.mute = false; // Desmutear la música
            } else if (planets.length === 0 && musicStarted) {
                musicStarted = false;
                Tone.Master.mute = true; // Mutear todo
            }
        }


        // =================================================================
        // FUNCIONES DE FÍSICA
        // =================================================================

        /**
         * Calcula la aceleración gravitacional neta sobre el planeta causada por todos los soles.
         * F = G * M1 * M2 / r^2
         * A = F / M2 = G * M1 / r^2
         * @param {object} planet El objeto planeta con posición, masa y aceleración.
         */
        function calculateGravity(planet) {
            const netAcceleration = new THREE.Vector3(0, 0, 0);

            suns.forEach(sun => {
                // Vector que apunta del planeta al sol
                const direction = tempVector.copy(sun.mesh.position).sub(planet.mesh.position);
                const distanceSq = direction.lengthSq();

                // Evitar división por cero o fuerzas infinitas en colisión cercana
                if (distanceSq < 1) { 
                    return;
                }
                
                const distance = Math.sqrt(distanceSq);

                // Fuerza gravitacional: A = (G * M_sol / r^2) * (vector unitario)
                const magnitude = (GRAVITATIONAL_CONSTANT * SUN_MASS) / distanceSq;

                // Asegurar que la fuerza no sea demasiado grande a corta distancia
                const maxMagnitude = 5.0; // Límite de aceleración para estabilidad
                const finalMagnitude = Math.min(magnitude, maxMagnitude);

                direction.normalize().multiplyScalar(finalMagnitude);
                
                netAcceleration.add(direction);
            });

            planet.acceleration = netAcceleration;
        }

        /**
         * Aplica la integración de Euler para actualizar la velocidad y posición.
         * @param {object} planet El objeto planeta.
         * @param {number} deltaTime El paso de tiempo.
         */
        function updatePhysics(planet, deltaTime) {
            // Velocidad = Velocidad + Aceleración * dt
            planet.velocity.add(planet.acceleration.clone().multiplyScalar(deltaTime));
            
            // Posición = Posición + Velocidad * dt
            planet.mesh.position.add(planet.velocity.clone().multiplyScalar(deltaTime));
        }

        /**
         * Encuentra el Sol más cercano al punto de click.
         * @param {THREE.Vector3} clickPosition Posición 3D del click.
         * @returns {object} El objeto Sol más cercano.
         */
        function findNearestSun(clickPosition) {
            let minDistanceSq = Infinity;
            let nearestSun = null;
            
            suns.forEach(sun => {
                // Usamos subVectors y lengthSq para calcular la distancia.
                const diffVector = new THREE.Vector3().subVectors(sun.mesh.position, clickPosition);
                const distanceSq = diffVector.lengthSq(); 
                
                if (distanceSq < minDistanceSq) {
                    minDistanceSq = distanceSq;
                    nearestSun = sun;
                }
            });

            return nearestSun;
        }

        // =================================================================
        // UTILIDADES
        // =================================================================

        /**
         * Inicializa la escena, cámara, renderizador y luces.
         */
        function init() {
            // 1. Configuración de la Escena
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0d0d1a, 0.003); 

            // 2. Configuración de la Cámara (perspectiva para 3D)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, ORBIT_RADIUS); // Posición inicial aumentada a 250
            
            // 3. Configuración del Renderizador (WebGL)
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1);
            // Añadir una clase para apuntar con CSS si queremos aumentar el grosor de línea
            renderer.domElement.classList.add('webgl-canvas'); 
            document.getElementById('container').appendChild(renderer.domElement);
            
            // 4. Configuración de la Iluminación
            ambientLight = new THREE.AmbientLight(0x404040, 0.5); 
            scene.add(ambientLight);

            // 5. Crear el Sol Central Inicial y el Fondo de Estrellas
            createInitialSun(); 
            createStarField(); 
            
            // 6. Manejadores de Eventos
            window.addEventListener('resize', onWindowResize, false);
            setupPointerControls(renderer.domElement);
        }

        /**
         * Crea el primer Sol al iniciar la simulación.
         */
        function createInitialSun() {
            // Sol inicial ligeramente desplazado para evitar la singularidad de la órbita inicial
            const center = new THREE.Vector3(5, 0, 0); 
            createSunAtPosition(center);
        }

        /**
         * Crea un objeto Sol y lo añade a la escena y al array de Soles.
         * @param {THREE.Vector3} position Posición del nuevo sol.
         */
        function createSunAtPosition(position) {
            const sunRadius = 12;
            const sunGeometry = new THREE.SphereGeometry(sunRadius, 32, 32); 
            const sunMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                emissive: 0xff8800 
            }); 
            const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            sunMesh.position.copy(position);
            scene.add(sunMesh);
            
            const flareTexture = generateRadialTexture(); 

            const lightSprite = new THREE.Sprite(new THREE.SpriteMaterial({
                map: flareTexture,
                color: 0xff8800, 
                blending: THREE.AdditiveBlending, 
                transparent: true,
                opacity: 0.7 
            }));
            lightSprite.scale.set(50, 50, 1.0); 
            sunMesh.add(lightSprite);

            // Cada sol necesita una luz para iluminar a los planetas a su alrededor
            const sunLight = new THREE.PointLight(0xffffff, 3.0, 0, 0); 
            sunLight.position.copy(position);
            scene.add(sunLight);

            // Se almacena el mesh para acceder a su posición Vector3
            suns.push({ mesh: sunMesh, light: sunLight, mass: SUN_MASS });
            
            // --- NUEVA LÓGICA: CAMBIAR LA CANCIÓN AL CREAR UN NUEVO SOL ---
            if (suns.length > 1 && musicStarted) {
                changeSong();
            }
        }


        /**
         * Crea un campo de estrellas aleatorias para el fondo.
         */
        function createStarField() {
            const starCount = 1500;
            const starGeometry = new THREE.BufferGeometry();
            const positions = [];
            
            const radius = 500; 

            for (let i = 0; i < starCount; i++) {
                const x = THREE.MathUtils.randFloatSpread(radius * 2);
                const y = THREE.MathUtils.randFloatSpread(radius * 2);
                const z = THREE.MathUtils.randFloatSpread(radius * 2);

                positions.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1, 
                sizeAttenuation: true 
            });

            starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }
        
        /**
         * Genera una textura circular suave con degradado para simular un brillo (flare).
         */
        function generateRadialTexture() {
            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');

            const gradient = context.createRadialGradient(
                size / 2, size / 2, 0, 
                size / 2, size / 2, size / 2 
            );
            gradient.addColorStop(0, 'rgba(255,255,255,1)'); 
            gradient.addColorStop(1, 'rgba(255,255,255,0)'); 

            context.fillStyle = gradient;
            context.fillRect(0, 0, size, size);

            return new THREE.CanvasTexture(canvas);
        }

        /**
         * Configura los eventos de mouse y touch para el control de la cámara.
         */
        function setupPointerControls(element) {
            element.addEventListener('pointerdown', onPointerDown, false);
            element.addEventListener('pointermove', onPointerMove, false);
            element.addEventListener('pointerup', onPointerUp, false);
            element.addEventListener('pointerleave', onPointerUp, false);
        }

        /**
         * Evento al pulsar (clic o tocar).
         */
        function onPointerDown(event) {
            if (event.buttons === 1 || event.pointerType === 'touch') { 
                isPointerActive = true; 
                isDragging = false; 
                
                pointerStart.x = event.clientX;
                pointerStart.y = event.clientY;

                previousPointerPosition.x = event.clientX;
                previousPointerPosition.y = event.clientY;
                velocityX = 0;
                velocityY = 0;
            }
        }

        /**
         * Evento al mover el puntero (arrastrar).
         */
        function onPointerMove(event) {
            
            if (!isPointerActive) return; 

            if (!isDragging) {
                const deltaMovementX = event.clientX - pointerStart.x;
                const deltaMovementY = event.clientY - pointerStart.y;
                const distance = Math.sqrt(deltaMovementX * deltaMovementX + deltaMovementY * deltaMovementY); 
                
                if (distance > DRAG_THRESHOLD) {
                    isDragging = true; 
                }
            }

            if (isDragging) { 
                const deltaX = event.clientX - previousPointerPosition.x;
                const deltaY = event.clientY - previousPointerPosition.y;

                theta += deltaX * ROTATION_MULTIPLIER;
                phi -= deltaY * ROTATION_MULTIPLIER;
                
                velocityX = deltaX * ROTATION_MULTIPLIER * 0.5;
                velocityY = deltaY * ROTATION_MULTIPLIER * 0.5;

                previousPointerPosition.x = event.clientX;
                previousPointerPosition.y = event.clientY;
            }
        }

        /**
         * Evento al soltar (dejar de arrastrar o crear entidad).
         */
        function onPointerUp(event) {
            if (isPointerActive && !isDragging) { 
                const entitySelect = document.getElementById('entitySelect');
                const selectedEntity = entitySelect ? entitySelect.value : 'planet';
                
                if (selectedEntity === 'planet') {
                    createPlanet(event);
                } else if (selectedEntity === 'sun') {
                    createSunOnClick(event);
                }
            }
            
            isDragging = false; 
            isPointerActive = false; 
        }

        /**
         * Intenta crear un Sol en la posición del click/toque.
         */
        function createSunOnClick(event) {
            // Mapeo de coordenadas de pantalla a un punto en el espacio 3D
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // Proyectar en el plano Y=0 (el "suelo" de la simulación)
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); 
            const intersection = new THREE.Vector3();
            
            raycaster.ray.intersectPlane(plane, intersection);

            // Limitar la distancia del Sol para evitar que aparezca muy lejos
            if (intersection.length() > MAX_SUN_DISTANCE) {
                intersection.normalize().multiplyScalar(MAX_SUN_DISTANCE);
                showMessage('Sol colocado en el límite de la zona central.', 2000, new THREE.Color(0xfacc15));
            }


            createSunAtPosition(intersection);
            showMessage('¡Nuevo Sol Creado! Ahora afecta la gravedad.', 2000, new THREE.Color(0xfacc15));
        }

        /**
         * Crea un nuevo planeta.
         * @param {PointerEvent} event El evento de puntero (contiene clientX/Y).
         */
        function createPlanet(event) {
            startAudioContext(); 

            if (suns.length === 0) {
                showMessage('No hay soles para orbitar. ¡Crea un Sol primero!', 3000, new THREE.Color(0xef4444));
                return;
            }
            
            // Mapeo de coordenadas de pantalla a un punto en el espacio 3D
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // Proyectar en el plano Y=0 (el "suelo" de la simulación)
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); 
            const intersection = new THREE.Vector3();
            
            raycaster.ray.intersectPlane(plane, intersection);
            const initialPosition = intersection.clone();

            // --- 1. ENCONTRAR EL SOL MÁS CERCANO PARA INICIALIZAR LA ÓRBITA ---
            const nearestSun = findNearestSun(initialPosition);
            
            // Usamos la posición del mesh del sol para la física
            const relativePosition = initialPosition.clone().sub(nearestSun.mesh.position);
            const distance = relativePosition.length();

            // VERIFICACIÓN DE SEGURIDAD CRÍTICA: La distancia NO debe ser 0.
            if (distance < COLLISION_DISTANCE) {
                showMessage('Demasiado cerca del Sol. Intenta más lejos.', 3000, new THREE.Color(0xfacc15));
                return;
            }

            // 2. CÁLCULO DE VELOCIDAD INICIAL (para órbita circular aproximada alrededor del Sol más cercano)
            
            // Magnitud de la velocidad orbital: v = sqrt(G*M/r)
            const orbitVelocityMag = Math.sqrt((GRAVITATIONAL_CONSTANT * SUN_MASS) / distance);
            
            // Dirección de la velocidad: perpendicular al vector posición (para iniciar la órbita)
            const positionUnit = relativePosition.clone().normalize();
            
            // Crea un vector perpendicular para la velocidad inicial (Vector3 perpendicular a positionUnit y Y-axis)
            let initialVelocity = new THREE.Vector3().crossVectors(positionUnit, new THREE.Vector3(0, 1, 0));
            
            // CORRECCIÓN CRÍTICA: Asegurar que el vector de velocidad no sea nulo si el producto cruz falla
            if (initialVelocity.lengthSq() < 0.001) {
                // Si falla (ej. el planeta está exactamente en el eje Y), usa una dirección arbitraria perpendicular (Eje X)
                 initialVelocity.set(1, 0, 0); 
            }
            
            // Velocidad inicial ajustada (0.99 a 1.01) para asegurar una órbita estable
            initialVelocity.normalize().multiplyScalar(orbitVelocityMag * THREE.MathUtils.randFloat(0.99, 1.01));

            // Añadir una pequeña componente Y para dar una inclinación 3D inicial
            initialVelocity.y = THREE.MathUtils.randFloatSpread(orbitVelocityMag * 0.1); 

            // 3. GENERAR EL RESTO DE PROPIEDADES
            const radius = THREE.MathUtils.randFloat(1, 4); 
            
            const baseColor = new THREE.Color(Math.random(), Math.random(), Math.random());
            const hsl = {};
            baseColor.getHSL(hsl);
            hsl.l = THREE.MathUtils.randFloat(0.7, 0.9);
            hsl.s = THREE.MathUtils.randFloat(0.4, 0.8); 
            const brightColor = new THREE.Color().setHSL(hsl.h, hsl.s, hsl.l);


            // 4. Configuración de AUDIO (Solo asignación de capa)
            
            // Asignación de Capa (El instrumento al que se asigna este planeta)
            // Asigna la siguiente capa del MIDI que no tenga un planeta activo
            const activeLayersCount = planets.filter(p => p.assignedLayer).length;
            const layerIndex = activeLayersCount % INSTRUMENT_LAYERS.length;
            const assignedLayer = INSTRUMENT_LAYERS[layerIndex];
            
            // Crear un objeto dummy para audio
            const { synth, panner } = createSynth(); 
            
            // 5. Malla y Rastro (similar al código anterior)
            const planetGeometry = new THREE.SphereGeometry(radius, 32, 32);
            const planetMaterial = new THREE.MeshLambertMaterial({ 
                color: brightColor, 
                emissive: brightColor.clone().multiplyScalar(0.1) 
            });
            const planetMesh = new THREE.Mesh(planetGeometry, planetMaterial);
            planetMesh.position.copy(initialPosition);

            const orbitPositions = new Float32Array(TRAIL_LENGTH * 3); 
            const drawingPositions = new Float32Array(TRAIL_LENGTH * 3);
            
            // Creación del Array de Colores (RGBA: 4 componentes por punto)
            const trailColors = new Float32Array(TRAIL_LENGTH * 4); 

            const trailGeometry = new THREE.BufferGeometry();
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(drawingPositions, 3)); 
            trailGeometry.setAttribute('color', new THREE.BufferAttribute(trailColors, 4)); // Añadir atributo de color/opacidad
            
            const trailMaterial = new THREE.LineBasicMaterial({
                color: brightColor, 
                transparent: true,
                opacity: 1.0,
                vertexColors: true // Usar colores definidos por el vértice
            });
            const orbitTrail = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(orbitTrail);

            // 6. Crear Objeto para el planeta (PROPIEDADES DE FÍSICA Y AUDIO)
            const planetObject = {
                mesh: planetMesh,
                trail: orbitTrail,
                orbitPositions: orbitPositions, 
                trailColors: trailColors, // Almacenar el array de colores
                planetColor: brightColor, // Color base del planeta
                trailIndex: 0,
                trailLength: TRAIL_LENGTH,
                trailCount: 0,
                // PROPIEDADES DE FÍSICA
                mass: PLANET_MASS,
                velocity: initialVelocity, // Vector3
                acceleration: new THREE.Vector3(0, 0, 0), // Vector3
                // PROPIEDADES DE AUDIO
                synth: synth,
                panner: panner, // Nuevo panner
                assignedLayer: assignedLayer, // Capa de la canción asignada (Ej: 'Cancion1_1')
                // PROPIEDADES DE TRIVIA
                id: planets.length + 1, // Asignar un ID para identificarlo en la trivia
                pulseTypeName: `Pista: ${assignedLayer}` // Nombre legible
            };

            scene.add(planetMesh);
            planets.push(planetObject);
            
            // --- ACTUALIZACIÓN DE VOLUMENES (Lógica visual de estado) ---
            updateAudioVolumes();
            // ---------------------------------------------
            
            // CAMBIO AQUÍ: Simplificamos el mensaje
            showMessage('¡Planeta Creado!', 1500, brightColor);
        }

        /**
         * Alterna el estado de pausa de la simulación y la música.
         */
        function togglePause() {
            isPaused = !isPaused;
            const button = document.getElementById('pauseButton');
            
            if (isPaused) {
                button.textContent = 'Reanudar Simulación';
                button.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                button.classList.add('bg-green-600', 'hover:bg-green-700');
                showMessage('Simulación PAUSADA.', 1500, new THREE.Color(0xfb923c));
                // Lógica para pausar el audio (si estuviera activo)
                if (musicStarted) { Tone.Transport.pause(); }
            } else {
                button.textContent = 'Pausar Simulación';
                button.classList.remove('bg-green-600', 'hover:bg-green-700');
                button.classList.add('bg-blue-600', 'hover:bg-blue-700');
                showMessage('Simulación REANUDADA.', 1500, new THREE.Color(0x22c55e));
                // Lógica para reanudar el audio (si estuviera activo)
                if (musicStarted) { Tone.Transport.start(); }
            }
        }

        /**
         * Elimina todos los planetas, soles, sus rastros y sus sintetizadores.
         */
        function clearSimulation() {
            const initialSuns = suns.length;
            
            // Limpieza de estados
            musicStarted = false;
            currentSongIndex = 0;
            INSTRUMENT_LAYERS = SONG_DATA_STRUCTURES[0].layers;
            
            // Detener el audio
            Tone.Transport.stop();
            Tone.Transport.cancel();
            Tone.Master.mute = true;


            // Limpieza de Planetas
            planets.forEach(planet => {
                scene.remove(planet.mesh);
                scene.remove(planet.trail);
            });
            planets.length = 0;

            // Limpieza de Soles
            suns.forEach(sun => {
                scene.remove(sun.mesh);
                scene.remove(sun.light);
            });
            suns.length = 0;
            
            // Vuelve a crear el sol inicial
            if (initialSuns === 0) {
                 createInitialSun(); 
            } else {
                // Si el audio estaba cargado, recargar la canción inicial
                if (isAudioContextStarted && currentMidiData) {
                    loadMidiAndSetup(0); // Recargar la primera canción
                }
            }
            
            showMessage('Simulación Reiniciada. ¡Crea nuevos sistemas!', 2500, new THREE.Color(0xef4444));
        }

        /**
         * Maneja el redimensionamiento de la ventana para mantener la vista correcta.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // =================================================================
        // LÓGICA MIDI REAL
        // =================================================================

        /**
         * Inicializa los Samplers de Tone.js (instrumentos reales).
         */
        async function setupMidiPlayers() {
            // Un mapa simple de Instrumentos General MIDI (GM) a sonidos de Sampler
            const GM_INSTRUMENT_MAP = {
                'piano': 'piano', 'bass': 'bass-electric', 'drums': 'drums', 'brass': 'trumpet', 
                'synth': 'synth_lead', 'strings': 'violin', 'guitar': 'guitar-acoustic'
            };
            
            const samplerPromises = [];
            
            // Solo necesitamos 10 Samplers, uno por cada posible pista activa
            for (let i = 0; i < TRACKS_PER_SONG; i++) {
                // Usamos una clave genérica para los Samplers (siempre se cargará piano por estabilidad)
                const sampler = new Tone.Sampler({
                    urls: { "C4": `piano-c4.mp3` }, 
                    baseUrl: "https://tonejs.github.io/audio/salamander/", 
                    onload: () => {
                        sampler.volume.value = -100; // Silenciado por defecto
                        sampler.toDestination();
                    },
                    onerror: (e) => {
                        console.error(`Error al cargar sampler:`, e);
                    }
                }).toDestination();
                
                midiPlayers.push(sampler);
                samplerPromises.push(new Promise(resolve => sampler.onload = resolve));
            }
            
            await Promise.all(samplerPromises);
            
            // Una vez cargados los 10 Samplers, procedemos a cargar la primera canción MIDI
            await loadMidiAndSetup(currentSongIndex);
        }
        
        /**
         * Inicia el secuenciador de Tone.js con los datos MIDI.
         * @param {number} songIndex Índice de la canción a cargar
         */
        function startSequencer(midiArray) {
            Tone.Transport.cancel();
            
            // Usamos el BPM del primer archivo MIDI
            Tone.Transport.bpm.value = midiArray[0].header.tempos[0].bpm || 128; 

            midiArray.slice(0, TRACKS_PER_SONG).forEach((midi, i) => {
                const track = midi.tracks.length > 0 ? midi.tracks[0] : null; 
                if (!track) return;

                const notes = track.notes;
                const player = midiPlayers[i];

                const part = new Tone.Part((time, note) => {
                    // Solo reproducimos si la capa está activa (activada por un planeta)
                    if (activePatterns[INSTRUMENT_LAYERS[i]]) {
                        player.triggerAttackRelease(
                            note.name, 
                            note.duration, 
                            time, 
                            note.velocity
                        );

                        // Visualización rítmica (parpadeo del planeta)
                        Tone.Draw.schedule(() => {
                            activeNotes[INSTRUMENT_LAYERS[i]] = true;
                            setTimeout(() => activeNotes[INSTRUMENT_LAYERS[i]] = false, Tone.Time(note.duration).toMilliseconds() * 0.5);
                        }, time);
                    }
                }, notes).start(0);

                part.loop = true;
                part.loopEnd = midi.duration || "4m";
            });

            // Usamos la duración del primer MIDI como duración del loop principal
            Tone.Transport.loop = true;
            Tone.Transport.loopEnd = midiArray[0].duration || "4m";
            
            Tone.Transport.start();
            showMessage(`¡Música ${SONG_DATA_STRUCTURES[currentSongIndex].name} lista! Crea tu primer planeta.`, 2000, new THREE.Color(0x22c55e));
        }

        /**
         * Carga el archivo MIDI de forma asíncrona.
         */
        async function loadMidiAndSetup(songIndex) {
             showMessage(`Cargando partitura MIDI para ${SONG_DATA_STRUCTURES[songIndex].name}...`, 3000, new THREE.Color(0xfacc15));
             
             // 1. Crear 10 promesas de carga para las 10 pistas
             const midiPromises = [];
             for(let i = 0; i < TRACKS_PER_SONG; i++) {
                 const MIDI_PATH = getTrackPath(songIndex, i); 
                 
                 // Usamos fetch para asegurar que el navegador pueda acceder al archivo
                 const loadPromise = fetch(MIDI_PATH)
                     .then(response => {
                         if (!response.ok) {
                             // Si no se encuentra el archivo (Error 404), no lanzamos error fatal, devolvemos un MIDI vacío
                             console.warn(`Advertencia: Pista ${i + 1} (${MIDI_PATH}) no encontrada. La pista estará en silencio.`);
                             return { tracks: [], duration: 0, header: { tempos: [{ bpm: 128 }] } };
                         }
                         return response.arrayBuffer();
                     })
                     .then(arrayBuffer => Midi.fromBuffer(arrayBuffer))
                     .catch(e => {
                         console.error(`Fallo al procesar Pista ${i + 1}:`, e);
                         // Devolver un objeto MIDI vacío si hay un fallo en el procesamiento
                         return { tracks: [], duration: 0, header: { tempos: [{ bpm: 128 }] } }; 
                     });
                 
                 midiPromises.push(loadPromise);
             }
            
            // 2. Esperar a que todos los archivos MIDI carguen
            const loadedMidis = await Promise.all(midiPromises);
            
            // 3. Almacenar y comenzar la secuencia
            currentMidiData = loadedMidis; 
            
            // 4. Iniciar el secuenciador con el array de midis
            startSequencer(loadedMidis);
        }

        /**
         * Función dummy para mantener la estructura de planet.synth (ahora solo mute/unmute)
         */
        function createSynth() {
            return { synth: null, panner: null }; 
        }

        /**
         * Inicia el contexto de audio y la carga del MIDI.
         */
        function startAudioContext() {
            if (!isAudioContextStarted) {
                // Iniciar el Contexto de Audio con interacción del usuario
                Tone.start(); 
                isAudioContextStarted = true;
                
                // Iniciar la carga de Samplers y MIDI
                setupMidiPlayers();
            }
        }
        
        /**
         * Función que cambia la canción al crear un nuevo Sol.
         */
        function changeSong() {
            // Ciclo a la siguiente canción
            currentSongIndex = (currentSongIndex + 1) % TOTAL_SONGS; 
            
            // 1. Limpiar patrones visuales
            activePatterns = {};
            planets.forEach(p => p.assignedLayer = INSTRUMENT_LAYERS[0]);
            
            // 2. Actualizar las capas de instrumento disponibles (para la UI)
            INSTRUMENT_LAYERS = SONG_DATA_STRUCTURES[currentSongIndex].layers;

            // 3. Cargar la nueva canción MIDI
            // NOTA: No esperamos aquí, el resto de la app es asíncrona.
            loadMidiAndSetup(currentSongIndex); 
            
            // 4. Actualizar volumen (silenciar capas)
            updateAudioVolumes();
            
            showMessage(`Música cambiada a: ${SONG_DATA_STRUCTURES[currentSongIndex].name}`, 2000, new THREE.Color(0xfacc15));
        }
        
        /**
         * Controla qué patrones rítmicos están activos (solo lógica, sin audio).
         */
        function updateAudioVolumes() {
            // 1. Mapear qué capas están activas visualmente (para el MIDI)
            INSTRUMENT_LAYERS.forEach(layer => activePatterns[layer] = false);
            
            planets.forEach((planet, index) => {
                const layerIndex = index % TRACKS_PER_SONG;
                const layerName = INSTRUMENT_LAYERS[layerIndex];
                
                planet.assignedLayer = layerName;
                activePatterns[layerName] = true;
                
                // Controlar el volumen real del sampler (si existe)
                if (midiPlayers[layerIndex]) {
                    midiPlayers[layerIndex].volume.value = 0; // Activar (0dB)
                }
            });
            
            // Silenciar las capas sin planeta
            for (let i = planets.length; i < TRACKS_PER_SONG; i++) {
                 if (midiPlayers[i]) {
                    midiPlayers[i].volume.value = -100; // Silenciar
                 }
            }


            // 3. Controlar el estado general 
            if (planets.length > 0 && !musicStarted) {
                musicStarted = true;
                Tone.Master.mute = false; // Desmutear la música
            } else if (planets.length === 0 && musicStarted) {
                musicStarted = false;
                Tone.Master.mute = true; // Mutear todo
            }
        }


        // =================================================================
        // FUNCIONES DE FÍSICA
        // =================================================================

        /**
         * Calcula la aceleración gravitacional neta sobre el planeta causada por todos los soles.
         * F = G * M1 * M2 / r^2
         * A = F / M2 = G * M1 / r^2
         * @param {object} planet El objeto planeta con posición, masa y aceleración.
         */
        function calculateGravity(planet) {
            const netAcceleration = new THREE.Vector3(0, 0, 0);

            suns.forEach(sun => {
                // Vector que apunta del planeta al sol
                const direction = tempVector.copy(sun.mesh.position).sub(planet.mesh.position);
                const distanceSq = direction.lengthSq();

                // Evitar división por cero o fuerzas infinitas en colisión cercana
                if (distanceSq < 1) { 
                    return;
                }
                
                const distance = Math.sqrt(distanceSq);

                // Fuerza gravitacional: A = (G * M_sol / r^2) * (vector unitario)
                const magnitude = (GRAVITATIONAL_CONSTANT * SUN_MASS) / distanceSq;

                // Asegurar que la fuerza no sea demasiado grande a corta distancia
                const maxMagnitude = 5.0; // Límite de aceleración para estabilidad
                const finalMagnitude = Math.min(magnitude, maxMagnitude);

                direction.normalize().multiplyScalar(finalMagnitude);
                
                netAcceleration.add(direction);
            });

            planet.acceleration = netAcceleration;
        }

        /**
         * Aplica la integración de Euler para actualizar la velocidad y posición.
         * @param {object} planet El objeto planeta.
         * @param {number} deltaTime El paso de tiempo.
         */
        function updatePhysics(planet, deltaTime) {
            // Velocidad = Velocidad + Aceleración * dt
            planet.velocity.add(planet.acceleration.clone().multiplyScalar(deltaTime));
            
            // Posición = Posición + Velocidad * dt
            planet.mesh.position.add(planet.velocity.clone().multiplyScalar(deltaTime));
        }

        /**
         * Encuentra el Sol más cercano al punto de click.
         * @param {THREE.Vector3} clickPosition Posición 3D del click.
         * @returns {object} El objeto Sol más cercano.
         */
        function findNearestSun(clickPosition) {
            let minDistanceSq = Infinity;
            let nearestSun = null;
            
            suns.forEach(sun => {
                // Usamos subVectors y lengthSq para calcular la distancia.
                const diffVector = new THREE.Vector3().subVectors(sun.mesh.position, clickPosition);
                const distanceSq = diffVector.lengthSq(); 
                
                if (distanceSq < minDistanceSq) {
                    minDistanceSq = distanceSq;
                    nearestSun = sun;
                }
            });

            return nearestSun;
        }

        // =================================================================
        // UTILIDADES
        // =================================================================

        /**
         * Inicializa la escena, cámara, renderizador y luces.
         */
        function init() {
            // 1. Configuración de la Escena
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0d0d1a, 0.003); 

            // 2. Configuración de la Cámara (perspectiva para 3D)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, ORBIT_RADIUS); // Posición inicial aumentada a 250
            
            // 3. Configuración del Renderizador (WebGL)
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1);
            // Añadir una clase para apuntar con CSS si queremos aumentar el grosor de línea
            renderer.domElement.classList.add('webgl-canvas'); 
            document.getElementById('container').appendChild(renderer.domElement);
            
            // 4. Configuración de la Iluminación
            ambientLight = new THREE.AmbientLight(0x404040, 0.5); 
            scene.add(ambientLight);

            // 5. Crear el Sol Central Inicial y el Fondo de Estrellas
            createInitialSun(); 
            createStarField(); 
            
            // 6. Manejadores de Eventos
            window.addEventListener('resize', onWindowResize, false);
            setupPointerControls(renderer.domElement);
        }

        /**
         * Crea el primer Sol al iniciar la simulación.
         */
        function createInitialSun() {
            // Sol inicial ligeramente desplazado para evitar la singularidad de la órbita inicial
            const center = new THREE.Vector3(5, 0, 0); 
            createSunAtPosition(center);
        }

        /**
         * Crea un objeto Sol y lo añade a la escena y al array de Soles.
         * @param {THREE.Vector3} position Posición del nuevo sol.
         */
        function createSunAtPosition(position) {
            const sunRadius = 12;
            const sunGeometry = new THREE.SphereGeometry(sunRadius, 32, 32); 
            const sunMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                emissive: 0xff8800 
            }); 
            const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            sunMesh.position.copy(position);
            scene.add(sunMesh);
            
            const flareTexture = generateRadialTexture(); 

            const lightSprite = new THREE.Sprite(new THREE.SpriteMaterial({
                map: flareTexture,
                color: 0xff8800, 
                blending: THREE.AdditiveBlending, 
                transparent: true,
                opacity: 0.7 
            }));
            lightSprite.scale.set(50, 50, 1.0); 
            sunMesh.add(lightSprite);

            // Cada sol necesita una luz para iluminar a los planetas a su alrededor
            const sunLight = new THREE.PointLight(0xffffff, 3.0, 0, 0); 
            sunLight.position.copy(position);
            scene.add(sunLight);

            // Se almacena el mesh para acceder a su posición Vector3
            suns.push({ mesh: sunMesh, light: sunLight, mass: SUN_MASS });
            
            // --- NUEVA LÓGICA: CAMBIAR LA CANCIÓN AL CREAR UN NUEVO SOL ---
            if (suns.length > 1 && musicStarted) {
                changeSong();
            }
        }


        /**
         * Crea un campo de estrellas aleatorias para el fondo.
         */
        function createStarField() {
            const starCount = 1500;
            const starGeometry = new THREE.BufferGeometry();
            const positions = [];
            
            const radius = 500; 

            for (let i = 0; i < starCount; i++) {
                const x = THREE.MathUtils.randFloatSpread(radius * 2);
                const y = THREE.MathUtils.randFloatSpread(radius * 2);
                const z = THREE.MathUtils.randFloatSpread(radius * 2);

                positions.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1, 
                sizeAttenuation: true 
            });

            starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }
        
        /**
         * Genera una textura circular suave con degradado para simular un brillo (flare).
         */
        function generateRadialTexture() {
            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');

            const gradient = context.createRadialGradient(
                size / 2, size / 2, 0, 
                size / 2, size / 2, size / 2 
            );
            gradient.addColorStop(0, 'rgba(255,255,255,1)'); 
            gradient.addColorStop(1, 'rgba(255,255,255,0)'); 

            context.fillStyle = gradient;
            context.fillRect(0, 0, size, size);

            return new THREE.CanvasTexture(canvas);
        }

        /**
         * Configura los eventos de mouse y touch para el control de la cámara.
         */
        function setupPointerControls(element) {
            element.addEventListener('pointerdown', onPointerDown, false);
            element.addEventListener('pointermove', onPointerMove, false);
            element.addEventListener('pointerup', onPointerUp, false);
            element.addEventListener('pointerleave', onPointerUp, false);
        }

        /**
         * Evento al pulsar (clic o tocar).
         */
        function onPointerDown(event) {
            if (event.buttons === 1 || event.pointerType === 'touch') { 
                isPointerActive = true; 
                isDragging = false; 
                
                pointerStart.x = event.clientX;
                pointerStart.y = event.clientY;

                previousPointerPosition.x = event.clientX;
                previousPointerPosition.y = event.clientY;
                velocityX = 0;
                velocityY = 0;
            }
        }

        /**
         * Evento al mover el puntero (arrastrar).
         */
        function onPointerMove(event) {
            
            if (!isPointerActive) return; 

            if (!isDragging) {
                const deltaMovementX = event.clientX - pointerStart.x;
                const deltaMovementY = event.clientY - pointerStart.y;
                const distance = Math.sqrt(deltaMovementX * deltaMovementX + deltaMovementY * deltaMovementY); 
                
                if (distance > DRAG_THRESHOLD) {
                    isDragging = true; 
                }
            }

            if (isDragging) { 
                const deltaX = event.clientX - previousPointerPosition.x;
                const deltaY = event.clientY - previousPointerPosition.y;

                theta += deltaX * ROTATION_MULTIPLIER;
                phi -= deltaY * ROTATION_MULTIPLIER;
                
                velocityX = deltaX * ROTATION_MULTIPLIER * 0.5;
                velocityY = deltaY * ROTATION_MULTIPLIER * 0.5;

                previousPointerPosition.x = event.clientX;
                previousPointerPosition.y = event.clientY;
            }
        }

        /**
         * Evento al soltar (dejar de arrastrar o crear entidad).
         */
        function onPointerUp(event) {
            if (isPointerActive && !isDragging) { 
                const entitySelect = document.getElementById('entitySelect');
                const selectedEntity = entitySelect ? entitySelect.value : 'planet';
                
                if (selectedEntity === 'planet') {
                    createPlanet(event);
                } else if (selectedEntity === 'sun') {
                    createSunOnClick(event);
                }
            }
            
            isDragging = false; 
            isPointerActive = false; 
        }

        /**
         * Intenta crear un Sol en la posición del click/toque.
         */
        function createSunOnClick(event) {
            // Mapeo de coordenadas de pantalla a un punto en el espacio 3D
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // Proyectar en el plano Y=0 (el "suelo" de la simulación)
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); 
            const intersection = new THREE.Vector3();
            
            raycaster.ray.intersectPlane(plane, intersection);

            // Limitar la distancia del Sol para evitar que aparezca muy lejos
            if (intersection.length() > MAX_SUN_DISTANCE) {
                intersection.normalize().multiplyScalar(MAX_SUN_DISTANCE);
                showMessage('Sol colocado en el límite de la zona central.', 2000, new THREE.Color(0xfacc15));
            }


            createSunAtPosition(intersection);
            showMessage('¡Nuevo Sol Creado! Ahora afecta la gravedad.', 2000, new THREE.Color(0xfacc15));
        }

        /**
         * Crea un nuevo planeta.
         * @param {PointerEvent} event El evento de puntero (contiene clientX/Y).
         */
        function createPlanet(event) {
            startAudioContext(); 

            if (suns.length === 0) {
                showMessage('No hay soles para orbitar. ¡Crea un Sol primero!', 3000, new THREE.Color(0xef4444));
                return;
            }
            
            // Mapeo de coordenadas de pantalla a un punto en el espacio 3D
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // Proyectar en el plano Y=0 (el "suelo" de la simulación)
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); 
            const intersection = new THREE.Vector3();
            
            raycaster.ray.intersectPlane(plane, intersection);
            const initialPosition = intersection.clone();

            // --- 1. ENCONTRAR EL SOL MÁS CERCANO PARA INICIALIZAR LA ÓRBITA ---
            const nearestSun = findNearestSun(initialPosition);
            
            // Usamos la posición del mesh del sol para la física
            const relativePosition = initialPosition.clone().sub(nearestSun.mesh.position);
            const distance = relativePosition.length();

            // VERIFICACIÓN DE SEGURIDAD CRÍTICA: La distancia NO debe ser 0.
            if (distance < COLLISION_DISTANCE) {
                showMessage('Demasiado cerca del Sol. Intenta más lejos.', 3000, new THREE.Color(0xfacc15));
                return;
            }

            // 2. CÁLCULO DE VELOCIDAD INICIAL (para órbita circular aproximada alrededor del Sol más cercano)
            
            // Magnitud de la velocidad orbital: v = sqrt(G*M/r)
            const orbitVelocityMag = Math.sqrt((GRAVITATIONAL_CONSTANT * SUN_MASS) / distance);
            
            // Dirección de la velocidad: perpendicular al vector posición (para iniciar la órbita)
            const positionUnit = relativePosition.clone().normalize();
            
            // Crea un vector perpendicular para la velocidad inicial (Vector3 perpendicular a positionUnit y Y-axis)
            let initialVelocity = new THREE.Vector3().crossVectors(positionUnit, new THREE.Vector3(0, 1, 0));
            
            // CORRECCIÓN CRÍTICA: Asegurar que el vector de velocidad no sea nulo si el producto cruz falla
            if (initialVelocity.lengthSq() < 0.001) {
                // Si falla (ej. el planeta está exactamente en el eje Y), usa una dirección arbitraria perpendicular (Eje X)
                 initialVelocity.set(1, 0, 0); 
            }
            
            // Velocidad inicial ajustada (0.99 a 1.01) para asegurar una órbita estable
            initialVelocity.normalize().multiplyScalar(orbitVelocityMag * THREE.MathUtils.randFloat(0.99, 1.01));

            // Añadir una pequeña componente Y para dar una inclinación 3D inicial
            initialVelocity.y = THREE.MathUtils.randFloatSpread(orbitVelocityMag * 0.1); 

            // 3. GENERAR EL RESTO DE PROPIEDADES
            const radius = THREE.MathUtils.randFloat(1, 4); 
            
            const baseColor = new THREE.Color(Math.random(), Math.random(), Math.random());
            const hsl = {};
            baseColor.getHSL(hsl);
            hsl.l = THREE.MathUtils.randFloat(0.7, 0.9);
            hsl.s = THREE.MathUtils.randFloat(0.4, 0.8); 
            const brightColor = new THREE.Color().setHSL(hsl.h, hsl.s, hsl.l);


            // 4. Configuración de AUDIO (Solo asignación de capa)
            
            // Asignación de Capa (El instrumento al que se asigna este planeta)
            // Asigna la siguiente capa del MIDI que no tenga un planeta activo
            const activeLayersCount = planets.filter(p => p.assignedLayer).length;
            const layerIndex = activeLayersCount % INSTRUMENT_LAYERS.length;
            const assignedLayer = INSTRUMENT_LAYERS[layerIndex];
            
            // Crear un objeto dummy para audio
            const { synth, panner } = createSynth(); 
            
            // 5. Malla y Rastro (similar al código anterior)
            const planetGeometry = new THREE.SphereGeometry(radius, 32, 32);
            const planetMaterial = new THREE.MeshLambertMaterial({ 
                color: brightColor, 
                emissive: brightColor.clone().multiplyScalar(0.1) 
            });
            const planetMesh = new THREE.Mesh(planetGeometry, planetMaterial);
            planetMesh.position.copy(initialPosition);

            const orbitPositions = new Float32Array(TRAIL_LENGTH * 3); 
            const drawingPositions = new Float32Array(TRAIL_LENGTH * 3);
            
            // Creación del Array de Colores (RGBA: 4 componentes por punto)
            const trailColors = new Float32Array(TRAIL_LENGTH * 4); 

            const trailGeometry = new THREE.BufferGeometry();
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(drawingPositions, 3)); 
            trailGeometry.setAttribute('color', new THREE.BufferAttribute(trailColors, 4)); // Añadir atributo de color/opacidad
            
            const trailMaterial = new THREE.LineBasicMaterial({
                color: brightColor, 
                transparent: true,
                opacity: 1.0,
                vertexColors: true // Usar colores definidos por el vértice
            });
            const orbitTrail = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(orbitTrail);

            // 6. Crear Objeto para el planeta (PROPIEDADES DE FÍSICA Y AUDIO)
            const planetObject = {
                mesh: planetMesh,
                trail: orbitTrail,
                orbitPositions: orbitPositions, 
                trailColors: trailColors, // Almacenar el array de colores
                planetColor: brightColor, // Color base del planeta
                trailIndex: 0,
                trailLength: TRAIL_LENGTH,
                trailCount: 0,
                // PROPIEDADES DE FÍSICA
                mass: PLANET_MASS,
                velocity: initialVelocity, // Vector3
                acceleration: new THREE.Vector3(0, 0, 0), // Vector3
                // PROPIEDADES DE AUDIO
                synth: synth,
                panner: panner, // Nuevo panner
                assignedLayer: assignedLayer, // Capa de la canción asignada (Ej: 'Cancion1_1')
                // PROPIEDADES DE TRIVIA
                id: planets.length + 1, // Asignar un ID para identificarlo en la trivia
                pulseTypeName: `Pista: ${assignedLayer}` // Nombre legible
            };

            scene.add(planetMesh);
            planets.push(planetObject);
            
            // --- ACTUALIZACIÓN DE VOLUMENES (Lógica visual de estado) ---
            updateAudioVolumes();
            // ---------------------------------------------
            
            // CAMBIO AQUÍ: Simplificamos el mensaje
            showMessage('¡Planeta Creado!', 1500, brightColor);
        }

        /**
         * Alterna el estado de pausa de la simulación y la música.
         */
        function togglePause() {
            isPaused = !isPaused;
            const button = document.getElementById('pauseButton');
            
            if (isPaused) {
                button.textContent = 'Reanudar Simulación';
                button.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                button.classList.add('bg-green-600', 'hover:bg-green-700');
                showMessage('Simulación PAUSADA.', 1500, new THREE.Color(0xfb923c));
                // Lógica para pausar el audio (si estuviera activo)
                if (musicStarted) { Tone.Transport.pause(); }
            } else {
                button.textContent = 'Pausar Simulación';
                button.classList.remove('bg-green-600', 'hover:bg-green-700');
                button.classList.add('bg-blue-600', 'hover:bg-blue-700');
                showMessage('Simulación REANUDADA.', 1500, new THREE.Color(0x22c55e));
                // Lógica para reanudar el audio (si estuviera activo)
                if (musicStarted) { Tone.Transport.start(); }
            }
        }

        /**
         * Elimina todos los planetas, soles, sus rastros y sus sintetizadores.
         */
        function clearSimulation() {
            const initialSuns = suns.length;
            
            // Limpieza de estados
            musicStarted = false;
            currentSongIndex = 0;
            INSTRUMENT_LAYERS = SONG_DATA_STRUCTURES[0].layers;
            
            // Detener el audio
            Tone.Transport.stop();
            Tone.Transport.cancel();
            Tone.Master.mute = true;


            // Limpieza de Planetas
            planets.forEach(planet => {
                scene.remove(planet.mesh);
                scene.remove(planet.trail);
            });
            planets.length = 0;

            // Limpieza de Soles
            suns.forEach(sun => {
                scene.remove(sun.mesh);
                scene.remove(sun.light);
            });
            suns.length = 0;
            
            // Vuelve a crear el sol inicial
            if (initialSuns === 0) {
                 createInitialSun(); 
            } else {
                // Si el audio estaba cargado, recargar la canción inicial
                if (isAudioContextStarted && currentMidiData) {
                    loadMidiAndSetup(0); // Recargar la primera canción
                }
            }
            
            showMessage('Simulación Reiniciada. ¡Crea nuevos sistemas!', 2500, new THREE.Color(0xef4444));
        }

        /**
         * Maneja el redimensionamiento de la ventana para mantener la vista correcta.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // =================================================================
        // LÓGICA MIDI REAL
        // =================================================================

        /**
         * Inicializa los Samplers de Tone.js (instrumentos reales).
         */
        async function setupMidiPlayers() {
            // Un mapa simple de Instrumentos General MIDI (GM) a sonidos de Sampler
            const GM_INSTRUMENT_MAP = {
                'piano': 'piano', 'bass': 'bass-electric', 'drums': 'drums', 'brass': 'trumpet', 
                'synth': 'synth_lead', 'strings': 'violin', 'guitar': 'guitar-acoustic'
            };
            
            const samplerPromises = [];
            
            // Solo necesitamos 10 Samplers, uno por cada posible pista activa
            for (let i = 0; i < TRACKS_PER_SONG; i++) {
                // Usamos una clave genérica para los Samplers (siempre se cargará piano por estabilidad)
                const sampler = new Tone.Sampler({
                    urls: { "C4": `piano-c4.mp3` }, 
                    baseUrl: "https://tonejs.github.io/audio/salamander/", 
                    onload: () => {
                        sampler.volume.value = -100; // Silenciado por defecto
                        sampler.toDestination();
                    },
                    onerror: (e) => {
                        console.error(`Error al cargar sampler:`, e);
                    }
                }).toDestination();
                
                midiPlayers.push(sampler);
                samplerPromises.push(new Promise(resolve => sampler.onload = resolve));
            }
            
            await Promise.all(samplerPromises);
            
            // Una vez cargados los 10 Samplers, procedemos a cargar la primera canción MIDI
            await loadMidiAndSetup(currentSongIndex);
        }
        
        /**
         * Inicia el secuenciador de Tone.js con los datos MIDI.
         * @param {number} songIndex Índice de la canción a cargar
         */
        function startSequencer(midiArray) {
            Tone.Transport.cancel();
            
            // Usamos el BPM del primer archivo MIDI
            Tone.Transport.bpm.value = midiArray[0].header.tempos[0].bpm || 128; 

            midiArray.slice(0, TRACKS_PER_SONG).forEach((midi, i) => {
                const track = midi.tracks.length > 0 ? midi.tracks[0] : null; 
                if (!track) return;

                const notes = track.notes;
                const player = midiPlayers[i];

                const part = new Tone.Part((time, note) => {
                    // Solo reproducimos si la capa está activa (activada por un planeta)
                    if (activePatterns[INSTRUMENT_LAYERS[i]]) {
                        player.triggerAttackRelease(
                            note.name, 
                            note.duration, 
                            time, 
                            note.velocity
                        );

                        // Visualización rítmica (parpadeo del planeta)
                        Tone.Draw.schedule(() => {
                            activeNotes[INSTRUMENT_LAYERS[i]] = true;
                            setTimeout(() => activeNotes[INSTRUMENT_LAYERS[i]] = false, Tone.Time(note.duration).toMilliseconds() * 0.5);
                        }, time);
                    }
                }, notes).start(0);

                part.loop = true;
                part.loopEnd = midi.duration || "4m";
            });

            // Usamos la duración del primer MIDI como duración del loop principal
            Tone.Transport.loop = true;
            Tone.Transport.loopEnd = midiArray[0].duration || "4m";
            
            Tone.Transport.start();
            showMessage(`¡Música ${SONG_DATA_STRUCTURES[currentSongIndex].name} lista! Crea tu primer planeta.`, 2000, new THREE.Color(0x22c55e));
        }

        /**
         * Carga el archivo MIDI de forma asíncrona.
         */
        async function loadMidiAndSetup(songIndex) {
             showMessage(`Cargando partitura MIDI para ${SONG_DATA_STRUCTURES[songIndex].name}...`, 3000, new THREE.Color(0xfacc15));
             
             // 1. Crear 10 promesas de carga para las 10 pistas
             const midiPromises = [];
             for(let i = 0; i < TRACKS_PER_SONG; i++) {
                 const MIDI_PATH = getTrackPath(songIndex, i); 
                 
                 // Usamos fetch para asegurar que el navegador pueda acceder al archivo
                 const loadPromise = fetch(MIDI_PATH)
                     .then(response => {
                         if (!response.ok) {
                             // Si no se encuentra el archivo (Error 404), no lanzamos error fatal, devolvemos un MIDI vacío
                             console.warn(`Advertencia: Pista ${i + 1} (${MIDI_PATH}) no encontrada. La pista estará en silencio.`);
                             return { tracks: [], duration: 0, header: { tempos: [{ bpm: 128 }] } };
                         }
                         return response.arrayBuffer();
                     })
                     .then(arrayBuffer => Midi.fromBuffer(arrayBuffer))
                     .catch(e => {
                         console.error(`Fallo al procesar Pista ${i + 1}:`, e);
                         // Devolver un objeto MIDI vacío si hay un fallo en el procesamiento
                         return { tracks: [], duration: 0, header: { tempos: [{ bpm: 128 }] } }; 
                     });
                 
                 midiPromises.push(loadPromise);
             }
            
            // 2. Esperar a que todos los archivos MIDI carguen
            const loadedMidis = await Promise.all(midiPromises);
            
            // 3. Almacenar y comenzar la secuencia
            currentMidiData = loadedMidis; 
            
            // 4. Iniciar el secuenciador con el array de midis
            startSequencer(loadedMidis);
        }

        /**
         * Función dummy para mantener la estructura de planet.synth (ahora solo mute/unmute)
         */
        function createSynth() {
            return { synth: null, panner: null }; 
        }

        /**
         * Inicia el contexto de audio y la carga del MIDI.
         */
        function startAudioContext() {
            if (!isAudioContextStarted) {
                // Iniciar el Contexto de Audio con interacción del usuario
                Tone.start(); 
                isAudioContextStarted = true;
                
                // Iniciar la carga de Samplers y MIDI
                setupMidiPlayers();
            }
        }
        
        /**
         * Función que cambia la canción al crear un nuevo Sol.
         */
        function changeSong() {
            // Ciclo a la siguiente canción
            currentSongIndex = (currentSongIndex + 1) % TOTAL_SONGS; 
            
            // 1. Limpiar patrones visuales
            activePatterns = {};
            planets.forEach(p => p.assignedLayer = INSTRUMENT_LAYERS[0]);
            
            // 2. Actualizar las capas de instrumento disponibles (para la UI)
            INSTRUMENT_LAYERS = SONG_DATA_STRUCTURES[currentSongIndex].layers;

            // 3. Cargar la nueva canción MIDI
            // NOTA: No esperamos aquí, el resto de la app es asíncrona.
            loadMidiAndSetup(currentSongIndex); 
            
            // 4. Actualizar volumen (silenciar capas)
            updateAudioVolumes();
            
            showMessage(`Música cambiada a: ${SONG_DATA_STRUCTURES[currentSongIndex].name}`, 2000, new THREE.Color(0xfacc15));
        }
        
        /**
         * Controla qué patrones rítmicos están activos (solo lógica, sin audio).
         */
        function updateAudioVolumes() {
            // 1. Mapear qué capas están activas visualmente (para el MIDI)
            INSTRUMENT_LAYERS.forEach(layer => activePatterns[layer] = false);
            
            planets.forEach((planet, index) => {
                const layerIndex = index % TRACKS_PER_SONG;
                const layerName = INSTRUMENT_LAYERS[layerIndex];
                
                planet.assignedLayer = layerName;
                activePatterns[layerName] = true;
                
                // Controlar el volumen real del sampler (si existe)
                if (midiPlayers[layerIndex]) {
                    midiPlayers[layerIndex].volume.value = 0; // Activar (0dB)
                }
            });
            
            // Silenciar las capas sin planeta
            for (let i = planets.length; i < TRACKS_PER_SONG; i++) {
                 if (midiPlayers[i]) {
                    midiPlayers[i].volume.value = -100; // Silenciar
                 }
            }


            // 3. Controlar el estado general 
            if (planets.length > 0 && !musicStarted) {
                musicStarted = true;
                Tone.Master.mute = false; // Desmutear la música
            } else if (planets.length === 0 && musicStarted) {
                musicStarted = false;
                Tone.Master.mute = true; // Mutear todo
            }
        }


        // =================================================================
        // FUNCIONES DE FÍSICA
        // =================================================================

        /**
         * Calcula la aceleración gravitacional neta sobre el planeta causada por todos los soles.
         * F = G * M1 * M2 / r^2
         * A = F / M2 = G * M1 / r^2
         * @param {object} planet El objeto planeta con posición, masa y aceleración.
         */
        function calculateGravity(planet) {
            const netAcceleration = new THREE.Vector3(0, 0, 0);

            suns.forEach(sun => {
                // Vector que apunta del planeta al sol
                const direction = tempVector.copy(sun.mesh.position).sub(planet.mesh.position);
                const distanceSq = direction.lengthSq();

                // Evitar división por cero o fuerzas infinitas en colisión cercana
                if (distanceSq < 1) { 
                    return;
                }
                
                const distance = Math.sqrt(distanceSq);

                // Fuerza gravitacional: A = (G * M_sol / r^2) * (vector unitario)
                const magnitude = (GRAVITATIONAL_CONSTANT * SUN_MASS) / distanceSq;

                // Asegurar que la fuerza no sea demasiado grande a corta distancia
                const maxMagnitude = 5.0; // Límite de aceleración para estabilidad
                const finalMagnitude = Math.min(magnitude, maxMagnitude);

                direction.normalize().multiplyScalar(finalMagnitude);
                
                netAcceleration.add(direction);
            });

            planet.acceleration = netAcceleration;
        }

        /**
         * Aplica la integración de Euler para actualizar la velocidad y posición.
         * @param {object} planet El objeto planeta.
         * @param {number} deltaTime El paso de tiempo.
         */
        function updatePhysics(planet, deltaTime) {
            // Velocidad = Velocidad + Aceleración * dt
            planet.velocity.add(planet.acceleration.clone().multiplyScalar(deltaTime));
            
            // Posición = Posición + Velocidad * dt
            planet.mesh.position.add(planet.velocity.clone().multiplyScalar(deltaTime));
        }

        /**
         * Encuentra el Sol más cercano al punto de click.
         * @param {THREE.Vector3} clickPosition Posición 3D del click.
         * @returns {object} El objeto Sol más cercano.
         */
        function findNearestSun(clickPosition) {
            let minDistanceSq = Infinity;
            let nearestSun = null;
            
            suns.forEach(sun => {
                // Usamos subVectors y lengthSq para calcular la distancia.
                const diffVector = new THREE.Vector3().subVectors(sun.mesh.position, clickPosition);
                const distanceSq = diffVector.lengthSq(); 
                
                if (distanceSq < minDistanceSq) {
                    minDistanceSq = distanceSq;
                    nearestSun = sun;
                }
            });

            return nearestSun;
        }

        // =================================================================
        // UTILIDADES
        // =================================================================

        /**
         * Inicializa la escena, cámara, renderizador y luces.
         */
        function init() {
            // 1. Configuración de la Escena
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0d0d1a, 0.003); 

            // 2. Configuración de la Cámara (perspectiva para 3D)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, ORBIT_RADIUS); // Posición inicial aumentada a 250
            
            // 3. Configuración del Renderizador (WebGL)
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1);
            // Añadir una clase para apuntar con CSS si queremos aumentar el grosor de línea
            renderer.domElement.classList.add('webgl-canvas'); 
            document.getElementById('container').appendChild(renderer.domElement);
            
            // 4. Configuración de la Iluminación
            ambientLight = new THREE.AmbientLight(0x404040, 0.5); 
            scene.add(ambientLight);

            // 5. Crear el Sol Central Inicial y el Fondo de Estrellas
            createInitialSun(); 
            createStarField(); 
            
            // 6. Manejadores de Eventos
            window.addEventListener('resize', onWindowResize, false);
            setupPointerControls(renderer.domElement);
        }

        /**
         * Crea el primer Sol al iniciar la simulación.
         */
        function createInitialSun() {
            // Sol inicial ligeramente desplazado para evitar la singularidad de la órbita inicial
            const center = new THREE.Vector3(5, 0, 0); 
            createSunAtPosition(center);
        }

        /**
         * Crea un objeto Sol y lo añade a la escena y al array de Soles.
         * @param {THREE.Vector3} position Posición del nuevo sol.
         */
        function createSunAtPosition(position) {
            const sunRadius = 12;
            const sunGeometry = new THREE.SphereGeometry(sunRadius, 32, 32); 
            const sunMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                emissive: 0xff8800 
            }); 
            const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            sunMesh.position.copy(position);
            scene.add(sunMesh);
            
            const flareTexture = generateRadialTexture(); 

            const lightSprite = new THREE.Sprite(new THREE.SpriteMaterial({
                map: flareTexture,
                color: 0xff8800, 
                blending: THREE.AdditiveBlending, 
                transparent: true,
                opacity: 0.7 
            }));
            lightSprite.scale.set(50, 50, 1.0); 
            sunMesh.add(lightSprite);

            // Cada sol necesita una luz para iluminar a los planetas a su alrededor
            const sunLight = new THREE.PointLight(0xffffff, 3.0, 0, 0); 
            sunLight.position.copy(position);
            scene.add(sunLight);

            // Se almacena el mesh para acceder a su posición Vector3
            suns.push({ mesh: sunMesh, light: sunLight, mass: SUN_MASS });
            
            // --- NUEVA LÓGICA: CAMBIAR LA CANCIÓN AL CREAR UN NUEVO SOL ---
            if (suns.length > 1 && musicStarted) {
                changeSong();
            }
        }


        /**
         * Crea un campo de estrellas aleatorias para el fondo.
         */
        function createStarField() {
            const starCount = 1500;
            const starGeometry = new THREE.BufferGeometry();
            const positions = [];
            
            const radius = 500; 

            for (let i = 0; i < starCount; i++) {
                const x = THREE.MathUtils.randFloatSpread(radius * 2);
                const y = THREE.MathUtils.randFloatSpread(radius * 2);
                const z = THREE.MathUtils.randFloatSpread(radius * 2);

                positions.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1, 
                sizeAttenuation: true 
            });

            starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }
        
        /**
         * Genera una textura circular suave con degradado para simular un brillo (flare).
         */
        function generateRadialTexture() {
            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');

            const gradient = context.createRadialGradient(
                size / 2, size / 2, 0, 
                size / 2, size / 2, size / 2 
            );
            gradient.addColorStop(0, 'rgba(255,255,255,1)'); 
            gradient.addColorStop(1, 'rgba(255,255,255,0)'); 

            context.fillStyle = gradient;
            context.fillRect(0, 0, size, size);

            return new THREE.CanvasTexture(canvas);
        }

        /**
         * Configura los eventos de mouse y touch para el control de la cámara.
         */
        function setupPointerControls(element) {
            element.addEventListener('pointerdown', onPointerDown, false);
            element.addEventListener('pointermove', onPointerMove, false);
            element.addEventListener('pointerup', onPointerUp, false);
            element.addEventListener('pointerleave', onPointerUp, false);
        }

        /**
         * Evento al pulsar (clic o tocar).
         */
        function onPointerDown(event) {
            if (event.buttons === 1 || event.pointerType === 'touch') { 
                isPointerActive = true; 
                isDragging = false; 
                
                pointerStart.x = event.clientX;
                pointerStart.y = event.clientY;

                previousPointerPosition.x = event.clientX;
                previousPointerPosition.y = event.clientY;
                velocityX = 0;
                velocityY = 0;
            }
        }

        /**
         * Evento al mover el puntero (arrastrar).
         */
        function onPointerMove(event) {
            
            if (!isPointerActive) return; 

            if (!isDragging) {
                const deltaMovementX = event.clientX - pointerStart.x;
                const deltaMovementY = event.clientY - pointerStart.y;
                const distance = Math.sqrt(deltaMovementX * deltaMovementX + deltaMovementY * deltaMovementY); 
                
                if (distance > DRAG_THRESHOLD) {
                    isDragging = true; 
                }
            }

            if (isDragging) { 
                const deltaX = event.clientX - previousPointerPosition.x;
                const deltaY = event.clientY - previousPointerPosition.y;

                theta += deltaX * ROTATION_MULTIPLIER;
                phi -= deltaY * ROTATION_MULTIPLIER;
                
                velocityX = deltaX * ROTATION_MULTIPLIER * 0.5;
                velocityY = deltaY * ROTATION_MULTIPLIER * 0.5;

                previousPointerPosition.x = event.clientX;
                previousPointerPosition.y = event.clientY;
            }
        }

        /**
         * Evento al soltar (dejar de arrastrar o crear entidad).
         */
        function onPointerUp(event) {
            if (isPointerActive && !isDragging) { 
                const entitySelect = document.getElementById('entitySelect');
                const selectedEntity = entitySelect ? entitySelect.value : 'planet';
                
                if (selectedEntity === 'planet') {
                    createPlanet(event);
                } else if (selectedEntity === 'sun') {
                    createSunOnClick(event);
                }
            }
            
            isDragging = false; 
            isPointerActive = false; 
        }

        /**
         * Intenta crear un Sol en la posición del click/toque.
         */
        function createSunOnClick(event) {
            // Mapeo de coordenadas de pantalla a un punto en el espacio 3D
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // Proyectar en el plano Y=0 (el "suelo" de la simulación)
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); 
            const intersection = new THREE.Vector3();
            
            raycaster.ray.intersectPlane(plane, intersection);

            // Limitar la distancia del Sol para evitar que aparezca muy lejos
            if (intersection.length() > MAX_SUN_DISTANCE) {
                intersection.normalize().multiplyScalar(MAX_SUN_DISTANCE);
                showMessage('Sol colocado en el límite de la zona central.', 2000, new THREE.Color(0xfacc15));
            }


            createSunAtPosition(intersection);
            showMessage('¡Nuevo Sol Creado! Ahora afecta la gravedad.', 2000, new THREE.Color(0xfacc15));
        }

        /**
         * Crea un nuevo planeta.
         * @param {PointerEvent} event El evento de puntero (contiene clientX/Y).
         */
        function createPlanet(event) {
            startAudioContext(); 

            if (suns.length === 0) {
                showMessage('No hay soles para orbitar. ¡Crea un Sol primero!', 3000, new THREE.Color(0xef4444));
                return;
            }
            
            // Mapeo de coordenadas de pantalla a un punto en el espacio 3D
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // Proyectar en el plano Y=0 (el "suelo" de la simulación)
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); 
            const intersection = new THREE.Vector3();
            
            raycaster.ray.intersectPlane(plane, intersection);
            const initialPosition = intersection.clone();

            // --- 1. ENCONTRAR EL SOL MÁS CERCANO PARA INICIALIZAR LA ÓRBITA ---
            const nearestSun = findNearestSun(initialPosition);
            
            // Usamos la posición del mesh del sol para la física
            const relativePosition = initialPosition.clone().sub(nearestSun.mesh.position);
            const distance = relativePosition.length();

            // VERIFICACIÓN DE SEGURIDAD CRÍTICA: La distancia NO debe ser 0.
            if (distance < COLLISION_DISTANCE) {
                showMessage('Demasiado cerca del Sol. Intenta más lejos.', 3000, new THREE.Color(0xfacc15));
                return;
            }

            // 2. CÁLCULO DE VELOCIDAD INICIAL (para órbita circular aproximada alrededor del Sol más cercano)
            
            // Magnitud de la velocidad orbital: v = sqrt(G*M/r)
            const orbitVelocityMag = Math.sqrt((GRAVITATIONAL_CONSTANT * SUN_MASS) / distance);
            
            // Dirección de la velocidad: perpendicular al vector posición (para iniciar la órbita)
            const positionUnit = relativePosition.clone().normalize();
            
            // Crea un vector perpendicular para la velocidad inicial (Vector3 perpendicular a positionUnit y Y-axis)
            let initialVelocity = new THREE.Vector3().crossVectors(positionUnit, new THREE.Vector3(0, 1, 0));
            
            // CORRECCIÓN CRÍTICA: Asegurar que el vector de velocidad no sea nulo si el producto cruz falla
            if (initialVelocity.lengthSq() < 0.001) {
                // Si falla (ej. el planeta está exactamente en el eje Y), usa una dirección arbitraria perpendicular (Eje X)
                 initialVelocity.set(1, 0, 0); 
            }
            
            // Velocidad inicial ajustada (0.99 a 1.01) para asegurar una órbita estable
            initialVelocity.normalize().multiplyScalar(orbitVelocityMag * THREE.MathUtils.randFloat(0.99, 1.01));

            // Añadir una pequeña componente Y para dar una inclinación 3D inicial
            initialVelocity.y = THREE.MathUtils.randFloatSpread(orbitVelocityMag * 0.1); 

            // 3. GENERAR EL RESTO DE PROPIEDADES
            const radius = THREE.MathUtils.randFloat(1, 4); 
            
            const baseColor = new THREE.Color(Math.random(), Math.random(), Math.random());
            const hsl = {};
            baseColor.getHSL(hsl);
            hsl.l = THREE.MathUtils.randFloat(0.7, 0.9);
            hsl.s = THREE.MathUtils.randFloat(0.4, 0.8); 
            const brightColor = new THREE.Color().setHSL(hsl.h, hsl.s, hsl.l);


            // 4. Configuración de AUDIO (Solo asignación de capa)
            
            // Asignación de Capa (El instrumento al que se asigna este planeta)
            // Asigna la siguiente capa del MIDI que no tenga un planeta activo
            const activeLayersCount = planets.filter(p => p.assignedLayer).length;
            const layerIndex = activeLayersCount % INSTRUMENT_LAYERS.length;
            const assignedLayer = INSTRUMENT_LAYERS[layerIndex];
            
            // Crear un objeto dummy para audio
            const { synth, panner } = createSynth(); 
            
            // 5. Malla y Rastro (similar al código anterior)
            const planetGeometry = new THREE.SphereGeometry(radius, 32, 32);
            const planetMaterial = new THREE.MeshLambertMaterial({ 
                color: brightColor, 
                emissive: brightColor.clone().multiplyScalar(0.1) 
            });
            const planetMesh = new THREE.Mesh(planetGeometry, planetMaterial);
            planetMesh.position.copy(initialPosition);

            const orbitPositions = new Float32Array(TRAIL_LENGTH * 3); 
            const drawingPositions = new Float32Array(TRAIL_LENGTH * 3);
            
            // Creación del Array de Colores (RGBA: 4 componentes por punto)
            const trailColors = new Float32Array(TRAIL_LENGTH * 4); 

            const trailGeometry = new THREE.BufferGeometry();
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(drawingPositions, 3)); 
            trailGeometry.setAttribute('color', new THREE.BufferAttribute(trailColors, 4)); // Añadir atributo de color/opacidad
            
            const trailMaterial = new THREE.LineBasicMaterial({
                color: brightColor, 
                transparent: true,
                opacity: 1.0,
                vertexColors: true // Usar colores definidos por el vértice
            });
            const orbitTrail = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(orbitTrail);

            // 6. Crear Objeto para el planeta (PROPIEDADES DE FÍSICA Y AUDIO)
            const planetObject = {
                mesh: planetMesh,
                trail: orbitTrail,
                orbitPositions: orbitPositions, 
                trailColors: trailColors, // Almacenar el array de colores
                planetColor: brightColor, // Color base del planeta
                trailIndex: 0,
                trailLength: TRAIL_LENGTH,
                trailCount: 0,
                // PROPIEDADES DE FÍSICA
                mass: PLANET_MASS,
                velocity: initialVelocity, // Vector3
                acceleration: new THREE.Vector3(0, 0, 0), // Vector3
                // PROPIEDADES DE AUDIO
                synth: synth,
                panner: panner, // Nuevo panner
                assignedLayer: assignedLayer, // Capa de la canción asignada (Ej: 'Cancion1_1')
                // PROPIEDADES DE TRIVIA
                id: planets.length + 1, // Asignar un ID para identificarlo en la trivia
                pulseTypeName: `Pista: ${assignedLayer}` // Nombre legible
            };

            scene.add(planetMesh);
            planets.push(planetObject);
            
            // --- ACTUALIZACIÓN DE VOLUMENES (Lógica visual de estado) ---
            updateAudioVolumes();
            // ---------------------------------------------
            
            // CAMBIO AQUÍ: Simplificamos el mensaje
            showMessage('¡Planeta Creado!', 1500, brightColor);
        }

        /**
         * Alterna el estado de pausa de la simulación y la música.
         */
        function togglePause() {
            isPaused = !isPaused;
            const button = document.getElementById('pauseButton');
            
            if (isPaused) {
                button.textContent = 'Reanudar Simulación';
                button.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                button.classList.add('bg-green-600', 'hover:bg-green-700');
                showMessage('Simulación PAUSADA.', 1500, new THREE.Color(0xfb923c));
                // Lógica para pausar el audio (si estuviera activo)
                if (musicStarted) { Tone.Transport.pause(); }
            } else {
                button.textContent = 'Pausar Simulación';
                button.classList.remove('bg-green-600', 'hover:bg-green-700');
                button.classList.add('bg-blue-600', 'hover:bg-blue-700');
                showMessage('Simulación REANUDADA.', 1500, new THREE.Color(0x22c55e));
                // Lógica para reanudar el audio (si estuviera activo)
                if (musicStarted) { Tone.Transport.start(); }
            }
        }

        /**
         * Elimina todos los planetas, soles, sus rastros y sus sintetizadores.
         */
        function clearSimulation() {
            const initialSuns = suns.length;
            
            // Limpieza de estados
            musicStarted = false;
            currentSongIndex = 0;
            INSTRUMENT_LAYERS = SONG_DATA_STRUCTURES[0].layers;
            
            // Detener el audio
            Tone.Transport.stop();
            Tone.Transport.cancel();
            Tone.Master.mute = true;


            // Limpieza de Planetas
            planets.forEach(planet => {
                scene.remove(planet.mesh);
                scene.remove(planet.trail);
            });
            planets.length = 0;

            // Limpieza de Soles
            suns.forEach(sun => {
                scene.remove(sun.mesh);
                scene.remove(sun.light);
            });
            suns.length = 0;
            
            // Vuelve a crear el sol inicial
            if (initialSuns === 0) {
                 createInitialSun(); 
            } else {
                // Si el audio estaba cargado, recargar la canción inicial
                if (isAudioContextStarted && currentMidiData) {
                    loadMidiAndSetup(0); // Recargar la primera canción
                }
            }
            
            showMessage('Simulación Reiniciada. ¡Crea nuevos sistemas!', 2500, new THREE.Color(0xef4444));
        }

        /**
         * Maneja el redimensionamiento de la ventana para mantener la vista correcta.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // =================================================================
        // LÓGICA MIDI REAL
        // =================================================================

        /**
         * Inicializa los Samplers de Tone.js (instrumentos reales).
         */
        async function setupMidiPlayers() {
            // Un mapa simple de Instrumentos General MIDI (GM) a sonidos de Sampler
            const GM_INSTRUMENT_MAP = {
                'piano': 'piano', 'bass': 'bass-electric', 'drums': 'drums', 'brass': 'trumpet', 
                'synth': 'synth_lead', 'strings': 'violin', 'guitar': 'guitar-acoustic'
            };
            
            const samplerPromises = [];
            
            // Solo necesitamos 10 Samplers, uno por cada posible pista activa
            for (let i = 0; i < TRACKS_PER_SONG; i++) {
                // Usamos una clave genérica para los Samplers (siempre se cargará piano por estabilidad)
                const sampler = new Tone.Sampler({
                    urls: { "C4": `piano-c4.mp3` }, 
                    baseUrl: "https://tonejs.github.io/audio/salamander/", 
                    onload: () => {
                        sampler.volume.value = -100; // Silenciado por defecto
                        sampler.toDestination();
                    },
                    onerror: (e) => {
                        console.error(`Error al cargar sampler:`, e);
                    }
                }).toDestination();
                
                midiPlayers.push(sampler);
                samplerPromises.push(new Promise(resolve => sampler.onload = resolve));
            }
            
            await Promise.all(samplerPromises);
            
            // Una vez cargados los 10 Samplers, procedemos a cargar la primera canción MIDI
            await loadMidiAndSetup(currentSongIndex);
        }
        
        /**
         * Inicia el secuenciador de Tone.js con los datos MIDI.
         * @param {number} songIndex Índice de la canción a cargar
         */
        function startSequencer(midiArray) {
            Tone.Transport.cancel();
            
            // Usamos el BPM del primer archivo MIDI
            Tone.Transport.bpm.value = midiArray[0].header.tempos[0].bpm || 128; 

            midiArray.slice(0, TRACKS_PER_SONG).forEach((midi, i) => {
                const track = midi.tracks.length > 0 ? midi.tracks[0] : null; 
                if (!track) return;

                const notes = track.notes;
                const player = midiPlayers[i];

                const part = new Tone.Part((time, note) => {
                    // Solo reproducimos si la capa está activa (activada por un planeta)
                    if (activePatterns[INSTRUMENT_LAYERS[i]]) {
                        player.triggerAttackRelease(
                            note.name, 
                            note.duration, 
                            time, 
                            note.velocity
                        );

                        // Visualización rítmica (parpadeo del planeta)
                        Tone.Draw.schedule(() => {
                            activeNotes[INSTRUMENT_LAYERS[i]] = true;
                            setTimeout(() => activeNotes[INSTRUMENT_LAYERS[i]] = false, Tone.Time(note.duration).toMilliseconds() * 0.5);
                        }, time);
                    }
                }, notes).start(0);

                part.loop = true;
                part.loopEnd = midi.duration || "4m";
            });

            // Usamos la duración del primer MIDI como duración del loop principal
            Tone.Transport.loop = true;
            Tone.Transport.loopEnd = midiArray[0].duration || "4m";
            
            Tone.Transport.start();
            showMessage(`¡Música ${SONG_DATA_STRUCTURES[currentSongIndex].name} lista! Crea tu primer planeta.`, 2000, new THREE.Color(0x22c55e));
        }

        /**
         * Carga el archivo MIDI de forma asíncrona.
         */
        async function loadMidiAndSetup(songIndex) {
             showMessage(`Cargando partitura MIDI para ${SONG_DATA_STRUCTURES[songIndex].name}...`, 3000, new THREE.Color(0xfacc15));
             
             // 1. Crear 10 promesas de carga para las 10 pistas
             const midiPromises = [];
             for(let i = 0; i < TRACKS_PER_SONG; i++) {
                 const MIDI_PATH = getTrackPath(songIndex, i); 
                 
                 // Usamos fetch para asegurar que el navegador pueda acceder al archivo
                 const loadPromise = fetch(MIDI_PATH)
                     .then(response => {
                         if (!response.ok) {
                             // Si no se encuentra el archivo (Error 404), no lanzamos error fatal, devolvemos un MIDI vacío
                             console.warn(`Advertencia: Pista ${i + 1} (${MIDI_PATH}) no encontrada. La pista estará en silencio.`);
                             return { tracks: [], duration: 0, header: { tempos: [{ bpm: 128 }] } };
                         }
                         return response.arrayBuffer();
                     })
                     .then(arrayBuffer => Midi.fromBuffer(arrayBuffer))
                     .catch(e => {
                         console.error(`Fallo al procesar Pista ${i + 1}:`, e);
                         // Devolver un objeto MIDI vacío si hay un fallo en el procesamiento
                         return { tracks: [], duration: 0, header: { tempos: [{ bpm: 128 }] } }; 
                     });
                 
                 midiPromises.push(loadPromise);
             }
            
            // 2. Esperar a que todos los archivos MIDI carguen
            const loadedMidis = await Promise.all(midiPromises);
            
            // 3. Almacenar y comenzar la secuencia
            currentMidiData = loadedMidis; 
            
            // 4. Iniciar el secuenciador con el array de midis
            startSequencer(loadedMidis);
        }

        /**
         * Función dummy para mantener la estructura de planet.synth (ahora solo mute/unmute)
         */
        function createSynth() {
            return { synth: null, panner: null }; 
        }

        /**
         * Inicia el contexto de audio y la carga del MIDI.
         */
        function startAudioContext() {
            if (!isAudioContextStarted) {
                // Iniciar el Contexto de Audio con interacción del usuario
                Tone.start(); 
                isAudioContextStarted = true;
                
                // Iniciar la carga de Samplers y MIDI
                setupMidiPlayers();
            }
        }
        
        /**
         * Función que cambia la canción al crear un nuevo Sol.
         */
        function changeSong() {
            // Ciclo a la siguiente canción
            currentSongIndex = (currentSongIndex + 1) % TOTAL_SONGS; 
            
            // 1. Limpiar patrones visuales
            activePatterns = {};
            planets.forEach(p => p.assignedLayer = INSTRUMENT_LAYERS[0]);
            
            // 2. Actualizar las capas de instrumento disponibles (para la UI)
            INSTRUMENT_LAYERS = SONG_DATA_STRUCTURES[currentSongIndex].layers;

            // 3. Cargar la nueva canción MIDI
            // NOTA: No esperamos aquí, el resto de la app es asíncrona.
            loadMidiAndSetup(currentSongIndex); 
            
            // 4. Actualizar volumen (silenciar capas)
            updateAudioVolumes();
            
            showMessage(`Música cambiada a: ${SONG_DATA_STRUCTURES[currentSongIndex].name}`, 2000, new THREE.Color(0xfacc15));
        }
        
        /**
         * Controla qué patrones rítmicos están activos (solo lógica, sin audio).
         */
        function updateAudioVolumes() {
            // 1. Mapear qué capas están activas visualmente (para el MIDI)
            INSTRUMENT_LAYERS.forEach(layer => activePatterns[layer] = false);
            
            planets.forEach((planet, index) => {
                const layerIndex = index % TRACKS_PER_SONG;
                const layerName = INSTRUMENT_LAYERS[layerIndex];
                
                planet.assignedLayer = layerName;
                activePatterns[layerName] = true;
                
                // Controlar el volumen real del sampler (si existe)
                if (midiPlayers[layerIndex]) {
                    midiPlayers[layerIndex].volume.value = 0; // Activar (0dB)
                }
            });
            
            // Silenciar las capas sin planeta
            for (let i = planets.length; i < TRACKS_PER_SONG; i++) {
                 if (midiPlayers[i]) {
                    midiPlayers[i].volume.value = -100; // Silenciar
                 }
            }


            // 3. Controlar el estado general 
            if (planets.length > 0 && !musicStarted) {
                musicStarted = true;
                Tone.Master.mute = false; // Desmutear la música
            } else if (planets.length === 0 && musicStarted) {
                musicStarted = false;
                Tone.Master.mute = true; // Mutear todo
            }
        }


        // =================================================================
        // FUNCIONES DE FÍSICA
        // =================================================================

        /**
         * Calcula la aceleración gravitacional neta sobre el planeta causada por todos los soles.
         * F = G * M1 * M2 / r^2
         * A = F / M2 = G * M1 / r^2
         * @param {object} planet El objeto planeta con posición, masa y aceleración.
         */
        function calculateGravity(planet) {
            const netAcceleration = new THREE.Vector3(0, 0, 0);

            suns.forEach(sun => {
                // Vector que apunta del planeta al sol
                const direction = tempVector.copy(sun.mesh.position).sub(planet.mesh.position);
                const distanceSq = direction.lengthSq();

                // Evitar división por cero o fuerzas infinitas en colisión cercana
                if (distanceSq < 1) { 
                    return;
                }
                
                const distance = Math.sqrt(distanceSq);

                // Fuerza gravitacional: A = (G * M_sol / r^2) * (vector unitario)
                const magnitude = (GRAVITATIONAL_CONSTANT * SUN_MASS) / distanceSq;

                // Asegurar que la fuerza no sea demasiado grande a corta distancia
                const maxMagnitude = 5.0; // Límite de aceleración para estabilidad
                const finalMagnitude = Math.min(magnitude, maxMagnitude);

                direction.normalize().multiplyScalar(finalMagnitude);
                
                netAcceleration.add(direction);
            });

            planet.acceleration = netAcceleration;
        }

        /**
         * Aplica la integración de Euler para actualizar la velocidad y posición.
         * @param {object} planet El objeto planeta.
         * @param {number} deltaTime El paso de tiempo.
         */
        function updatePhysics(planet, deltaTime) {
            // Velocidad = Velocidad + Aceleración * dt
            planet.velocity.add(planet.acceleration.clone().multiplyScalar(deltaTime));
            
            // Posición = Posición + Velocidad * dt
            planet.mesh.position.add(planet.velocity.clone().multiplyScalar(deltaTime));
        }

        /**
         * Encuentra el Sol más cercano al punto de click.
         * @param {THREE.Vector3} clickPosition Posición 3D del click.
         * @returns {object} El objeto Sol más cercano.
         */
        function findNearestSun(clickPosition) {
            let minDistanceSq = Infinity;
            let nearestSun = null;
            
            suns.forEach(sun => {
                // Usamos subVectors y lengthSq para calcular la distancia.
                const diffVector = new THREE.Vector3().subVectors(sun.mesh.position, clickPosition);
                const distanceSq = diffVector.lengthSq(); 
                
                if (distanceSq < minDistanceSq) {
                    minDistanceSq = distanceSq;
                    nearestSun = sun;
                }
            });

            return nearestSun;
        }

        // =================================================================
        // UTILIDADES
        // =================================================================

        /**
         * Inicializa la escena, cámara, renderizador y luces.
         */
        function init() {
            // 1. Configuración de la Escena
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0d0d1a, 0.003); 

            // 2. Configuración de la Cámara (perspectiva para 3D)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, ORBIT_RADIUS); // Posición inicial aumentada a 250
            
            // 3. Configuración del Renderizador (WebGL)
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1);
            // Añadir una clase para apuntar con CSS si queremos aumentar el grosor de línea
            renderer.domElement.classList.add('webgl-canvas'); 
            
            // ** CORRECCIÓN: Asegurar que el canvas se adjunta al DOM **
            const container = document.getElementById('container');
            if (container) {
                 container.appendChild(renderer.domElement);
            } else {
                 console.error("Error crítico: El contenedor #container no se encontró.");
            }
            // ********************************************************
            
            // 4. Configuración de la Iluminación
            ambientLight = new THREE.AmbientLight(0x404040, 0.5); 
            scene.add(ambientLight);

            // 5. Crear el Sol Central Inicial y el Fondo de Estrellas
            createInitialSun(); 
            createStarField(); 
            
            // 6. Manejadores de Eventos
            window.addEventListener('resize', onWindowResize, false);
            setupPointerControls(renderer.domElement);
        }

        /**
         * Crea el primer Sol al iniciar la simulación.
         */
        function createInitialSun() {
            // Sol inicial ligeramente desplazado para evitar la singularidad de la órbita inicial
            const center = new THREE.Vector3(5, 0, 0); 
            createSunAtPosition(center);
        }

        /**
         * Crea un objeto Sol y lo añade a la escena y al array de Soles.
         * @param {THREE.Vector3} position Posición del nuevo sol.
         */
        function createSunAtPosition(position) {
            const sunRadius = 12;
            const sunGeometry = new THREE.SphereGeometry(sunRadius, 32, 32); 
            const sunMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                emissive: 0xff8800 
            }); 
            const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            sunMesh.position.copy(position);
            scene.add(sunMesh);
            
            const flareTexture = generateRadialTexture(); 

            const lightSprite = new THREE.Sprite(new THREE.SpriteMaterial({
                map: flareTexture,
                color: 0xff8800, 
                blending: THREE.AdditiveBlending, 
                transparent: true,
                opacity: 0.7 
            }));
            lightSprite.scale.set(50, 50, 1.0); 
            sunMesh.add(lightSprite);

            // Cada sol necesita una luz para iluminar a los planetas a su alrededor
            const sunLight = new THREE.PointLight(0xffffff, 3.0, 0, 0); 
            sunLight.position.copy(position);
            scene.add(sunLight);

            // Se almacena el mesh para acceder a su posición Vector3
            suns.push({ mesh: sunMesh, light: sunLight, mass: SUN_MASS });
            
            // --- NUEVA LÓGICA: CAMBIAR LA CANCIÓN AL CREAR UN NUEVO SOL ---
            if (suns.length > 1 && musicStarted) {
                changeSong();
            }
        }


        /**
         * Crea un campo de estrellas aleatorias para el fondo.
         */
        function createStarField() {
            const starCount = 1500;
            const starGeometry = new THREE.BufferGeometry();
            const positions = [];
            
            const radius = 500; 

            for (let i = 0; i < starCount; i++) {
                const x = THREE.MathUtils.randFloatSpread(radius * 2);
                const y = THREE.MathUtils.randFloatSpread(radius * 2);
                const z = THREE.MathUtils.randFloatSpread(radius * 2);

                positions.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1, 
                sizeAttenuation: true 
            });

            starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }
        
        /**
         * Genera una textura circular suave con degradado para simular un brillo (flare).
         */
        function generateRadialTexture() {
            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');

            const gradient = context.createRadialGradient(
                size / 2, size / 2, 0, 
                size / 2, size / 2, size / 2 
            );
            gradient.addColorStop(0, 'rgba(255,255,255,1)'); 
            gradient.addColorStop(1, 'rgba(255,255,255,0)'); 

            context.fillStyle = gradient;
            context.fillRect(0, 0, size, size);

            return new THREE.CanvasTexture(canvas);
        }

        /**
         * Configura los eventos de mouse y touch para el control de la cámara.
         */
        function setupPointerControls(element) {
            element.addEventListener('pointerdown', onPointerDown, false);
            element.addEventListener('pointermove', onPointerMove, false);
            element.addEventListener('pointerup', onPointerUp, false);
            element.addEventListener('pointerleave', onPointerUp, false);
        }

        /**
         * Evento al pulsar (clic o tocar).
         */
        function onPointerDown(event) {
            if (event.buttons === 1 || event.pointerType === 'touch') { 
                isPointerActive = true; 
                isDragging = false; 
                
                pointerStart.x = event.clientX;
                pointerStart.y = event.clientY;

                previousPointerPosition.x = event.clientX;
                previousPointerPosition.y = event.clientY;
                velocityX = 0;
                velocityY = 0;
            }
        }

        /**
         * Evento al mover el puntero (arrastrar).
         */
        function onPointerMove(event) {
            
            if (!isPointerActive) return; 

            if (!isDragging) {
                const deltaMovementX = event.clientX - pointerStart.x;
                const deltaMovementY = event.clientY - pointerStart.y;
                const distance = Math.sqrt(deltaMovementX * deltaMovementX + deltaMovementY * deltaMovementY); 
                
                if (distance > DRAG_THRESHOLD) {
                    isDragging = true; 
                }
            }

            if (isDragging) { 
                const deltaX = event.clientX - previousPointerPosition.x;
                const deltaY = event.clientY - previousPointerPosition.y;

                theta += deltaX * ROTATION_MULTIPLIER;
                phi -= deltaY * ROTATION_MULTIPLIER;
                
                velocityX = deltaX * ROTATION_MULTIPLIER * 0.5;
                velocityY = deltaY * ROTATION_MULTIPLIER * 0.5;

                previousPointerPosition.x = event.clientX;
                previousPointerPosition.y = event.clientY;
            }
        }

        /**
         * Evento al soltar (dejar de arrastrar o crear entidad).
         */
        function onPointerUp(event) {
            if (isPointerActive && !isDragging) { 
                const entitySelect = document.getElementById('entitySelect');
                const selectedEntity = entitySelect ? entitySelect.value : 'planet';
                
                if (selectedEntity === 'planet') {
                    createPlanet(event);
                } else if (selectedEntity === 'sun') {
                    createSunOnClick(event);
                }
            }
            
            isDragging = false; 
            isPointerActive = false; 
        }

        /**
         * Intenta crear un Sol en la posición del click/toque.
         */
        function createSunOnClick(event) {
            // Mapeo de coordenadas de pantalla a un punto en el espacio 3D
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // Proyectar en el plano Y=0 (el "suelo" de la simulación)
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); 
            const intersection = new THREE.Vector3();
            
            raycaster.ray.intersectPlane(plane, intersection);

            // Limitar la distancia del Sol para evitar que aparezca muy lejos
            if (intersection.length() > MAX_SUN_DISTANCE) {
                intersection.normalize().multiplyScalar(MAX_SUN_DISTANCE);
                showMessage('Sol colocado en el límite de la zona central.', 2000, new THREE.Color(0xfacc15));
            }


            createSunAtPosition(intersection);
            showMessage('¡Nuevo Sol Creado! Ahora afecta la gravedad.', 2000, new THREE.Color(0xfacc15));
        }

        /**
         * Crea un nuevo planeta.
         * @param {PointerEvent} event El evento de puntero (contiene clientX/Y).
         */
        function createPlanet(event) {
            startAudioContext(); 

            if (suns.length === 0) {
                showMessage('No hay soles para orbitar. ¡Crea un Sol primero!', 3000, new THREE.Color(0xef4444));
                return;
            }
            
            // Mapeo de coordenadas de pantalla a un punto en el espacio 3D
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // Proyectar en el plano Y=0 (el "suelo" de la simulación)
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); 
            const intersection = new THREE.Vector3();
            
            raycaster.ray.intersectPlane(plane, intersection);
            const initialPosition = intersection.clone();

            // --- 1. ENCONTRAR EL SOL MÁS CERCANO PARA INICIALIZAR LA ÓRBITA ---
            const nearestSun = findNearestSun(initialPosition);
            
            // Usamos la posición del mesh del sol para la física
            const relativePosition = initialPosition.clone().sub(nearestSun.mesh.position);
            const distance = relativePosition.length();

            // VERIFICACIÓN DE SEGURIDAD CRÍTICA: La distancia NO debe ser 0.
            if (distance < COLLISION_DISTANCE) {
                showMessage('Demasiado cerca del Sol. Intenta más lejos.', 3000, new THREE.Color(0xfacc15));
                return;
            }

            // 2. CÁLCULO DE VELOCIDAD INICIAL (para órbita circular aproximada alrededor del Sol más cercano)
            
            // Magnitud de la velocidad orbital: v = sqrt(G*M/r)
            const orbitVelocityMag = Math.sqrt((GRAVITATIONAL_CONSTANT * SUN_MASS) / distance);
            
            // Dirección de la velocidad: perpendicular al vector posición (para iniciar la órbita)
            const positionUnit = relativePosition.clone().normalize();
            
            // Crea un vector perpendicular para la velocidad inicial (Vector3 perpendicular a positionUnit y Y-axis)
            let initialVelocity = new THREE.Vector3().crossVectors(positionUnit, new THREE.Vector3(0, 1, 0));
            
            // CORRECCIÓN CRÍTICA: Asegurar que el vector de velocidad no sea nulo si el producto cruz falla
            if (initialVelocity.lengthSq() < 0.001) {
                // Si falla (ej. el planeta está exactamente en el eje Y), usa una dirección arbitraria perpendicular (Eje X)
                 initialVelocity.set(1, 0, 0); 
            }
            
            // Velocidad inicial ajustada (0.99 a 1.01) para asegurar una órbita estable
            initialVelocity.normalize().multiplyScalar(orbitVelocityMag * THREE.MathUtils.randFloat(0.99, 1.01));

            // Añadir una pequeña componente Y para dar una inclinación 3D inicial
            initialVelocity.y = THREE.MathUtils.randFloatSpread(orbitVelocityMag * 0.1); 

            // 3. GENERAR EL RESTO DE PROPIEDADES
            const radius = THREE.MathUtils.randFloat(1, 4); 
            
            const baseColor = new THREE.Color(Math.random(), Math.random(), Math.random());
            const hsl = {};
            baseColor.getHSL(hsl);
            hsl.l = THREE.MathUtils.randFloat(0.7, 0.9);
            hsl.s = THREE.MathUtils.randFloat(0.4, 0.8); 
            const brightColor = new THREE.Color().setHSL(hsl.h, hsl.s, hsl.l);


            // 4. Configuración de AUDIO (Solo asignación de capa)
            
            // Asignación de Capa (El instrumento al que se asigna este planeta)
            // Asigna la siguiente capa del MIDI que no tenga un planeta activo
            const activeLayersCount = planets.filter(p => p.assignedLayer).length;
            const layerIndex = activeLayersCount % INSTRUMENT_LAYERS.length;
            const assignedLayer = INSTRUMENT_LAYERS[layerIndex];
            
            // Crear un objeto dummy para audio
            const { synth, panner } = createSynth(); 
            
            // 5. Malla y Rastro (similar al código anterior)
            const planetGeometry = new THREE.SphereGeometry(radius, 32, 32);
            const planetMaterial = new THREE.MeshLambertMaterial({ 
                color: brightColor, 
                emissive: brightColor.clone().multiplyScalar(0.1) 
            });
            const planetMesh = new THREE.Mesh(planetGeometry, planetMaterial);
            planetMesh.position.copy(initialPosition);

            const orbitPositions = new Float32Array(TRAIL_LENGTH * 3); 
            const drawingPositions = new Float32Array(TRAIL_LENGTH * 3);
            
            // Creación del Array de Colores (RGBA: 4 componentes por punto)
            const trailColors = new Float32Array(TRAIL_LENGTH * 4); 

            const trailGeometry = new THREE.BufferGeometry();
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(drawingPositions, 3)); 
            trailGeometry.setAttribute('color', new THREE.BufferAttribute(trailColors, 4)); // Añadir atributo de color/opacidad
            
            const trailMaterial = new THREE.LineBasicMaterial({
                color: brightColor, 
                transparent: true,
                opacity: 1.0,
                vertexColors: true // Usar colores definidos por el vértice
            });
            const orbitTrail = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(orbitTrail);

            // 6. Crear Objeto para el planeta (PROPIEDADES DE FÍSICA Y AUDIO)
            const planetObject = {
                mesh: planetMesh,
                trail: orbitTrail,
                orbitPositions: orbitPositions, 
                trailColors: trailColors, // Almacenar el array de colores
                planetColor: brightColor, // Color base del planeta
                trailIndex: 0,
                trailLength: TRAIL_LENGTH,
                trailCount: 0,
                // PROPIEDADES DE FÍSICA
                mass: PLANET_MASS,
                velocity: initialVelocity, // Vector3
                acceleration: new THREE.Vector3(0, 0, 0), // Vector3
                // PROPIEDADES DE AUDIO
                synth: synth,
                panner: panner, // Nuevo panner
                assignedLayer: assignedLayer, // Capa de la canción asignada (Ej: 'Cancion1_1')
                // PROPIEDADES DE TRIVIA
                id: planets.length + 1, // Asignar un ID para identificarlo en la trivia
                pulseTypeName: `Pista: ${assignedLayer}` // Nombre legible
            };

            scene.add(planetMesh);
            planets.push(planetObject);
            
            // --- ACTUALIZACIÓN DE VOLUMENES (Lógica visual de estado) ---
            updateAudioVolumes();
            // ---------------------------------------------
            
            // CAMBIO AQUÍ: Simplificamos el mensaje
            showMessage('¡Planeta Creado!', 1500, brightColor);
        }

        /**
         * Alterna el estado de pausa de la simulación y la música.
         */
        function togglePause() {
            isPaused = !isPaused;
            const button = document.getElementById('pauseButton');
            
            if (isPaused) {
                button.textContent = 'Reanudar Simulación';
                button.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                button.classList.add('bg-green-600', 'hover:bg-green-700');
                showMessage('Simulación PAUSADA.', 1500, new THREE.Color(0xfb923c));
                // Lógica para pausar el audio (si estuviera activo)
                if (musicStarted) { Tone.Transport.pause(); }
            } else {
                button.textContent = 'Pausar Simulación';
                button.classList.remove('bg-green-600', 'hover:bg-green-700');
                button.classList.add('bg-blue-600', 'hover:bg-blue-700');
                showMessage('Simulación REANUDADA.', 1500, new THREE.Color(0x22c55e));
                // Lógica para reanudar el audio (si estuviera activo)
                if (musicStarted) { Tone.Transport.start(); }
            }
        }

        /**
         * Elimina todos los planetas, soles, sus rastros y sus sintetizadores.
         */
        function clearSimulation() {
            const initialSuns = suns.length;
            
            // Limpieza de estados
            musicStarted = false;
            currentSongIndex = 0;
            INSTRUMENT_LAYERS = SONG_DATA_STRUCTURES[0].layers;
            
            // Detener el audio
            Tone.Transport.stop();
            Tone.Transport.cancel();
            Tone.Master.mute = true;


            // Limpieza de Planetas
            planets.forEach(planet => {
                scene.remove(planet.mesh);
                scene.remove(planet.trail);
            });
            planets.length = 0;

            // Limpieza de Soles
            suns.forEach(sun => {
                scene.remove(sun.mesh);
                scene.remove(sun.light);
            });
            suns.length = 0;
            
            // Vuelve a crear el sol inicial
            if (initialSuns === 0) {
                 createInitialSun(); 
            } else {
                // Si el audio estaba cargado, recargar la canción inicial
                if (isAudioContextStarted && currentMidiData) {
                    loadMidiAndSetup(0); // Recargar la primera canción
                }
            }
            
            showMessage('Simulación Reiniciada. ¡Crea nuevos sistemas!', 2500, new THREE.Color(0xef4444));
        }

        /**
         * Maneja el redimensionamiento de la ventana para mantener la vista correcta.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // =================================================================
        // LÓGICA MIDI REAL
        // =================================================================

        /**
         * Inicializa los Samplers de Tone.js (instrumentos reales).
         */
        async function setupMidiPlayers() {
            // Un mapa simple de Instrumentos General MIDI (GM) a sonidos de Sampler
            const GM_INSTRUMENT_MAP = {
                'piano': 'piano', 'bass': 'bass-electric', 'drums': 'drums', 'brass': 'trumpet', 
                'synth': 'synth_lead', 'strings': 'violin', 'guitar': 'guitar-acoustic'
            };
            
            const samplerPromises = [];
            
            // Solo necesitamos 10 Samplers, uno por cada posible pista activa
            for (let i = 0; i < TRACKS_PER_SONG; i++) {
                // Usamos una clave genérica para los Samplers (siempre se cargará piano por estabilidad)
                const sampler = new Tone.Sampler({
                    urls: { "C4": `piano-c4.mp3` }, 
                    baseUrl: "https://tonejs.github.io/audio/salamander/", 
                    onload: () => {
                        sampler.volume.value = -100; // Silenciado por defecto
                        sampler.toDestination();
                    },
                    onerror: (e) => {
                        console.error(`Error al cargar sampler:`, e);
                    }
                }).toDestination();
                
                midiPlayers.push(sampler);
                samplerPromises.push(new Promise(resolve => sampler.onload = resolve));
            }
            
            await Promise.all(samplerPromises);
            
            // Una vez cargados los 10 Samplers, procedemos a cargar la primera canción MIDI
            await loadMidiAndSetup(currentSongIndex);
        }
        
        /**
         * Inicia el secuenciador de Tone.js con los datos MIDI.
         * @param {number} songIndex Índice de la canción a cargar
         */
        function startSequencer(midiArray) {
            Tone.Transport.cancel();
            
            // Usamos el BPM del primer archivo MIDI
            Tone.Transport.bpm.value = midiArray[0].header.tempos[0].bpm || 128; 

            midiArray.slice(0, TRACKS_PER_SONG).forEach((midi, i) => {
                const track = midi.tracks.length > 0 ? midi.tracks[0] : null; 
                if (!track) return;

                const notes = track.notes;
                const player = midiPlayers[i];

                const part = new Tone.Part((time, note) => {
                    // Solo reproducimos si la capa está activa (activada por un planeta)
                    if (activePatterns[INSTRUMENT_LAYERS[i]]) {
                        player.triggerAttackRelease(
                            note.name, 
                            note.duration, 
                            time, 
                            note.velocity
                        );

                        // Visualización rítmica (parpadeo del planeta)
                        Tone.Draw.schedule(() => {
                            activeNotes[INSTRUMENT_LAYERS[i]] = true;
                            setTimeout(() => activeNotes[INSTRUMENT_LAYERS[i]] = false, Tone.Time(note.duration).toMilliseconds() * 0.5);
                        }, time);
                    }
                }, notes).start(0);

                part.loop = true;
                part.loopEnd = midi.duration || "4m";
            });

            // Usamos la duración del primer MIDI como duración del loop principal
            Tone.Transport.loop = true;
            Tone.Transport.loopEnd = midiArray[0].duration || "4m";
            
            Tone.Transport.start();
            showMessage(`¡Música ${SONG_DATA_STRUCTURES[currentSongIndex].name} lista! Crea tu primer planeta.`, 2000, new THREE.Color(0x22c55e));
        }

        /**
         * Carga el archivo MIDI de forma asíncrona.
         */
        async function loadMidiAndSetup(songIndex) {
             showMessage(`Cargando partitura MIDI para ${SONG_DATA_STRUCTURES[songIndex].name}...`, 3000, new THREE.Color(0xfacc15));
             
             // 1. Crear 10 promesas de carga para las 10 pistas
             const midiPromises = [];
             for(let i = 0; i < TRACKS_PER_SONG; i++) {
                 const MIDI_PATH = getTrackPath(songIndex, i); 
                 
                 // Usamos fetch para asegurar que el navegador pueda acceder al archivo
                 const loadPromise = fetch(MIDI_PATH)
                     .then(response => {
                         if (!response.ok) {
                             // Si no se encuentra el archivo (Error 404), no lanzamos error fatal, devolvemos un MIDI vacío
                             console.warn(`Advertencia: Pista ${i + 1} (${MIDI_PATH}) no encontrada. La pista estará en silencio.`);
                             return { tracks: [], duration: 0, header: { tempos: [{ bpm: 128 }] } };
                         }
                         return response.arrayBuffer();
                     })
                     .then(arrayBuffer => Midi.fromBuffer(arrayBuffer))
                     .catch(e => {
                         console.error(`Fallo al procesar Pista ${i + 1}:`, e);
                         // Devolver un objeto MIDI vacío si hay un fallo en el procesamiento
                         return { tracks: [], duration: 0, header: { tempos: [{ bpm: 128 }] } }; 
                     });
                 
                 midiPromises.push(loadPromise);
             }
            
            // 2. Esperar a que todos los archivos MIDI carguen
            const loadedMidis = await Promise.all(midiPromises);
            
            // 3. Almacenar y comenzar la secuencia
            currentMidiData = loadedMidis; 
            
            // 4. Iniciar el secuenciador con el array de midis
            startSequencer(loadedMidis);
        }

        /**
         * Función dummy para mantener la estructura de planet.synth (ahora solo mute/unmute)
         */
        function createSynth() {
            return { synth: null, panner: null }; 
        }

        /**
         * Inicia el contexto de audio y la carga del MIDI.
         */
        function startAudioContext() {
            if (!isAudioContextStarted) {
                // Iniciar el Contexto de Audio con interacción del usuario
                Tone.start(); 
                isAudioContextStarted = true;
                
                // Iniciar la carga de Samplers y MIDI
                setupMidiPlayers();
            }
        }
        
        /**
         * Función que cambia la canción al crear un nuevo Sol.
         */
        function changeSong() {
            // Ciclo a la siguiente canción
            currentSongIndex = (currentSongIndex + 1) % TOTAL_SONGS; 
            
            // 1. Limpiar patrones visuales
            activePatterns = {};
            planets.forEach(p => p.assignedLayer = INSTRUMENT_LAYERS[0]);
            
            // 2. Actualizar las capas de instrumento disponibles (para la UI)
            INSTRUMENT_LAYERS = SONG_DATA_STRUCTURES[currentSongIndex].layers;

            // 3. Cargar la nueva canción MIDI
            // NOTA: No esperamos aquí, el resto de la app es asíncrona.
            loadMidiAndSetup(currentSongIndex); 
            
            // 4. Actualizar volumen (silenciar capas)
            updateAudioVolumes();
            
            showMessage(`Música cambiada a: ${SONG_DATA_STRUCTURES[currentSongIndex].name}`, 2000, new THREE.Color(0xfacc15));
        }
        
        /**
         * Controla qué patrones rítmicos están activos (solo lógica, sin audio).
         */
        function updateAudioVolumes() {
            // 1. Mapear qué capas están activas visualmente (para el MIDI)
            INSTRUMENT_LAYERS.forEach(layer => activePatterns[layer] = false);
            
            planets.forEach((planet, index) => {
                const layerIndex = index % TRACKS_PER_SONG;
                const layerName = INSTRUMENT_LAYERS[layerIndex];
                
                planet.assignedLayer = layerName;
                activePatterns[layerName] = true;
                
                // Controlar el volumen real del sampler (si existe)
                if (midiPlayers[layerIndex]) {
                    midiPlayers[layerIndex].volume.value = 0; // Activar (0dB)
                }
            });
            
            // Silenciar las capas sin planeta
            for (let i = planets.length; i < TRACKS_PER_SONG; i++) {
                 if (midiPlayers[i]) {
                    midiPlayers[i].volume.value = -100; // Silenciar
                 }
            }


            // 3. Controlar el estado general 
            if (planets.length > 0 && !musicStarted) {
                musicStarted = true;
                Tone.Master.mute = false; // Desmutear la música
            } else if (planets.length === 0 && musicStarted) {
                musicStarted = false;
                Tone.Master.mute = true; // Mutear todo
            }
        }


        // =================================================================
        // FUNCIONES DE FÍSICA
        // =================================================================

        /**
         * Calcula la aceleración gravitacional neta sobre el planeta causada por todos los soles.
         * F = G * M1 * M2 / r^2
         * A = F / M2 = G * M1 / r^2
         * @param {object} planet El objeto planeta con posición, masa y aceleración.
         */
        function calculateGravity(planet) {
            const netAcceleration = new THREE.Vector3(0, 0, 0);

            suns.forEach(sun => {
                // Vector que apunta del planeta al sol
                const direction = tempVector.copy(sun.mesh.position).sub(planet.mesh.position);
                const distanceSq = direction.lengthSq();

                // Evitar división por cero o fuerzas infinitas en colisión cercana
                if (distanceSq < 1) { 
                    return;
                }
                
                const distance = Math.sqrt(distanceSq);

                // Fuerza gravitacional: A = (G * M_sol / r^2) * (vector unitario)
                const magnitude = (GRAVITATIONAL_CONSTANT * SUN_MASS) / distanceSq;

                // Asegurar que la fuerza no sea demasiado grande a corta distancia
                const maxMagnitude = 5.0; // Límite de aceleración para estabilidad
                const finalMagnitude = Math.min(magnitude, maxMagnitude);

                direction.normalize().multiplyScalar(finalMagnitude);
                
                netAcceleration.add(direction);
            });

            planet.acceleration = netAcceleration;
        }

        /**
         * Aplica la integración de Euler para actualizar la velocidad y posición.
         * @param {object} planet El objeto planeta.
         * @param {number} deltaTime El paso de tiempo.
         */
        function updatePhysics(planet, deltaTime) {
            // Velocidad = Velocidad + Aceleración * dt
            planet.velocity.add(planet.acceleration.clone().multiplyScalar(deltaTime));
            
            // Posición = Posición + Velocidad * dt
            planet.mesh.position.add(planet.velocity.clone().multiplyScalar(deltaTime));
        }

        /**
         * Encuentra el Sol más cercano al punto de click.
         * @param {THREE.Vector3} clickPosition Posición 3D del click.
         * @returns {object} El objeto Sol más cercano.
         */
        function findNearestSun(clickPosition) {
            let minDistanceSq = Infinity;
            let nearestSun = null;
            
            suns.forEach(sun => {
                // Usamos subVectors y lengthSq para calcular la distancia.
                const diffVector = new THREE.Vector3().subVectors(sun.mesh.position, clickPosition);
                const distanceSq = diffVector.lengthSq(); 
                
                if (distanceSq < minDistanceSq) {
                    minDistanceSq = distanceSq;
                    nearestSun = sun;
                }
            });

            return nearestSun;
        }

        // =================================================================
        // UTILIDADES
        // =================================================================

        /**
         * Inicializa la escena, cámara, renderizador y luces.
         */
        function init() {
            // 1. Configuración de la Escena
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0d0d1a, 0.003); 

            // 2. Configuración de la Cámara (perspectiva para 3D)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, ORBIT_RADIUS); // Posición inicial aumentada a 250
            
            // 3. Configuración del Renderizador (WebGL)
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1);
            // Añadir una clase para apuntar con CSS si queremos aumentar el grosor de línea
            renderer.domElement.classList.add('webgl-canvas'); 
            
            // ** CORRECCIÓN: Asegurar que el canvas se adjunta al DOM **
            const container = document.getElementById('container');
            if (container) {
                 container.appendChild(renderer.domElement);
            } else {
                 console.error("Error crítico: El contenedor #container no se encontró.");
            }
            // ********************************************************
            
            // 4. Configuración de la Iluminación
            ambientLight = new THREE.AmbientLight(0x404040, 0.5); 
            scene.add(ambientLight);

            // 5. Crear el Sol Central Inicial y el Fondo de Estrellas
            createInitialSun(); 
            createStarField(); 
            
            // 6. Manejadores de Eventos
            window.addEventListener('resize', onWindowResize, false);
            setupPointerControls(renderer.domElement);
        }

        /**
         * Crea el primer Sol al iniciar la simulación.
         */
        function createInitialSun() {
            // Sol inicial ligeramente desplazado para evitar la singularidad de la órbita inicial
            const center = new THREE.Vector3(5, 0, 0); 
            createSunAtPosition(center);
        }

        /**
         * Crea un objeto Sol y lo añade a la escena y al array de Soles.
         * @param {THREE.Vector3} position Posición del nuevo sol.
         */
        function createSunAtPosition(position) {
            const sunRadius = 12;
            const sunGeometry = new THREE.SphereGeometry(sunRadius, 32, 32); 
            const sunMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                emissive: 0xff8800 
            }); 
            const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            sunMesh.position.copy(position);
            scene.add(sunMesh);
            
            const flareTexture = generateRadialTexture(); 

            const lightSprite = new THREE.Sprite(new THREE.SpriteMaterial({
                map: flareTexture,
                color: 0xff8800, 
                blending: THREE.AdditiveBlending, 
                transparent: true,
                opacity: 0.7 
            }));
            lightSprite.scale.set(50, 50, 1.0); 
            sunMesh.add(lightSprite);

            // Cada sol necesita una luz para iluminar a los planetas a su alrededor
            const sunLight = new THREE.PointLight(0xffffff, 3.0, 0, 0); 
            sunLight.position.copy(position);
            scene.add(sunLight);

            // Se almacena el mesh para acceder a su posición Vector3
            suns.push({ mesh: sunMesh, light: sunLight, mass: SUN_MASS });
            
            // --- NUEVA LÓGICA: CAMBIAR LA CANCIÓN AL CREAR UN NUEVO SOL ---
            if (suns.length > 1 && musicStarted) {
                changeSong();
            }
        }


        /**
         * Crea un campo de estrellas aleatorias para el fondo.
         */
        function createStarField() {
            const starCount = 1500;
            const starGeometry = new THREE.BufferGeometry();
            const positions = [];
            
            const radius = 500; 

            for (let i = 0; i < starCount; i++) {
                const x = THREE.MathUtils.randFloatSpread(radius * 2);
                const y = THREE.MathUtils.randFloatSpread(radius * 2);
                const z = THREE.MathUtils.randFloatSpread(radius * 2);

                positions.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1, 
                sizeAttenuation: true 
            });

            starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }
        
        /**
         * Genera una textura circular suave con degradado para simular un brillo (flare).
         */
        function generateRadialTexture() {
            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');

            const gradient = context.createRadialGradient(
                size / 2, size / 2, 0, 
                size / 2, size / 2, size / 2 
            );
            gradient.addColorStop(0, 'rgba(255,255,255,1)'); 
            gradient.addColorStop(1, 'rgba(255,255,255,0)'); 

            context.fillStyle = gradient;
            context.fillRect(0, 0, size, size);

            return new THREE.CanvasTexture(canvas);
        }

        /**
         * Configura los eventos de mouse y touch para el control de la cámara.
         */
        function setupPointerControls(element) {
            element.addEventListener('pointerdown', onPointerDown, false);
            element.addEventListener('pointermove', onPointerMove, false);
            element.addEventListener('pointerup', onPointerUp, false);
            element.addEventListener('pointerleave', onPointerUp, false);
        }

        /**
         * Evento al pulsar (clic o tocar).
         */
        function onPointerDown(event) {
            if (event.buttons === 1 || event.pointerType === 'touch') { 
                isPointerActive = true; 
                isDragging = false; 
                
                pointerStart.x = event.clientX;
                pointerStart.y = event.clientY;

                previousPointerPosition.x = event.clientX;
                previousPointerPosition.y = event.clientY;
                velocityX = 0;
                velocityY = 0;
            }
        }

        /**
         * Evento al mover el puntero (arrastrar).
         */
        function onPointerMove(event) {
            
            if (!isPointerActive) return; 

            if (!isDragging) {
                const deltaMovementX = event.clientX - pointerStart.x;
                const deltaMovementY = event.clientY - pointerStart.y;
                const distance = Math.sqrt(deltaMovementX * deltaMovementX + deltaMovementY * deltaMovementY); 
                
                if (distance > DRAG_THRESHOLD) {
                    isDragging = true; 
                }
            }

            if (isDragging) { 
                const deltaX = event.clientX - previousPointerPosition.x;
                const deltaY = event.clientY - previousPointerPosition.y;

                theta += deltaX * ROTATION_MULTIPLIER;
                phi -= deltaY * ROTATION_MULTIPLIER;
                
                velocityX = deltaX * ROTATION_MULTIPLIER * 0.5;
                velocityY = deltaY * ROTATION_MULTIPLIER * 0.5;

                previousPointerPosition.x = event.clientX;
                previousPointerPosition.y = event.clientY;
            }
        }

        /**
         * Evento al soltar (dejar de arrastrar o crear entidad).
         */
        function onPointerUp(event) {
            if (isPointerActive && !isDragging) { 
                const entitySelect = document.getElementById('entitySelect');
                const selectedEntity = entitySelect ? entitySelect.value : 'planet';
                
                if (selectedEntity === 'planet') {
                    createPlanet(event);
                } else if (selectedEntity === 'sun') {
                    createSunOnClick(event);
                }
            }
            
            isDragging = false; 
            isPointerActive = false; 
        }

        /**
         * Intenta crear un Sol en la posición del click/toque.
         */
        function createSunOnClick(event) {
            // Mapeo de coordenadas de pantalla a un punto en el espacio 3D
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // Proyectar en el plano Y=0 (el "suelo" de la simulación)
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); 
            const intersection = new THREE.Vector3();
            
            raycaster.ray.intersectPlane(plane, intersection);

            // Limitar la distancia del Sol para evitar que aparezca muy lejos
            if (intersection.length() > MAX_SUN_DISTANCE) {
                intersection.normalize().multiplyScalar(MAX_SUN_DISTANCE);
                showMessage('Sol colocado en el límite de la zona central.', 2000, new THREE.Color(0xfacc15));
            }


            createSunAtPosition(intersection);
            showMessage('¡Nuevo Sol Creado! Ahora afecta la gravedad.', 2000, new THREE.Color(0xfacc15));
        }

        /**
         * Crea un nuevo planeta.
         * @param {PointerEvent} event El evento de puntero (contiene clientX/Y).
         */
        function createPlanet(event) {
            startAudioContext(); 

            if (suns.length === 0) {
                showMessage('No hay soles para orbitar. ¡Crea un Sol primero!', 3000, new THREE.Color(0xef4444));
                return;
            }
            
            // Mapeo de coordenadas de pantalla a un punto en el espacio 3D
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // Proyectar en el plano Y=0 (el "suelo" de la simulación)
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); 
            const intersection = new THREE.Vector3();
            
            raycaster.ray.intersectPlane(plane, intersection);
            const initialPosition = intersection.clone();

            // --- 1. ENCONTRAR EL SOL MÁS CERCANO PARA INICIALIZAR LA ÓRBITA ---
            const nearestSun = findNearestSun(initialPosition);
            
            // Usamos la posición del mesh del sol para la física
            const relativePosition = initialPosition.clone().sub(nearestSun.mesh.position);
            const distance = relativePosition.length();

            // VERIFICACIÓN DE SEGURIDAD CRÍTICA: La distancia NO debe ser 0.
            if (distance < COLLISION_DISTANCE) {
                showMessage('Demasiado cerca del Sol. Intenta más lejos.', 3000, new THREE.Color(0xfacc15));
                return;
            }

            // 2. CÁLCULO DE VELOCIDAD INICIAL (para órbita circular aproximada alrededor del Sol más cercano)
            
            // Magnitud de la velocidad orbital: v = sqrt(G*M/r)
            const orbitVelocityMag = Math.sqrt((GRAVITATIONAL_CONSTANT * SUN_MASS) / distance);
            
            // Dirección de la velocidad: perpendicular al vector posición (para iniciar la órbita)
            const positionUnit = relativePosition.clone().normalize();
            
            // Crea un vector perpendicular para la velocidad inicial (Vector3 perpendicular a positionUnit y Y-axis)
            let initialVelocity = new THREE.Vector3().crossVectors(positionUnit, new THREE.Vector3(0, 1, 0));
            
            // CORRECCIÓN CRÍTICA: Asegurar que el vector de velocidad no sea nulo si el producto cruz falla
            if (initialVelocity.lengthSq() < 0.001) {
                // Si falla (ej. el planeta está exactamente en el eje Y), usa una dirección arbitraria perpendicular (Eje X)
                 initialVelocity.set(1, 0, 0); 
            }
            
            // Velocidad inicial ajustada (0.99 a 1.01) para asegurar una órbita estable
            initialVelocity.normalize().multiplyScalar(orbitVelocityMag * THREE.MathUtils.randFloat(0.99, 1.01));

            // Añadir una pequeña componente Y para dar una inclinación 3D inicial
            initialVelocity.y = THREE.MathUtils.randFloatSpread(orbitVelocityMag * 0.1); 

            // 3. GENERAR EL RESTO DE PROPIEDADES
            const radius = THREE.MathUtils.randFloat(1, 4); 
            
            const baseColor = new THREE.Color(Math.random(), Math.random(), Math.random());
            const hsl = {};
            baseColor.getHSL(hsl);
            hsl.l = THREE.MathUtils.randFloat(0.7, 0.9);
            hsl.s = THREE.MathUtils.randFloat(0.4, 0.8); 
            const brightColor = new THREE.Color().setHSL(hsl.h, hsl.s, hsl.l);


            // 4. Configuración de AUDIO (Solo asignación de capa)
            
            // Asignación de Capa (El instrumento al que se asigna este planeta)
            // Asigna la siguiente capa del MIDI que no tenga un planeta activo
            const activeLayersCount = planets.filter(p => p.assignedLayer).length;
            const layerIndex = activeLayersCount % INSTRUMENT_LAYERS.length;
            const assignedLayer = INSTRUMENT_LAYERS[layerIndex];
            
            // Crear un objeto dummy para audio
            const { synth, panner } = createSynth(); 
            
            // 5. Malla y Rastro (similar al código anterior)
            const planetGeometry = new THREE.SphereGeometry(radius, 32, 32);
            const planetMaterial = new THREE.MeshLambertMaterial({ 
                color: brightColor, 
                emissive: brightColor.clone().multiplyScalar(0.1) 
            });
            const planetMesh = new THREE.Mesh(planetGeometry, planetMaterial);
            planetMesh.position.copy(initialPosition);

            const orbitPositions = new Float32Array(TRAIL_LENGTH * 3); 
            const drawingPositions = new Float32Array(TRAIL_LENGTH * 3);
            
            // Creación del Array de Colores (RGBA: 4 componentes por punto)
            const trailColors = new Float32Array(TRAIL_LENGTH * 4); 

            const trailGeometry = new THREE.BufferGeometry();
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(drawingPositions, 3)); 
            trailGeometry.setAttribute('color', new THREE.BufferAttribute(trailColors, 4)); // Añadir atributo de color/opacidad
            
            const trailMaterial = new THREE.LineBasicMaterial({
                color: brightColor, 
                transparent: true,
                opacity: 1.0,
                vertexColors: true // Usar colores definidos por el vértice
            });
            const orbitTrail = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(orbitTrail);

            // 6. Crear Objeto para el planeta (PROPIEDADES DE FÍSICA Y AUDIO)
            const planetObject = {
                mesh: planetMesh,
                trail: orbitTrail,
                orbitPositions: orbitPositions, 
                trailColors: trailColors, // Almacenar el array de colores
                planetColor: brightColor, // Color base del planeta
                trailIndex: 0,
                trailLength: TRAIL_LENGTH,
                trailCount: 0,
                // PROPIEDADES DE FÍSICA
                mass: PLANET_MASS,
                velocity: initialVelocity, // Vector3
                acceleration: new THREE.Vector3(0, 0, 0), // Vector3
                // PROPIEDADES DE AUDIO
                synth: synth,
                panner: panner, // Nuevo panner
                assignedLayer: assignedLayer, // Capa de la canción asignada (Ej: 'Cancion1_1')
                // PROPIEDADES DE TRIVIA
                id: planets.length + 1, // Asignar un ID para identificarlo en la trivia
                pulseTypeName: `Pista: ${assignedLayer}` // Nombre legible
            };

            scene.add(planetMesh);
            planets.push(planetObject);
            
            // --- ACTUALIZACIÓN DE VOLUMENES (Lógica visual de estado) ---
            updateAudioVolumes();
            // ---------------------------------------------
            
            // CAMBIO AQUÍ: Simplificamos el mensaje
            showMessage('¡Planeta Creado!', 1500, brightColor);
        }

        /**
         * Alterna el estado de pausa de la simulación y la música.
         */
        function togglePause() {
            isPaused = !isPaused;
            const button = document.getElementById('pauseButton');
            
            if (isPaused) {
                button.textContent = 'Reanudar Simulación';
                button.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                button.classList.add('bg-green-600', 'hover:bg-green-700');
                showMessage('Simulación PAUSADA.', 1500, new THREE.Color(0xfb923c));
                // Lógica para pausar el audio (si estuviera activo)
                if (musicStarted) { Tone.Transport.pause(); }
            } else {
                button.textContent = 'Pausar Simulación';
                button.classList.remove('bg-green-600', 'hover:bg-green-700');
                button.classList.add('bg-blue-600', 'hover:bg-blue-700');
                showMessage('Simulación REANUDADA.', 1500, new THREE.Color(0x22c55e));
                // Lógica para reanudar el audio (si estuviera activo)
                if (musicStarted) { Tone.Transport.start(); }
            }
        }

        /**
         * Elimina todos los planetas, soles, sus rastros y sus sintetizadores.
         */
        function clearSimulation() {
            const initialSuns = suns.length;
            
            // Limpieza de estados
            musicStarted = false;
            currentSongIndex = 0;
            INSTRUMENT_LAYERS = SONG_DATA_STRUCTURES[0].layers;
            
            // Detener el audio
            Tone.Transport.stop();
            Tone.Transport.cancel();
            Tone.Master.mute = true;


            // Limpieza de Planetas
            planets.forEach(planet => {
                scene.remove(planet.mesh);
                scene.remove(planet.trail);
            });
            planets.length = 0;

            // Limpieza de Soles
            suns.forEach(sun => {
                scene.remove(sun.mesh);
                scene.remove(sun.light);
            });
            suns.length = 0;
            
            // Vuelve a crear el sol inicial
            if (initialSuns === 0) {
                 createInitialSun(); 
            } else {
                // Si el audio estaba cargado, recargar la canción inicial
                if (isAudioContextStarted && currentMidiData) {
                    loadMidiAndSetup(0); // Recargar la primera canción
                }
            }
            
            showMessage('Simulación Reiniciada. ¡Crea nuevos sistemas!', 2500, new THREE.Color(0xef4444));
        }

        /**
         * Maneja el redimensionamiento de la ventana para mantener la vista correcta.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // =================================================================
        // LÓGICA MIDI REAL
        // =================================================================

        /**
         * Inicializa los Samplers de Tone.js (instrumentos reales).
         */
        async function setupMidiPlayers() {
            // Un mapa simple de Instrumentos General MIDI (GM) a sonidos de Sampler
            const GM_INSTRUMENT_MAP = {
                'piano': 'piano', 'bass': 'bass-electric', 'drums': 'drums', 'brass': 'trumpet', 
                'synth': 'synth_lead', 'strings': 'violin', 'guitar': 'guitar-acoustic'
            };
            
            const samplerPromises = [];
            
            // Solo necesitamos 10 Samplers, uno por cada posible pista activa
            for (let i = 0; i < TRACKS_PER_SONG; i++) {
                // Usamos una clave genérica para los Samplers (siempre se cargará piano por estabilidad)
                const sampler = new Tone.Sampler({
                    urls: { "C4": `piano-c4.mp3` }, 
                    baseUrl: "https://tonejs.github.io/audio/salamander/", 
                    onload: () => {
                        sampler.volume.value = -100; // Silenciado por defecto
                        sampler.toDestination();
                    },
                    onerror: (e) => {
                        console.error(`Error al cargar sampler:`, e);
                    }
                }).toDestination();
                
                midiPlayers.push(sampler);
                samplerPromises.push(new Promise(resolve => sampler.onload = resolve));
            }
            
            await Promise.all(samplerPromises);
            
            // Una vez cargados los 10 Samplers, procedemos a cargar la primera canción MIDI
            await loadMidiAndSetup(currentSongIndex);
        }
        
        /**
         * Inicia el secuenciador de Tone.js con los datos MIDI.
         * @param {number} songIndex Índice de la canción a cargar
         */
        function startSequencer(midiArray) {
            Tone.Transport.cancel();
            
            // Usamos el BPM del primer archivo MIDI
            Tone.Transport.bpm.value = midiArray[0].header.tempos[0].bpm || 128; 

            midiArray.slice(0, TRACKS_PER_SONG).forEach((midi, i) => {
                const track = midi.tracks.length > 0 ? midi.tracks[0] : null; 
                if (!track) return;

                const notes = track.notes;
                const player = midiPlayers[i];

                const part = new Tone.Part((time, note) => {
                    // Solo reproducimos si la capa está activa (activada por un planeta)
                    if (activePatterns[INSTRUMENT_LAYERS[i]]) {
                        player.triggerAttackRelease(
                            note.name, 
                            note.duration, 
                            time, 
                            note.velocity
                        );

                        // Visualización rítmica (parpadeo del planeta)
                        Tone.Draw.schedule(() => {
                            activeNotes[INSTRUMENT_LAYERS[i]] = true;
                            setTimeout(() => activeNotes[INSTRUMENT_LAYERS[i]] = false, Tone.Time(note.duration).toMilliseconds() * 0.5);
                        }, time);
                    }
                }, notes).start(0);

                part.loop = true;
                part.loopEnd = midi.duration || "4m";
            });

            // Usamos la duración del primer MIDI como duración del loop principal
            Tone.Transport.loop = true;
            Tone.Transport.loopEnd = midiArray[0].duration || "4m";
            
            Tone.Transport.start();
            showMessage(`¡Música ${SONG_DATA_STRUCTURES[currentSongIndex].name} lista! Crea tu primer planeta.`, 2000, new THREE.Color(0x22c55e));
        }

        /**
         * Carga el archivo MIDI de forma asíncrona.
         */
        async function loadMidiAndSetup(songIndex) {
             showMessage(`Cargando partitura MIDI para ${SONG_DATA_STRUCTURES[songIndex].name}...`, 3000, new THREE.Color(0xfacc15));
             
             // 1. Crear 10 promesas de carga para las 10 pistas
             const midiPromises = [];
             for(let i = 0; i < TRACKS_PER_SONG; i++) {
                 const MIDI_PATH = getTrackPath(songIndex, i); 
                 
                 // Usamos fetch para asegurar que el navegador pueda acceder al archivo
                 const loadPromise = fetch(MIDI_PATH)
                     .then(response => {
                         if (!response.ok) {
                             // Si no se encuentra el archivo (Error 404), no lanzamos error fatal, devolvemos un MIDI vacío
                             console.warn(`Advertencia: Pista ${i + 1} (${MIDI_PATH}) no encontrada. La pista estará en silencio.`);
                             return { tracks: [], duration: 0, header: { tempos: [{ bpm: 128 }] } };
                         }
                         return response.arrayBuffer();
                     })
                     .then(arrayBuffer => Midi.fromBuffer(arrayBuffer))
                     .catch(e => {
                         console.error(`Fallo al procesar Pista ${i + 1}:`, e);
                         // Devolver un objeto MIDI vacío si hay un fallo en el procesamiento
                         return { tracks: [], duration: 0, header: { tempos: [{ bpm: 128 }] } }; 
                     });
                 
                 midiPromises.push(loadPromise);
             }
            
            // 2. Esperar a que todos los archivos MIDI carguen
            const loadedMidis = await Promise.all(midiPromises);
            
            // 3. Almacenar y comenzar la secuencia
            currentMidiData = loadedMidis; 
            
            // 4. Iniciar el secuenciador con el array de midis
            startSequencer(loadedMidis);
        }

        /**
         * Función dummy para mantener la estructura de planet.synth (ahora solo mute/unmute)
         */
        function createSynth() {
            return { synth: null, panner: null }; 
        }

        /**
         * Inicia el contexto de audio y la carga del MIDI.
         */
        function startAudioContext() {
            if (!isAudioContextStarted) {
                // Iniciar el Contexto de Audio con interacción del usuario
                Tone.start(); 
                isAudioContextStarted = true;
                
                // Iniciar la carga de Samplers y MIDI
                setupMidiPlayers();
            }
        }
        
        /**
         * Función que cambia la canción al crear un nuevo Sol.
         */
        function changeSong() {
            // Ciclo a la siguiente canción
            currentSongIndex = (currentSongIndex + 1) % TOTAL_SONGS; 
            
            // 1. Limpiar patrones visuales
            activePatterns = {};
            planets.forEach(p => p.assignedLayer = INSTRUMENT_LAYERS[0]);
            
            // 2. Actualizar las capas de instrumento disponibles (para la UI)
            INSTRUMENT_LAYERS = SONG_DATA_STRUCTURES[currentSongIndex].layers;

            // 3. Cargar la nueva canción MIDI
            // NOTA: No esperamos aquí, el resto de la app es asíncrona.
            loadMidiAndSetup(currentSongIndex); 
            
            // 4. Actualizar volumen (silenciar capas)
            updateAudioVolumes();
            
            showMessage(`Música cambiada a: ${SONG_DATA_STRUCTURES[currentSongIndex].name}`, 2000, new THREE.Color(0xfacc15));
        }
        
        /**
         * Controla qué patrones rítmicos están activos (solo lógica, sin audio).
         */
        function updateAudioVolumes() {
            // 1. Mapear qué capas están activas visualmente (para el MIDI)
            INSTRUMENT_LAYERS.forEach(layer => activePatterns[layer] = false);
            
            planets.forEach((planet, index) => {
                const layerIndex = index % TRACKS_PER_SONG;
                const layerName = INSTRUMENT_LAYERS[layerIndex];
                
                planet.assignedLayer = layerName;
                activePatterns[layerName] = true;
                
                // Controlar el volumen real del sampler (si existe)
                if (midiPlayers[layerIndex]) {
                    midiPlayers[layerIndex].volume.value = 0; // Activar (0dB)
                }
            });
            
            // Silenciar las capas sin planeta
            for (let i = planets.length; i < TRACKS_PER_SONG; i++) {
                 if (midiPlayers[i]) {
                    midiPlayers[i].volume.value = -100; // Silenciar
                 }
            }


            // 3. Controlar el estado general 
            if (planets.length > 0 && !musicStarted) {
                musicStarted = true;
                Tone.Master.mute = false; // Desmutear la música
            } else if (planets.length === 0 && musicStarted) {
                musicStarted = false;
                Tone.Master.mute = true; // Mutear todo
            }
        }


        // =================================================================
        // FUNCIONES DE FÍSICA
        // =================================================================

        /**
         * Calcula la aceleración gravitacional neta sobre el planeta causada por todos los soles.
         * F = G * M1 * M2 / r^2
         * A = F / M2 = G * M1 / r^2
         * @param {object} planet El objeto planeta con posición, masa y aceleración.
         */
        function calculateGravity(planet) {
            const netAcceleration = new THREE.Vector3(0, 0, 0);

            suns.forEach(sun => {
                // Vector que apunta del planeta al sol
                const direction = tempVector.copy(sun.mesh.position).sub(planet.mesh.position);
                const distanceSq = direction.lengthSq();

                // Evitar división por cero o fuerzas infinitas en colisión cercana
                if (distanceSq < 1) { 
                    return;
                }
                
                const distance = Math.sqrt(distanceSq);

                // Fuerza gravitacional: A = (G * M_sol / r^2) * (vector unitario)
                const magnitude = (GRAVITATIONAL_CONSTANT * SUN_MASS) / distanceSq;

                // Asegurar que la fuerza no sea demasiado grande a corta distancia
                const maxMagnitude = 5.0; // Límite de aceleración para estabilidad
                const finalMagnitude = Math.min(magnitude, maxMagnitude);

                direction.normalize().multiplyScalar(finalMagnitude);
                
                netAcceleration.add(direction);
            });

            planet.acceleration = netAcceleration;
        }

        /**
         * Aplica la integración de Euler para actualizar la velocidad y posición.
         * @param {object} planet El objeto planeta.
         * @param {number} deltaTime El paso de tiempo.
         */
        function updatePhysics(planet, deltaTime) {
            // Velocidad = Velocidad + Aceleración * dt
            planet.velocity.add(planet.acceleration.clone().multiplyScalar(deltaTime));
            
            // Posición = Posición + Velocidad * dt
            planet.mesh.position.add(planet.velocity.clone().multiplyScalar(deltaTime));
        }

        /**
         * Encuentra el Sol más cercano al punto de click.
         * @param {THREE.Vector3} clickPosition Posición 3D del click.
         * @returns {object} El objeto Sol más cercano.
         */
        function findNearestSun(clickPosition) {
            let minDistanceSq = Infinity;
            let nearestSun = null;
            
            suns.forEach(sun => {
                // Usamos subVectors y lengthSq para calcular la distancia.
                const diffVector = new THREE.Vector3().subVectors(sun.mesh.position, clickPosition);
                const distanceSq = diffVector.lengthSq(); 
                
                if (distanceSq < minDistanceSq) {
                    minDistanceSq = distanceSq;
                    nearestSun = sun;
                }
            });

            return nearestSun;
        }

        // =================================================================
        // UTILIDADES
        // =================================================================

        /**
         * Inicializa la escena, cámara, renderizador y luces.
         */
        function init() {
            // 1. Configuración de la Escena
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0d0d1a, 0.003); 

            // 2. Configuración de la Cámara (perspectiva para 3D)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, ORBIT_RADIUS); // Posición inicial aumentada a 250
            
            // 3. Configuración del Renderizador (WebGL)
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1);
            // Añadir una clase para apuntar con CSS si queremos aumentar el grosor de línea
            renderer.domElement.classList.add('webgl-canvas'); 
            
            // ** CORRECCIÓN: Asegurar que el canvas se adjunta al DOM **
            const container = document.getElementById('container');
            if (container) {
                 container.appendChild(renderer.domElement);
            } else {
                 console.error("Error crítico: El contenedor #container no se encontró.");
            }
            // ********************************************************
            
            // 4. Configuración de la Iluminación
            ambientLight = new THREE.AmbientLight(0x404040, 0.5); 
            scene.add(ambientLight);

            // 5. Crear el Sol Central Inicial y el Fondo de Estrellas
            createInitialSun(); 
            createStarField(); 
            
            // 6. Manejadores de Eventos
            window.addEventListener('resize', onWindowResize, false);
            setupPointerControls(renderer.domElement);
        }

        /**
         * Crea el primer Sol al iniciar la simulación.
         */
        function createInitialSun() {
            // Sol inicial ligeramente desplazado para evitar la singularidad de la órbita inicial
            const center = new THREE.Vector3(5, 0, 0); 
            createSunAtPosition(center);
        }

        /**
         * Crea un objeto Sol y lo añade a la escena y al array de Soles.
         * @param {THREE.Vector3} position Posición del nuevo sol.
         */
        function createSunAtPosition(position) {
            const sunRadius = 12;
            const sunGeometry = new THREE.SphereGeometry(sunRadius, 32, 32); 
            const sunMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                emissive: 0xff8800 
            }); 
            const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            sunMesh.position.copy(position);
            scene.add(sunMesh);
            
            const flareTexture = generateRadialTexture(); 

            const lightSprite = new THREE.Sprite(new THREE.SpriteMaterial({
                map: flareTexture,
                color: 0xff8800, 
                blending: THREE.AdditiveBlending, 
                transparent: true,
                opacity: 0.7 
            }));
            lightSprite.scale.set(50, 50, 1.0); 
            sunMesh.add(lightSprite);

            // Cada sol necesita una luz para iluminar a los planetas a su alrededor
            const sunLight = new THREE.PointLight(0xffffff, 3.0, 0, 0); 
            sunLight.position.copy(position);
            scene.add(sunLight);

            // Se almacena el mesh para acceder a su posición Vector3
            suns.push({ mesh: sunMesh, light: sunLight, mass: SUN_MASS });
            
            // --- NUEVA LÓGICA: CAMBIAR LA CANCIÓN AL CREAR UN NUEVO SOL ---
            if (suns.length > 1 && musicStarted) {
                changeSong();
            }
        }


        /**
         * Crea un campo de estrellas aleatorias para el fondo.
         */
        function createStarField() {
            const starCount = 1500;
            const starGeometry = new THREE.BufferGeometry();
            const positions = [];
            
            const radius = 500; 

            for (let i = 0; i < starCount; i++) {
                const x = THREE.MathUtils.randFloatSpread(radius * 2);
                const y = THREE.MathUtils.randFloatSpread(radius * 2);
                const z = THREE.MathUtils.randFloatSpread(radius * 2);

                positions.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1, 
                sizeAttenuation: true 
            });

            starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }
        
        /**
         * Genera una textura circular suave con degradado para simular un brillo (flare).
         */
        function generateRadialTexture() {
            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');

            const gradient = context.createRadialGradient(
                size / 2, size / 2, 0, 
                size / 2, size / 2, size / 2 
            );
            gradient.addColorStop(0, 'rgba(255,255,255,1)'); 
            gradient.addColorStop(1, 'rgba(255,255,255,0)'); 

            context.fillStyle = gradient;
            context.fillRect(0, 0, size, size);

            return new THREE.CanvasTexture(canvas);
        }

        /**
         * Configura los eventos de mouse y touch para el control de la cámara.
         */
        function setupPointerControls(element) {
            element.addEventListener('pointerdown', onPointerDown, false);
            element.addEventListener('pointermove', onPointerMove, false);
            element.addEventListener('pointerup', onPointerUp, false);
            element.addEventListener('pointerleave', onPointerUp, false);
        }

        /**
         * Evento al pulsar (clic o tocar).
         */
        function onPointerDown(event) {
            if (event.buttons === 1 || event.pointerType === 'touch') { 
                isPointerActive = true; 
                isDragging = false; 
                
                pointerStart.x = event.clientX;
                pointerStart.y = event.clientY;

                previousPointerPosition.x = event.clientX;
                previousPointerPosition.y = event.clientY;
                velocityX = 0;
                velocityY = 0;
            }
        }

        /**
         * Evento al mover el puntero (arrastrar).
         */
        function onPointerMove(event) {
            
            if (!isPointerActive) return; 

            if (!isDragging) {
                const deltaMovementX = event.clientX - pointerStart.x;
                const deltaMovementY = event.clientY - pointerStart.y;
                const distance = Math.sqrt(deltaMovementX * deltaMovementX + deltaMovementY * deltaMovementY); 
                
                if (distance > DRAG_THRESHOLD) {
                    isDragging = true; 
                }
            }

            if (isDragging) { 
                const deltaX = event.clientX - previousPointerPosition.x;
                const deltaY = event.clientY - previousPointerPosition.y;

                theta += deltaX * ROTATION_MULTIPLIER;
                phi -= deltaY * ROTATION_MULTIPLIER;
                
                velocityX = deltaX * ROTATION_MULTIPLIER * 0.5;
                velocityY = deltaY * ROTATION_MULTIPLIER * 0.5;

                previousPointerPosition.x = event.clientX;
                previousPointerPosition.y = event.clientY;
            }
        }

        /**
         * Evento al soltar (dejar de arrastrar o crear entidad).
         */
        function onPointerUp(event) {
            if (isPointerActive && !isDragging) { 
                const entitySelect = document.getElementById('entitySelect');
                const selectedEntity = entitySelect ? entitySelect.value : 'planet';
                
                if (selectedEntity === 'planet') {
                    createPlanet(event);
                } else if (selectedEntity === 'sun') {
                    createSunOnClick(event);
                }
            }
            
            isDragging = false; 
            isPointerActive = false; 
        }

        /**
         * Intenta crear un Sol en la posición del click/toque.
         */
        function createSunOnClick(event) {
            // Mapeo de coordenadas de pantalla a un punto en el espacio 3D
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // Proyectar en el plano Y=0 (el "suelo" de la simulación)
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); 
            const intersection = new THREE.Vector3();
            
            raycaster.ray.intersectPlane(plane, intersection);

            // Limitar la distancia del Sol para evitar que aparezca muy lejos
            if (intersection.length() > MAX_SUN_DISTANCE) {
                intersection.normalize().multiplyScalar(MAX_SUN_DISTANCE);
                showMessage('Sol colocado en el límite de la zona central.', 2000, new THREE.Color(0xfacc15));
            }


            createSunAtPosition(intersection);
            showMessage('¡Nuevo Sol Creado! Ahora afecta la gravedad.', 2000, new THREE.Color(0xfacc15));
        }

        /**
         * Crea un nuevo planeta.
         * @param {PointerEvent} event El evento de puntero (contiene clientX/Y).
         */
        function createPlanet(event) {
            startAudioContext(); 

            if (suns.length === 0) {
                showMessage('No hay soles para orbitar. ¡Crea un Sol primero!', 3000, new THREE.Color(0xef4444));
                return;
            }
            
            // Mapeo de coordenadas de pantalla a un punto en el espacio 3D
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // Proyectar en el plano Y=0 (el "suelo" de la simulación)
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); 
            const intersection = new THREE.Vector3();
            
            raycaster.ray.intersectPlane(plane, intersection);
            const initialPosition = intersection.clone();

            // --- 1. ENCONTRAR EL SOL MÁS CERCANO PARA INICIALIZAR LA ÓRBITA ---
            const nearestSun = findNearestSun(initialPosition);
            
            // Usamos la posición del mesh del sol para la física
            const relativePosition = initialPosition.clone().sub(nearestSun.mesh.position);
            const distance = relativePosition.length();

            // VERIFICACIÓN DE SEGURIDAD CRÍTICA: La distancia NO debe ser 0.
            if (distance < COLLISION_DISTANCE) {
                showMessage('Demasiado cerca del Sol. Intenta más lejos.', 3000, new THREE.Color(0xfacc15));
                return;
            }

            // 2. CÁLCULO DE VELOCIDAD INICIAL (para órbita circular aproximada alrededor del Sol más cercano)
            
            // Magnitud de la velocidad orbital: v = sqrt(G*M/r)
            const orbitVelocityMag = Math.sqrt((GRAVITATIONAL_CONSTANT * SUN_MASS) / distance);
            
            // Dirección de la velocidad: perpendicular al vector posición (para iniciar la órbita)
            const positionUnit = relativePosition.clone().normalize();
            
            // Crea un vector perpendicular para la velocidad inicial (Vector3 perpendicular a positionUnit y Y-axis)
            let initialVelocity = new THREE.Vector3().crossVectors(positionUnit, new THREE.Vector3(0, 1, 0));
            
            // CORRECCIÓN CRÍTICA: Asegurar que el vector de velocidad no sea nulo si el producto cruz falla
            if (initialVelocity.lengthSq() < 0.001) {
                // Si falla (ej. el planeta está exactamente en el eje Y), usa una dirección arbitraria perpendicular (Eje X)
                 initialVelocity.set(1, 0, 0); 
            }
            
            // Velocidad inicial ajustada (0.99 a 1.01) para asegurar una órbita estable
            initialVelocity.normalize().multiplyScalar(orbitVelocityMag * THREE.MathUtils.randFloat(0.99, 1.01));

            // Añadir una pequeña componente Y para dar una inclinación 3D inicial
            initialVelocity.y = THREE.MathUtils.randFloatSpread(orbitVelocityMag * 0.1); 

            // 3. GENERAR EL RESTO DE PROPIEDADES
            const radius = THREE.MathUtils.randFloat(1, 4); 
            
            const baseColor = new THREE.Color(Math.random(), Math.random(), Math.random());
            const hsl = {};
            baseColor.getHSL(hsl);
            hsl.l = THREE.MathUtils.randFloat(0.7, 0.9);
            hsl.s = THREE.MathUtils.randFloat(0.4, 0.8); 
            const brightColor = new THREE.Color().setHSL(hsl.h, hsl.s, hsl.l);


            // 4. Configuración de AUDIO (Solo asignación de capa)
            
            // Asignación de Capa (El instrumento al que se asigna este planeta)
            // Asigna la siguiente capa del MIDI que no tenga un planeta activo
            const activeLayersCount = planets.filter(p => p.assignedLayer).length;
            const layerIndex = activeLayersCount % INSTRUMENT_LAYERS.length;
            const assignedLayer = INSTRUMENT_LAYERS[layerIndex];
            
            // Crear un objeto dummy para audio
            const { synth, panner } = createSynth(); 
            
            // 5. Malla y Rastro (similar al código anterior)
            const planetGeometry = new THREE.SphereGeometry(radius, 32, 32);
            const planetMaterial = new THREE.MeshLambertMaterial({ 
                color: brightColor, 
                emissive: brightColor.clone().multiplyScalar(0.1) 
            });
            const planetMesh = new THREE.Mesh(planetGeometry, planetMaterial);
            planetMesh.position.copy(initialPosition);

            const orbitPositions = new Float32Array(TRAIL_LENGTH * 3); 
            const drawingPositions = new Float32Array(TRAIL_LENGTH * 3);
            
            // Creación del Array de Colores (RGBA: 4 componentes por punto)
            const trailColors = new Float32Array(TRAIL_LENGTH * 4); 

            const trailGeometry = new THREE.BufferGeometry();
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(drawingPositions, 3)); 
            trailGeometry.setAttribute('color', new THREE.BufferAttribute(trailColors, 4)); // Añadir atributo de color/opacidad
            
            const trailMaterial = new THREE.LineBasicMaterial({
                color: brightColor, 
                transparent: true,
                opacity: 1.0,
                vertexColors: true // Usar colores definidos por el vértice
            });
            const orbitTrail = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(orbitTrail);

            // 6. Crear Objeto para el planeta (PROPIEDADES DE FÍSICA Y AUDIO)
            const planetObject = {
                mesh: planetMesh,
                trail: orbitTrail,
                orbitPositions: orbitPositions, 
                trailColors: trailColors, // Almacenar el array de colores
                planetColor: brightColor, // Color base del planeta
                trailIndex: 0,
                trailLength: TRAIL_LENGTH,
                trailCount: 0,
                // PROPIEDADES DE FÍSICA
                mass: PLANET_MASS,
                velocity: initialVelocity, // Vector3
                acceleration: new THREE.Vector3(0, 0, 0), // Vector3
                // PROPIEDADES DE AUDIO
                synth: synth,
                panner: panner, // Nuevo panner
                assignedLayer: assignedLayer, // Capa de la canción asignada (Ej: 'Cancion1_1')
                // PROPIEDADES DE TRIVIA
                id: planets.length + 1, // Asignar un ID para identificarlo en la trivia
                pulseTypeName: `Pista: ${assignedLayer}` // Nombre legible
            };

            scene.add(planetMesh);
            planets.push(planetObject);
            
            // --- ACTUALIZACIÓN DE VOLUMENES (Lógica visual de estado) ---
            updateAudioVolumes();
            // ---------------------------------------------
            
            // CAMBIO AQUÍ: Simplificamos el mensaje
            showMessage('¡Planeta Creado!', 1500, brightColor);
        }

        /**
         * Alterna el estado de pausa de la simulación y la música.
         */
        function togglePause() {
            isPaused = !isPaused;
            const button = document.getElementById('pauseButton');
            
            if (isPaused) {
                button.textContent = 'Reanudar Simulación';
                button.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                button.classList.add('bg-green-600', 'hover:bg-green-700');
                showMessage('Simulación PAUSADA.', 1500, new THREE.Color(0xfb923c));
                // Lógica para pausar el audio (si estuviera activo)
                if (musicStarted) { Tone.Transport.pause(); }
            } else {
                button.textContent = 'Pausar Simulación';
                button.classList.remove('bg-green-600', 'hover:bg-green-700');
                button.classList.add('bg-blue-600', 'hover:bg-blue-700');
                showMessage('Simulación REANUDADA.', 1500, new THREE.Color(0x22c55e));
                // Lógica para reanudar el audio (si estuviera activo)
                if (musicStarted) { Tone.Transport.start(); }
            }
        }

        /**
         * Elimina todos los planetas, soles, sus rastros y sus sintetizadores.
         */
        function clearSimulation() {
            const initialSuns = suns.length;
            
            // Limpieza de estados
            musicStarted = false;
            currentSongIndex = 0;
            INSTRUMENT_LAYERS = SONG_DATA_STRUCTURES[0].layers;
            
            // Detener el audio
            Tone.Transport.stop();
            Tone.Transport.cancel();
            Tone.Master.mute = true;


            // Limpieza de Planetas
            planets.forEach(planet => {
                scene.remove(planet.mesh);
                scene.remove(planet.trail);
            });
            planets.length = 0;

            // Limpieza de Soles
            suns.forEach(sun => {
                scene.remove(sun.mesh);
                scene.remove(sun.light);
            });
            suns.length = 0;
            
            // Vuelve a crear el sol inicial
            if (initialSuns === 0) {
                 createInitialSun(); 
            } else {
                // Si el audio estaba cargado, recargar la canción inicial
                if (isAudioContextStarted && currentMidiData) {
                    loadMidiAndSetup(0); // Recargar la primera canción
                }
            }
            
            showMessage('Simulación Reiniciada. ¡Crea nuevos sistemas!', 2500, new THREE.Color(0xef4444));
        }

        /**
         * Maneja el redimensionamiento de la ventana para mantener la vista correcta.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // =================================================================
        // LÓGICA MIDI REAL
        // =================================================================

        /**
         * Inicializa los Samplers de Tone.js (instrumentos reales).
         */
        async function setupMidiPlayers() {
            // Un mapa simple de Instrumentos General MIDI (GM) a sonidos de Sampler
            const GM_INSTRUMENT_MAP = {
                'piano': 'piano', 'bass': 'bass-electric', 'drums': 'drums', 'brass': 'trumpet', 
                'synth': 'synth_lead', 'strings': 'violin', 'guitar': 'guitar-acoustic'
            };
            
            const samplerPromises = [];
            
            // Solo necesitamos 10 Samplers, uno por cada posible pista activa
            for (let i = 0; i < TRACKS_PER_SONG; i++) {
                // Usamos una clave genérica para los Samplers (siempre se cargará piano por estabilidad)
                const sampler = new Tone.Sampler({
                    urls: { "C4": `piano-c4.mp3` }, 
                    baseUrl: "https://tonejs.github.io/audio/salamander/", 
                    onload: () => {
                        sampler.volume.value = -100; // Silenciado por defecto
                        sampler.toDestination();
                    },
                    onerror: (e) => {
                        console.error(`Error al cargar sampler:`, e);
                    }
                }).toDestination();
                
                midiPlayers.push(sampler);
                samplerPromises.push(new Promise(resolve => sampler.onload = resolve));
            }
            
            await Promise.all(samplerPromises);
            
            // Una vez cargados los 10 Samplers, procedemos a cargar la primera canción MIDI
            await loadMidiAndSetup(currentSongIndex);
        }
        
        /**
         * Inicia el secuenciador de Tone.js con los datos MIDI.
         */
        function startSequencer(midiArray) {
            Tone.Transport.cancel();
            
            // Usamos el BPM del primer archivo MIDI
            Tone.Transport.bpm.value = midiArray[0].header.tempos[0].bpm || 128; 

            midiArray.slice(0, TRACKS_PER_SONG).forEach((midi, i) => {
                const track = midi.tracks.length > 0 ? midi.tracks[0] : null; 
                if (!track) return;

                const notes = track.notes;
                const player = midiPlayers[i];

                const part = new Tone.Part((time, note) => {
                    // Solo reproducimos si la capa está activa (activada por un planeta)
                    if (activePatterns[INSTRUMENT_LAYERS[i]]) {
                        player.triggerAttackRelease(
                            note.name, 
                            note.duration, 
                            time, 
                            note.velocity
                        );

                        // Visualización rítmica (parpadeo del planeta)
                        Tone.Draw.schedule(() => {
                            activeNotes[INSTRUMENT_LAYERS[i]] = true;
                            setTimeout(() => activeNotes[INSTRUMENT_LAYERS[i]] = false, Tone.Time(note.duration).toMilliseconds() * 0.5);
                        }, time);
                    }
                }, notes).start(0);

                part.loop = true;
                part.loopEnd = midi.duration || "4m";
            });

            // Usamos la duración del primer MIDI como duración del loop principal
            Tone.Transport.loop = true;
            Tone.Transport.loopEnd = midiArray[0].duration || "4m";
            
            Tone.Transport.start();
            showMessage(`¡Música ${SONG_DATA_STRUCTURES[currentSongIndex].name} lista! Crea tu primer planeta.`, 2000, new THREE.Color(0x22c55e));
        }

        /**
         * Carga el archivo MIDI de forma asíncrona.
         */
        async function loadMidiAndSetup(songIndex) {
             showMessage(`Cargando partitura MIDI para ${SONG_DATA_STRUCTURES[songIndex].name}...`, 3000, new THREE.Color(0xfacc15));
             
             // 1. Crear 10 promesas de carga para las 10 pistas
             const midiPromises = [];
             for(let i = 0; i < TRACKS_PER_SONG; i++) {
                 const MIDI_PATH = getTrackPath(songIndex, i); 
                 
                 // Usamos fetch para asegurar que el navegador pueda acceder al archivo
                 const loadPromise = fetch(MIDI_PATH)
                     .then(response => {
                         if (!response.ok) {
                             // Si no se encuentra el archivo (Error 404), no lanzamos error fatal, devolvemos un MIDI vacío
                             console.warn(`Advertencia: Pista ${i + 1} (${MIDI_PATH}) no encontrada. La pista estará en silencio.`);
                             return { tracks: [], duration: 0, header: { tempos: [{ bpm: 128 }] } };
                         }
                         return response.arrayBuffer();
                     })
                     .then(arrayBuffer => Midi.fromBuffer(arrayBuffer))
                     .catch(e => {
                         console.error(`Fallo al procesar Pista ${i + 1}:`, e);
                         // Devolver un objeto MIDI vacío si hay un fallo en el procesamiento
                         return { tracks: [], duration: 0, header: { tempos: [{ bpm: 128 }] } }; 
                     });
                 
                 midiPromises.push(loadPromise);
             }
            
            // 2. Esperar a que todos los archivos MIDI carguen
            const loadedMidis = await Promise.all(midiPromises);
            
            // 3. Almacenar y comenzar la secuencia
            currentMidiData = loadedMidis; 
            
            // 4. Iniciar el secuenciador con el array de midis
            startSequencer(loadedMidis);
        }

        /**
         * Función dummy para mantener la estructura de planet.synth (ahora solo mute/unmute)
         */
        function createSynth() {
            return { synth: null, panner: null }; 
        }

        /**
         * Inicia el contexto de audio y la carga del MIDI.
         */
        function startAudioContext() {
            if (!isAudioContextStarted) {
                // Iniciar el Contexto de Audio con interacción del usuario
                Tone.start(); 
                isAudioContextStarted = true;
                
                // Iniciar la carga de Samplers y MIDI
                setupMidiPlayers();
            }
        }
        
        /**
         * Función que cambia la canción al crear un nuevo Sol.
         */
        function changeSong() {
            // Ciclo a la siguiente canción
            currentSongIndex = (currentSongIndex + 1) % TOTAL_SONGS; 
            
            // 1. Limpiar patrones visuales
            activePatterns = {};
            planets.forEach(p => p.assignedLayer = INSTRUMENT_LAYERS[0]);
            
            // 2. Actualizar las capas de instrumento disponibles (para la UI)
            INSTRUMENT_LAYERS = SONG_DATA_STRUCTURES[currentSongIndex].layers;

            // 3. Cargar la nueva canción MIDI
            // NOTA: No esperamos aquí, el resto de la app es asíncrona.
            loadMidiAndSetup(currentSongIndex); 
            
            // 4. Actualizar volumen (silenciar capas)
            updateAudioVolumes();
            
            showMessage(`Música cambiada a: ${SONG_DATA_STRUCTURES[currentSongIndex].name}`, 2000, new THREE.Color(0xfacc15));
        }
        
        /**
         * Controla qué patrones rítmicos están activos (solo lógica, sin audio).
         */
        function updateAudioVolumes() {
            // 1. Mapear qué capas están activas visualmente (para el MIDI)
            INSTRUMENT_LAYERS.forEach(layer => activePatterns[layer] = false);
            
            planets.forEach((planet, index) => {
                const layerIndex = index % TRACKS_PER_SONG;
                const layerName = INSTRUMENT_LAYERS[layerIndex];
                
                planet.assignedLayer = layerName;
                activePatterns[layerName] = true;
                
                // Controlar el volumen real del sampler (si existe)
                if (midiPlayers[layerIndex]) {
                    midiPlayers[layerIndex].volume.value = 0; // Activar (0dB)
                }
            });
            
            // Silenciar las capas sin planeta
            for (let i = planets.length; i < TRACKS_PER_SONG; i++) {
                 if (midiPlayers[i]) {
                    midiPlayers[i].volume.value = -100; // Silenciar
                 }
            }


            // 3. Controlar el estado general 
            if (planets.length > 0 && !musicStarted) {
                musicStarted = true;
                Tone.Master.mute = false; // Desmutear la música
            } else if (planets.length === 0 && musicStarted) {
                musicStarted = false;
                Tone.Master.mute = true; // Mutear todo
            }
        }


        // =================================================================
        // FUNCIONES DE FÍSICA
        // =================================================================

        /**
         * Calcula la aceleración gravitacional neta sobre el planeta causada por todos los soles.
         * F = G * M1 * M2 / r^2
         * A = F / M2 = G * M1 / r^2
         * @param {object} planet El objeto planeta con posición, masa y aceleración.
         */
        function calculateGravity(planet) {
            const netAcceleration = new THREE.Vector3(0, 0, 0);

            suns.forEach(sun => {
                // Vector que apunta del planeta al sol
                const direction = tempVector.copy(sun.mesh.position).sub(planet.mesh.position);
                const distanceSq = direction.lengthSq();

                // Evitar división por cero o fuerzas infinitas en colisión cercana
                if (distanceSq < 1) { 
                    return;
                }
                
                const distance = Math.sqrt(distanceSq);

                // Fuerza gravitacional: A = (G * M_sol / r^2) * (vector unitario)
                const magnitude = (GRAVITATIONAL_CONSTANT * SUN_MASS) / distanceSq;

                // Asegurar que la fuerza no sea demasiado grande a corta distancia
                const maxMagnitude = 5.0; // Límite de aceleración para estabilidad
                const finalMagnitude = Math.min(magnitude, maxMagnitude);

                direction.normalize().multiplyScalar(finalMagnitude);
                
                netAcceleration.add(direction);
            });

            planet.acceleration = netAcceleration;
        }

        /**
         * Aplica la integración de Euler para actualizar la velocidad y posición.
         * @param {object} planet El objeto planeta.
         * @param {number} deltaTime El paso de tiempo.
         */
        function updatePhysics(planet, deltaTime) {
            // Velocidad = Velocidad + Aceleración * dt
            planet.velocity.add(planet.acceleration.clone().multiplyScalar(deltaTime));
            
            // Posición = Posición + Velocidad * dt
            planet.mesh.position.add(planet.velocity.clone().multiplyScalar(deltaTime));
        }

        /**
         * Encuentra el Sol más cercano al punto de click.
         * @param {THREE.Vector3} clickPosition Posición 3D del click.
         * @returns {object} El objeto Sol más cercano.
         */
        function findNearestSun(clickPosition) {
            let minDistanceSq = Infinity;
            let nearestSun = null;
            
            suns.forEach(sun => {
                // Usamos subVectors y lengthSq para calcular la distancia.
                const diffVector = new THREE.Vector3().subVectors(sun.mesh.position, clickPosition);
                const distanceSq = diffVector.lengthSq(); 
                
                if (distanceSq < minDistanceSq) {
                    minDistanceSq = distanceSq;
                    nearestSun = sun;
                }
            });

            return nearestSun;
        }

        // =================================================================
        // UTILIDADES
        // =================================================================

        /**
         * Inicializa la escena, cámara, renderizador y luces.
         */
        function init() {
            // 1. Configuración de la Escena
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0d0d1a, 0.003); 

            // 2. Configuración de la Cámara (perspectiva para 3D)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, ORBIT_RADIUS); // Posición inicial aumentada a 250
            
            // 3. Configuración del Renderizador (WebGL)
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1);
            // Añadir una clase para apuntar con CSS si queremos aumentar el grosor de línea
            renderer.domElement.classList.add('webgl-canvas'); 
            
            // ** CORRECCIÓN: Asegurar que el canvas se adjunta al DOM **
            const container = document.getElementById('container');
            if (container) {
                 container.appendChild(renderer.domElement);
            } else {
                 console.error("Error crítico: El contenedor #container no se encontró.");
            }
            // ********************************************************
            
            // 4. Configuración de la Iluminación
            ambientLight = new THREE.AmbientLight(0x404040, 0.5); 
            scene.add(ambientLight);

            // 5. Crear el Sol Central Inicial y el Fondo de Estrellas
            createInitialSun(); 
            createStarField(); 
            
            // 6. Manejadores de Eventos
            window.addEventListener('resize', onWindowResize, false);
            setupPointerControls(renderer.domElement);
        }

        /**
         * Crea el primer Sol al iniciar la simulación.
         */
        function createInitialSun() {
            // Sol inicial ligeramente desplazado para evitar la singularidad de la órbita inicial
            const center = new THREE.Vector3(5, 0, 0); 
            createSunAtPosition(center);
        }

        /**
         * Crea un objeto Sol y lo añade a la escena y al array de Soles.
         * @param {THREE.Vector3} position Posición del nuevo sol.
         */
        function createSunAtPosition(position) {
            const sunRadius = 12;
            const sunGeometry = new THREE.SphereGeometry(sunRadius, 32, 32); 
            const sunMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff, 
                emissive: 0xff8800 
            }); 
            const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            sunMesh.position.copy(position);
            scene.add(sunMesh);
            
            const flareTexture = generateRadialTexture(); 

            const lightSprite = new THREE.Sprite(new THREE.SpriteMaterial({
                map: flareTexture,
                color: 0xff8800, 
                blending: THREE.AdditiveBlending, 
                transparent: true,
                opacity: 0.7 
            }));
            lightSprite.scale.set(50, 50, 1.0); 
            sunMesh.add(lightSprite);

            // Cada sol necesita una luz para iluminar a los planetas a su alrededor
            const sunLight = new THREE.PointLight(0xffffff, 3.0, 0, 0); 
            sunLight.position.copy(position);
            scene.add(sunLight);

            // Se almacena el mesh para acceder a su posición Vector3
            suns.push({ mesh: sunMesh, light: sunLight, mass: SUN_MASS });
            
            // --- NUEVA LÓGICA: CAMBIAR LA CANCIÓN AL CREAR UN NUEVO SOL ---
            if (suns.length > 1 && musicStarted) {
                changeSong();
            }
        }


        /**
         * Crea un campo de estrellas aleatorias para el fondo.
         */
        function createStarField() {
            const starCount = 1500;
            const starGeometry = new THREE.BufferGeometry();
            const positions = [];
            
            const radius = 500; 

            for (let i = 0; i < starCount; i++) {
                const x = THREE.MathUtils.randFloatSpread(radius * 2);
                const y = THREE.MathUtils.randFloatSpread(radius * 2);
                const z = THREE.MathUtils.randFloatSpread(radius * 2);

                positions.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1, 
                sizeAttenuation: true 
            });

            starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }
        
        /**
         * Genera una textura circular suave con degradado para simular un brillo (flare).
         */
        function generateRadialTexture() {
            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');

            const gradient = context.createRadialGradient(
                size / 2, size / 2, 0, 
                size / 2, size / 2, size / 2 
            );
            gradient.addColorStop(0, 'rgba(255,255,255,1)'); 
            gradient.addColorStop(1, 'rgba(255,255,255,0)'); 

            context.fillStyle = gradient;
            context.fillRect(0, 0, size, size);

            return new THREE.CanvasTexture(canvas);
        }

        /**
         * Configura los eventos de mouse y touch para el control de la cámara.
         */
        function setupPointerControls(element) {
            element.addEventListener('pointerdown', onPointerDown, false);
            element.addEventListener('pointermove', onPointerMove, false);
            element.addEventListener('pointerup', onPointerUp, false);
            element.addEventListener('pointerleave', onPointerUp, false);
        }

        /**
         * Evento al pulsar (clic o tocar).
         */
        function onPointerDown(event) {
            if (event.buttons === 1 || event.pointerType === 'touch') { 
                isPointerActive = true; 
                isDragging = false; 
                
                pointerStart.x = event.clientX;
                pointerStart.y = event.clientY;

                previousPointerPosition.x = event.clientX;
                previousPointerPosition.y = event.clientY;
                velocityX = 0;
                velocityY = 0;
            }
        }

        /**
         * Evento al mover el puntero (arrastrar).
         */
        function onPointerMove(event) {
            
            if (!isPointerActive) return; 

            if (!isDragging) {
                const deltaMovementX = event.clientX - pointerStart.x;
                const deltaMovementY = event.clientY - pointerStart.y;
                const distance = Math.sqrt(deltaMovementX * deltaMovementX + deltaMovementY * deltaMovementY); 
                
                if (distance > DRAG_THRESHOLD) {
                    isDragging = true; 
                }
            }

            if (isDragging) { 
                const deltaX = event.clientX - previousPointerPosition.x;
                const deltaY = event.clientY - previousPointerPosition.y;

                theta += deltaX * ROTATION_MULTIPLIER;
                phi -= deltaY * ROTATION_MULTIPLIER;
                
                velocityX = deltaX * ROTATION_MULTIPLIER * 0.5;
                velocityY = deltaY * ROTATION_MULTIPLIER * 0.5;

                previousPointerPosition.x = event.clientX;
                previousPointerPosition.y = event.clientY;
            }
        }

        /**
         * Evento al soltar (dejar de arrastrar o crear entidad).
         */
        function onPointerUp(event) {
            if (isPointerActive && !isDragging) { 
                const entitySelect = document.getElementById('entitySelect');
                const selectedEntity = entitySelect ? entitySelect.value : 'planet';
                
                if (selectedEntity === 'planet') {
                    createPlanet(event);
                } else if (selectedEntity === 'sun') {
                    createSunOnClick(event);
                }
            }
            
            isDragging = false; 
            isPointerActive = false; 
        }

        /**
         * Intenta crear un Sol en la posición del click/toque.
         */
        function createSunOnClick(event) {
            // Mapeo de coordenadas de pantalla a un punto en el espacio 3D
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // Proyectar en el plano Y=0 (el "suelo" de la simulación)
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); 
            const intersection = new THREE.Vector3();
            
            raycaster.ray.intersectPlane(plane, intersection);

            // Limitar la distancia del Sol para evitar que aparezca muy lejos
            if (intersection.length() > MAX_SUN_DISTANCE) {
                intersection.normalize().multiplyScalar(MAX_SUN_DISTANCE);
                showMessage('Sol colocado en el límite de la zona central.', 2000, new THREE.Color(0xfacc15));
            }


            createSunAtPosition(intersection);
            showMessage('¡Nuevo Sol Creado! Ahora afecta la gravedad.', 2000, new THREE.Color(0xfacc15));
        }

        /**
         * Crea un nuevo planeta.
         * @param {PointerEvent} event El evento de puntero (contiene clientX/Y).
         */
        function createPlanet(event) {
            startAudioContext(); 

            if (suns.length === 0) {
                showMessage('No hay soles para orbitar. ¡Crea un Sol primero!', 3000, new THREE.Color(0xef4444));
                return;
            }
            
            // Mapeo de coordenadas de pantalla a un punto en el espacio 3D
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // Proyectar en el plano Y=0 (el "suelo" de la simulación)
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); 
            const intersection = new THREE.Vector3();
            
            raycaster.ray.intersectPlane(plane, intersection);
            const initialPosition = intersection.clone();

            // --- 1. ENCONTRAR EL SOL MÁS CERCANO PARA INICIALIZAR LA ÓRBITA ---
            const nearestSun = findNearestSun(initialPosition);
            
            // Usamos la posición del mesh del sol para la física
            const relativePosition = initialPosition.clone().sub(nearestSun.mesh.position);
            const distance = relativePosition.length();

            // VERIFICACIÓN DE SEGURIDAD CRÍTICA: La distancia NO debe ser 0.
            if (distance < COLLISION_DISTANCE) {
                showMessage('Demasiado cerca del Sol. Intenta más lejos.', 3000, new THREE.Color(0xfacc15));
                return;
            }

            // 2. CÁLCULO DE VELOCIDAD INICIAL (para órbita circular aproximada alrededor del Sol más cercano)
            
            // Magnitud de la velocidad orbital: v = sqrt(G*M/r)
            const orbitVelocityMag = Math.sqrt((GRAVITATIONAL_CONSTANT * SUN_MASS) / distance);
            
            // Dirección de la velocidad: perpendicular al vector posición (para iniciar la órbita)
            const positionUnit = relativePosition.clone().normalize();
            
            // Crea un vector perpendicular para la velocidad inicial (Vector3 perpendicular a positionUnit y Y-axis)
            let initialVelocity = new THREE.Vector3().crossVectors(positionUnit, new THREE.Vector3(0, 1, 0));
            
            // CORRECCIÓN CRÍTICA: Asegurar que el vector de velocidad no sea nulo si el producto cruz falla
            if (initialVelocity.lengthSq() < 0.001) {
                // Si falla (ej. el planeta está exactamente en el eje Y), usa una dirección arbitraria perpendicular (Eje X)
                 initialVelocity.set(1, 0, 0); 
            }
            
            // Velocidad inicial ajustada (0.99 a 1.01) para asegurar una órbita estable
            initialVelocity.normalize().multiplyScalar(orbitVelocityMag * THREE.MathUtils.randFloat(0.99, 1.01));

            // Añadir una pequeña componente Y para dar una inclinación 3D inicial
            initialVelocity.y = THREE.MathUtils.randFloatSpread(orbitVelocityMag * 0.1); 

            // 3. GENERAR EL RESTO DE PROPIEDADES
            const radius = THREE.MathUtils.randFloat(1, 4); 
            
            const baseColor = new THREE.Color(Math.random(), Math.random(), Math.random());
            const hsl = {};
            baseColor.getHSL(hsl);
            hsl.l = THREE.MathUtils.randFloat(0.7, 0.9);
            hsl.s = THREE.MathUtils.randFloat(0.4, 0.8); 
            const brightColor = new THREE.Color().setHSL(hsl.h, hsl.s, hsl.l);


            // 4. Configuración de AUDIO (Solo asignación de capa)
            
            // Asignación de Capa (El instrumento al que se asigna este planeta)
            // Asigna la siguiente capa del MIDI que no tenga un planeta activo
            const activeLayersCount = planets.filter(p => p.assignedLayer).length;
            const layerIndex = activeLayersCount % INSTRUMENT_LAYERS.length;
            const assignedLayer = INSTRUMENT_LAYERS[layerIndex];
            
            // Crear un objeto dummy para audio
            const { synth, panner } = createSynth(); 
            
            // 5. Malla y Rastro (similar al código anterior)
            const planetGeometry = new THREE.SphereGeometry(radius, 32, 32);
            const planetMaterial = new THREE.MeshLambertMaterial({ 
                color: brightColor, 
                emissive: brightColor.clone().multiplyScalar(0.1) 
            });
            const planetMesh = new THREE.Mesh(planetGeometry, planetMaterial);
            planetMesh.position.copy(initialPosition);

            const orbitPositions = new Float32Array(TRAIL_LENGTH * 3); 
            const drawingPositions = new Float
