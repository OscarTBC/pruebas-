<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Armonía de las Esferas: Simulación de Órbitas y Trivia (Móvil)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Configuración de Tailwind para incluir colores personalizados (Restaurado)
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'space-dark': '#0d0d1a',
                        'space-blue': '#1a202c',
                        'brand-orange': '#f75b0f', 
                        'trivia-teal': '#00c7b5',
                    },
                    keyframes: {
                        fadeInUp: {
                            '0%': { opacity: '0', transform: 'translateY(10px)' },
                            '100%': { opacity: '1', transform: 'translateY(0)' },
                        }
                    },
                    animation: {
                        fadeInUp: 'fadeInUp 0.5s ease-out forwards',
                    }
                }
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <style>
        /* Estilos base ajustados para usar los colores de Tailwind */
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #0d0d1a; /* space-dark */
            color: white; 
        }
        #webgl-output { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        .interactive-overlay { pointer-events: auto; }
        .hover-scale { transition: transform 0.1s; }
        .hover-scale:hover { transform: scale(1.05); }

        /* Estilos específicos para la interfaz */
        .sidebar { 
            background-color: rgba(26, 32, 44, 0.9); /* space-blue con opacidad */
            backdrop-filter: blur(5px); 
            width: 10rem;
            right: 0.5rem; 
            top: 5rem;
            max-height: calc(100% - 6rem);
            transition: transform 0.3s ease-out;
        }
        .modal { background-color: rgba(0, 0, 0, 0.9); backdrop-filter: blur(5px); }
        .draggable-planet { cursor: grab; }

        /* Clases para la trivia */
        .correct-answer { border: 2px solid #10b981; }
        .wrong-answer { border: 2px solid #ef4444; }

        /* Tooltip para información del planeta - Fijo en la parte inferior para mejor uso en móvil */
        #infoTooltip {
            position: fixed;
            bottom: 0; 
            left: 0;
            right: 0;
            background-color: #f75b0f; /* brand-orange */
            color: white;
            padding: 12px;
            box-shadow: 0 -4px 6px rgba(0, 0, 0, 0.1);
            pointer-events: none;
            z-index: 20;
            opacity: 0;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            transform: translateY(100%);
        }
        #infoTooltip.active {
            opacity: 1;
            transform: translateY(0);
        }

        /* Ajustes de control para pantallas pequeñas */
        #actionButtons {
            position: fixed;
            top: 0.5rem;
            left: 0.5rem;
        }

        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; }
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; }
    </style>
</head>
<body>
    <div id="webgl-output"></div>
    
    <div id="infoTooltip" class="text-sm">
        <button id="closeTooltip" class="absolute top-1 right-3 text-xl font-bold text-white pointer-events-auto">×</button>
        <div id="tooltipContent"></div>
    </div>

    <div id="loadingScreen" class="overlay flex flex-col items-center justify-center bg-space-dark transition-opacity duration-500 z-50 interactive-overlay">
        <h1 class="text-4xl md:text-6xl text-white mb-8 font-extrabold">ARMÓNIA DE LAS ESFERAS</h1>
        <button id="startButton" class="px-8 py-4 bg-brand-orange text-white text-xl font-bold rounded-lg hover:bg-orange-700 transition duration-300 transform hover-scale">
            Iniciar Simulación
        </button>
    </div>

    <div id="mainInterface" class="overlay interactive-overlay p-4 hidden">

        <div id="actionButtons" class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-4">
            <button id="clearButton" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition duration-300 transform hover-scale text-sm sm:text-base sm:order-1">
                Reiniciar Sim.
            </button>
            
            <button id="triviaButton" class="px-4 py-2 bg-trivia-teal text-white rounded-lg hover:bg-teal-600 transition duration-300 transform hover-scale text-sm sm:text-base sm:order-4">
                Trivia
            </button>
        </div>
        
        <div id="planetCatalog" class="sidebar p-4 rounded-xl shadow-2xl absolute max-h-4/5 overflow-y-auto interactive-overlay pt-4">
            <h2 class="text-xl font-bold text-white mb-2">CATÁLOGO</h2>
            <p class="text-xs text-gray-400 mt-4">Arrastra órbita.</p> 

            <hr class="my-4 border-gray-700">

            <div id="celestialBodiesList" class="space-y-4">
                
                <div id="body-slow-low" class="draggable-planet bg-gray-700 p-2 rounded-lg flex flex-col items-center text-center shadow-md hover:bg-gray-600 hover-scale" data-type="slow-low">
                    <div class="w-6 h-6 rounded-full bg-red-500 mb-1"></div>
                    <p class="text-white text-xs font-semibold">Tipo I (Rojo)</p>
                    <p class="text-xs text-gray-400">Masa Alta</p>
                </div>

                <div id="body-medium-rhythm" class="draggable-planet bg-gray-700 p-2 rounded-lg flex flex-col items-center text-center shadow-md hover:bg-gray-600 hover-scale" data-type="medium-rhythm">
                    <div class="w-6 h-6 rounded-full bg-yellow-500 mb-1"></div>
                    <p class="text-white text-xs font-semibold">Tipo II (Amarillo)</p>
                    <p class="text-xs text-gray-400">Masa Media</p>
                </div>

                <div id="body-fast-high" class="draggable-planet bg-gray-700 p-2 rounded-lg flex flex-col items-center text-center shadow-md hover:bg-gray-600 hover-scale" data-type="fast-high">
                    <div class="w-6 h-6 rounded-full bg-blue-500 mb-1"></div>
                    <p class="text-white text-xs font-semibold">Tipo III (Azul)</p>
                    <p class="text-xs text-gray-400">Masa Baja</p>
                </div>
            </div>
            <hr class="my-4 border-gray-700">
        </div>

        <div id="triviaModal" class="modal fixed inset-0 flex items-center justify-center p-4 hidden">
            <div class="bg-gray-900 p-8 rounded-xl shadow-2xl max-w-lg w-full text-white interactive-overlay">
                <h2 id="triviaTitle" class="text-2xl font-bold mb-4 text-trivia-teal">Trivia del Sistema Solar</h2>
                <div id="triviaContent">
                    <p id="triviaQuestion" class="text-lg mb-6"></p>
                    <div id="triviaOptions" class="space-y-4">
                        </div>
                </div>
                <button id="nextQuestionButton" class="mt-6 px-6 py-2 bg-trivia-teal text-white rounded-lg hover:bg-teal-600 transition duration-300 transform hover-scale hidden">
                    Siguiente Pregunta
                </button>
                <button id="closeTriviaButton" class="mt-6 px-6 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition duration-300 transform hover-scale">
                    Cerrar
                </button>
            </div>
        </div>

        <div id="welcomeModal" class="modal fixed inset-0 flex items-center justify-center p-4">
            <div class="bg-gray-900 p-10 rounded-xl shadow-2xl max-w-xl w-full text-white text-center interactive-overlay">
                <img src="./armonia-orbital.png" alt="Símbolo de Armonía Orbital" class="w-24 h-auto mx-auto mb-6">
                <h2 class="text-3xl font-bold mb-4 text-brand-orange">Armonía de las Esferas</h2>
                <p class="text-lg mb-6 text-gray-300">
                    Arrastra los cuerpos celestes desde el catálogo lateral para crear órbitas. 
                    Experimenta la física gravitacional en un entorno 3D.
                </p>
                <button id="closeWelcomeButton" class="px-8 py-3 bg-brand-orange text-white text-lg font-bold rounded-lg hover:bg-orange-700 transition duration-300 transform hover-scale">
                    ¡Comenzar!
                </button>
            </div>
        </div>
    </div>


    <script>
        // ==========================================================================================
        // CONFIGURACIÓN DE LA SIMULACIÓN
        // ==========================================================================================
        let scene, camera, renderer, controls;
        let ambientLight, directionalLight;
        let raycaster, mouse;

        const SUN_MASS = 1000;
        const G = 0.01;
        const SCALE_FACTOR = 0.5;
        const TIME_STEP = 0.1;
        const MAX_ORBITS = 8;
        const INFO_TOOLTIP = document.getElementById('infoTooltip'); 
        const TOOLTIP_CONTENT = document.getElementById('tooltipContent');

        let orbitingBodies = [];
        let isDragging = false;
        let initialClickPoint = new THREE.Vector3();
        let currentDragLine = null;
        let isSimulationRunning = false;
        let animationFrameId = null;
        let lastIntersectedObject = null;

        // Estructura de un cuerpo celeste
        class CelestialBody {
            constructor(mass, type, mesh, position, initialVelocity, color, info) {
                this.mass = mass;
                this.type = type;
                this.mesh = mesh;
                this.mesh.position.copy(position);
                this.velocity = initialVelocity;
                this.color = color;
                this.trail = null;
                this.trailGeometry = null;
                this.trailMaterial = null;
                this.trailLength = 50; 
                this.trailIndex = 0;
                this.orbitPositions = new Array(this.trailLength).fill(new THREE.Vector3()); 
                this.isOrbiting = true;
                this.info = info; 

                this.initTrail();
            }

            initTrail() {
                this.trailGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(this.trailLength * 3); 
                this.trailGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                this.trailMaterial = new THREE.LineBasicMaterial({ color: this.color, linewidth: 2 });
                this.trail = new THREE.Line(this.trailGeometry, this.trailMaterial);
                this.trail.frustumCulled = false;
                scene.add(this.trail);
            }

            update(deltaTime) {
                if (!this.isOrbiting) return;

                const position = this.mesh.position;
                const distanceSq = position.lengthSq();
                const distance = Math.sqrt(distanceSq);

                if (distance < 1.0) { 
                    this.isOrbiting = false; 
                    return; 
                }

                const forceMagnitude = (G * SUN_MASS * this.mass) / distanceSq;
                const direction = position.clone().negate().normalize();
                const acceleration = direction.multiplyScalar(forceMagnitude / this.mass);

                this.velocity.add(acceleration.multiplyScalar(deltaTime));
                this.mesh.position.add(this.velocity.clone().multiplyScalar(deltaTime * SCALE_FACTOR));

                this.updateTrail();
            }

            updateTrail() {
                const newPosition = this.mesh.position.clone();
                this.orbitPositions[this.trailIndex] = newPosition;
                
                this.trailIndex = (this.trailIndex + 1) % this.trailLength;

                const positionsAttribute = this.trailGeometry.getAttribute('position');
                const positionsArray = positionsAttribute.array;

                if (this.trailIndex === 0) {
                    for (let i = 0; i < this.trailLength; i++) {
                        const currentIdx = i;

                        positionsArray[i * 3 + 0] = this.orbitPositions[currentIdx].x;
                        positionsArray[i * 3 + 1] = this.orbitPositions[currentIdx].y;
                        positionsArray[i * 3 + 2] = this.orbitPositions[currentIdx].z;
                    }

                } else {
                    for (let i = 0; i < this.trailIndex; i++) {
                        positionsArray[i * 3 + 0] = this.orbitPositions[i].x;
                        positionsArray[i * 3 + 1] = this.orbitPositions[i].y;
                        positionsArray[i * 3 + 2] = this.orbitPositions[i].z;
                    }
                    for (let i = this.trailIndex; i < this.trailLength; i++) {
                        positionsArray[i * 3 + 0] = this.mesh.position.x;
                        positionsArray[i * 3 + 1] = this.mesh.position.y;
                        positionsArray[i * 3 + 2] = this.mesh.position.z;
                    }
                }

                positionsAttribute.needsUpdate = true;
                this.trailGeometry.setDrawRange(0, this.trailIndex === 0 ? this.trailLength : this.trailIndex);
            }

            dispose() {
                scene.remove(this.mesh);
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
                scene.remove(this.trail);
                this.trailGeometry.dispose();
                this.trailMaterial.dispose();
            }
        }

        // ==========================================================================================
        // LÓGICA DE TRIVIA
        // ==========================================================================================
        let triviaData = [
            {
                question: "¿Cuál es el planeta más grande de nuestro sistema solar?",
                options: [
                    { text: "Saturno", correct: false },
                    { text: "Júpiter", correct: true },
                    { text: "Urano", correct: false },
                    { text: "Tierra", correct: false }
                ]
            },
            {
                question: "¿Qué planeta es conocido como 'el planeta rojo'?",
                options: [
                    { text: "Venus", correct: false },
                    { text: "Marte", correct: true },
                    { text: "Mercurio", correct: false },
                    { text: "Júpiter", correct: false }
                ]
            },
            {
                question: "¿Qué cuerpo celeste es el centro de gravedad en la simulación?",
                options: [
                    { text: "El planeta más masivo", correct: false },
                    { text: "El Sol (centro)", correct: true },
                    { text: "El objeto más rápido", correct: false },
                    { text: "La Tierra", correct: false }
                ]
            }
        ];
        
        let currentQuestionIndex = 0;
        let isAnsweringTrivia = false;

        function startTrivia() {
            if (orbitingBodies.length === 0) {
                alert("¡Crea al menos una órbita para comenzar la trivia!");
                return;
            }
            hideTooltip();

            isAnsweringTrivia = true;
            currentQuestionIndex = 0;
            document.getElementById('triviaModal').classList.remove('hidden');
            displayQuestion(currentQuestionIndex);
        }

        function displayQuestion(index) {
            const question = triviaData[index];
            const optionsDiv = document.getElementById('triviaOptions');
            const nextButton = document.getElementById('nextQuestionButton');

            document.getElementById('triviaTitle').textContent = `Pregunta ${index + 1} de ${triviaData.length}`;
            document.getElementById('triviaQuestion').textContent = question.question;
            optionsDiv.innerHTML = '';
            nextButton.classList.add('hidden');

            question.options.forEach((option, optionIndex) => {
                const button = document.createElement('button');
                button.textContent = option.text;
                button.className = 'w-full px-4 py-3 bg-gray-700 text-white rounded-lg text-left hover:bg-gray-600 transition duration-300 transform hover-scale';
                button.onclick = () => checkAnswer(option, button);
                optionsDiv.appendChild(button);
            });
        }

        function checkAnswer(selectedOption, buttonElement) {
            isAnsweringTrivia = false;
            const optionsDiv = document.getElementById('triviaOptions');
            const nextButton = document.getElementById('nextQuestionButton');
            
            Array.from(optionsDiv.children).forEach(btn => btn.disabled = true);

            if (selectedOption.correct) {
                buttonElement.classList.add('correct-answer', 'bg-green-500', 'hover:bg-green-500');
            } else {
                buttonElement.classList.add('wrong-answer', 'bg-red-500', 'hover:bg-red-500');
                const correctAnswer = triviaData[currentQuestionIndex].options.find(opt => opt.correct);
                const correctButton = Array.from(optionsDiv.children).find(btn => btn.textContent === correctAnswer.text);
                if (correctButton) {
                    correctButton.classList.add('correct-answer', 'bg-green-500');
                }
            }

            if (currentQuestionIndex < triviaData.length - 1) {
                nextButton.textContent = "Siguiente Pregunta";
                nextButton.onclick = () => {
                    currentQuestionIndex++;
                    displayQuestion(currentQuestionIndex);
                    isAnsweringTrivia = true;
                };
            } else {
                nextButton.textContent = "Trivia Finalizada (Cerrar)";
                nextButton.onclick = closeTrivia;
            }
            nextButton.classList.remove('hidden');
        }

        function closeTrivia() {
            document.getElementById('triviaModal').classList.add('hidden');
            isAnsweringTrivia = false;
        }


        // ==========================================================================================
        // INICIALIZACIÓN DE LA SIMULACIÓN
        // ==========================================================================================

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.001);

            const aspect = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
            camera.position.set(0, 100, 200);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('webgl-output').appendChild(renderer.domElement);

            ambientLight = new THREE.AmbientLight(0x404040, 5); 
            scene.add(ambientLight);
            directionalLight = new THREE.DirectionalLight(0xffffff, 2);
            directionalLight.position.set(50, 50, 50);
            scene.add(directionalLight);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; 
            controls.dampingFactor = 0.05;
            controls.maxDistance = 500;
            controls.minDistance = 50;
            
            // Habilitar controles táctiles
            controls.touches = {
                ONE: THREE.TOUCH.ROTATE,
                TWO: THREE.TOUCH.DOLLY_PAN 
            };


            const sunGeometry = new THREE.SphereGeometry(10, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffa500 });
            const sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sun.position.set(0, 0, 0);
            scene.add(sun);
            
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 10000;
            const positions = new Float32Array(starCount * 3);
            for (let i = 0; i < starCount; i++) {
                const distance = 500 + Math.random() * 500;
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;

                positions[i * 3 + 0] = distance * Math.sin(theta) * Math.cos(phi);
                positions[i * 3 + 1] = distance * Math.sin(theta) * Math.sin(phi);
                positions[i * 3 + 2] = distance * Math.cos(theta);
            }
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1, sizeAttenuation: true });
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            window.addEventListener('resize', onWindowResize, false);
            
            // Eventos de ratón y táctiles para arrastre de órbita
            renderer.domElement.addEventListener('mousedown', onPointerDown, false);
            renderer.domElement.addEventListener('touchstart', onPointerDown, false);

            renderer.domElement.addEventListener('mousemove', onPointerMove, false);
            renderer.domElement.addEventListener('touchmove', onPointerMove, false);

            renderer.domElement.addEventListener('mouseup', onPointerUp, false);
            renderer.domElement.addEventListener('touchend', onPointerUp, false);
            
            // EVENTO PRINCIPAL DE INTERACCIÓN (Tap para información)
            renderer.domElement.addEventListener('click', onPlanetTap, false);
            
            setupEventListeners();
        }

        // ==========================================================================================
        // LÓGICA DE TOOLTIP TÁCTIL (Tap/Click)
        // ==========================================================================================

        function showTooltip(bodyData) {
            const content = `
                <p class="font-bold text-base mb-1">${bodyData.info.name}</p>
                <p><strong>Masa:</strong> ${bodyData.info.mass.toFixed(1)} Unidades</p>
                <p><strong>Radio:</strong> ${bodyData.info.size.toFixed(1)}</p>
                <p><strong>Velocidad:</strong> ${bodyData.velocity.length().toFixed(2)}</p>
            `;
            TOOLTIP_CONTENT.innerHTML = content;
            INFO_TOOLTIP.classList.add('active');
        }

        function hideTooltip() {
            INFO_TOOLTIP.classList.remove('active');
            lastIntersectedObject = null;
        }

        function onPlanetTap(event) {
            if (isDragging || document.getElementById('welcomeModal').classList.contains('active')) return; 

            const clientX = event.clientX || (event.touches ? event.touches[0].clientX : undefined);
            const clientY = event.clientY || (event.touches ? event.touches[0].clientY : undefined);

            if (clientX === undefined || clientY === undefined) return;

            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const interactableObjects = orbitingBodies.map(body => body.mesh);
            const intersects = raycaster.intersectObjects(interactableObjects, false);

            if (intersects.length > 0) {
                controls.enabled = false;
                const intersectedMesh = intersects[0].object;
                
                if (intersectedMesh === lastIntersectedObject) {
                    hideTooltip();
                    controls.enabled = true;
                } else {
                    lastIntersectedObject = intersectedMesh;
                    const bodyData = orbitingBodies.find(body => body.mesh === intersectedMesh);
                    if (bodyData) {
                        showTooltip(bodyData);
                    }
                }
            } else {
                if (INFO_TOOLTIP.classList.contains('active')) {
                    hideTooltip();
                }
                controls.enabled = true;
            }
        }


        // ==========================================================================================
        // MANEJO DE EVENTOS DE USUARIO Y DRAG & DROP (TÁCTIL Y RATÓN)
        // ==========================================================================================

        function getClientCoords(event) {
            if (event.touches && event.touches.length) {
                return { x: event.touches[0].clientX, y: event.touches[0].clientY };
            }
            return { x: event.clientX, y: event.clientY };
        }

        function onPointerDown(event) {
            const coords = getClientCoords(event);
            
            if (event.target.closest('#planetCatalog') || event.target.closest('#actionButtons') || event.target.closest('#infoTooltip')) return;

            if (!dragBodyType) return;
            
            if (event.cancelable) event.preventDefault(); 

            isDragging = true;
            
            const position = get3DMousePosition(event);
            if (position) {
                initialClickPoint.copy(position);
                
                const geometry = new THREE.BufferGeometry().setFromPoints([initialClickPoint, initialClickPoint]);
                currentDragLine = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 3 }));
                scene.add(currentDragLine);

                controls.enabled = false;
            }
        }

        function onPointerMove(event) {
            if (!isDragging || !dragBodyType) return;
            
            if (event.cancelable) event.preventDefault(); 

            const currentPoint = get3DMousePosition(event);
            if (currentPoint && currentDragLine) {
                const positions = currentDragLine.geometry.attributes.position.array;
                positions[3] = currentPoint.x;
                positions[4] = currentPoint.y;
                positions[5] = currentPoint.z;
                currentDragLine.geometry.attributes.position.needsUpdate = true;
            }
        }

        function onPointerUp(event) {
            if (!isDragging || !dragBodyType) return;

            isDragging = false;
            controls.enabled = true;
            
            const releasePoint = get3DMousePosition(event);

            if (releasePoint && currentDragLine) {
                const initialVelocity = releasePoint.clone().sub(initialClickPoint).multiplyScalar(0.5); 
                createCelestialBody(initialClickPoint, initialVelocity, dragBodyType);
            }

            if (currentDragLine) {
                scene.remove(currentDragLine);
                currentDragLine.geometry.dispose();
                currentDragLine.material.dispose();
                currentDragLine = null;
            }

            dragBodyType = null;
        }

        let dragBodyTypeFromCatalog = null;

        document.querySelectorAll('.draggable-planet').forEach(element => {
            element.addEventListener('dragstart', (e) => {
                dragBodyType = element.getAttribute('data-type');
                e.dataTransfer.setData('text/plain', dragBodyType);
                const img = new Image();
                img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
                e.dataTransfer.setDragImage(img, 0, 0);

                document.getElementById('planetCatalog').style.opacity = 0.3;
            });

            element.addEventListener('dragend', () => {
                dragBodyType = null;
                document.getElementById('planetCatalog').style.opacity = 1.0;
            });
        });

        renderer.domElement.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        renderer.domElement.addEventListener('drop', (e) => {
            e.preventDefault();
            
            if (orbitingBodies.length >= MAX_ORBITS) {
                alert(`Límite alcanzado: Máximo ${MAX_ORBITS} órbitas.`);
                return;
            }

            dragBodyType = e.dataTransfer.getData('text/plain');

            const position = get3DMousePosition(e);
            if (position) {
                isDragging = true;
                initialClickPoint.copy(position);
            }
        });


        // ==========================================================================================
        // LÓGICA DE CREACIÓN DE CUERPOS CELESTES
        // ==========================================================================================

        function createCelestialBody(position, velocity, type) {
            let bodyMass, color, size, name;

            switch(type) {
                case 'slow-low':
                    bodyMass = 10;
                    color = 0xff0000;
                    size = 5;
                    name = "Gran Gigante (Rojo)";
                    break;
                case 'medium-rhythm':
                    bodyMass = 5;
                    color = 0xffff00;
                    size = 3;
                    name = "Cuerpo Mediano (Amarillo)";
                    break;
                case 'fast-high':
                    bodyMass = 2;
                    color = 0x0000ff;
                    size = 2;
                    name = "Pequeño Rápido (Azul)";
                    break;
                default:
                    return;
            }
            
            const geometry = new THREE.SphereGeometry(size, 16, 16);
            const material = new THREE.MeshLambertMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);

            const info = { name, mass: bodyMass, size };
            
            const body = new CelestialBody(bodyMass, type, mesh, position, velocity, new THREE.Color(color), info);
            
            scene.add(mesh);
            orbitingBodies.push(body);
            
            if (orbitingBodies.length === 1 && !isSimulationRunning) {
                startSimulation();
            }

            updateCatalogDisplay();
        }

        function updateCatalogDisplay() {
            const usedTypes = new Set(orbitingBodies.map(b => b.type));
            
            document.querySelectorAll('.draggable-planet').forEach(element => {
                const type = element.getAttribute('data-type');
                if (usedTypes.has(type)) {
                    element.classList.add('opacity-50', 'cursor-not-allowed');
                    element.setAttribute('draggable', 'false');
                } else {
                    element.classList.remove('opacity-50', 'cursor-not-allowed');
                    element.setAttribute('draggable', 'true');
                }
            });
        }

        function clearSimulation() {
            stopSimulation(); 
            
            orbitingBodies.forEach(body => body.dispose());
            orbitingBodies = [];
            
            hideTooltip();
            
            updateCatalogDisplay();
            controls.reset();
        }


        // ==========================================================================================
        // BUCLE DE ANIMACIÓN
        // ==========================================================================================

        function animate() {
            if (!isSimulationRunning) return;

            animationFrameId = requestAnimationFrame(animate);

            const deltaTime = TIME_STEP;

            orbitingBodies.forEach(body => {
                body.update(deltaTime);
            });

            controls.update();
            renderer.render(scene, camera);
        }

        function startSimulation() {
            if (isSimulationRunning) return;

            isSimulationRunning = true;
            animate();
            console.log("Simulación Iniciada.");
        }

        function stopSimulation() {
            if (!isSimulationRunning) return;
            
            cancelAnimationFrame(animationFrameId);
            isSimulationRunning = false;
            console.log("Simulación Detenida.");
        }


        // ==========================================================================================
        // CONFIGURACIÓN DE EVENTOS DE BOTONES
        // ==========================================================================================
        
        function setupEventListeners() {
            
            // CORRECCIÓN: Event Listener para el botón de inicio (ahora vinculado correctamente)
            document.getElementById('startButton').addEventListener('click', () => {
                document.getElementById('loadingScreen').classList.add('opacity-0');
                setTimeout(() => {
                    document.getElementById('loadingScreen').classList.add('hidden');
                    document.getElementById('mainInterface').classList.remove('hidden');
                }, 500); 
            });
            
            document.getElementById('closeWelcomeButton').addEventListener('click', () => {
                document.getElementById('welcomeModal').classList.add('hidden');
            });
            
            document.getElementById('clearButton').addEventListener('click', () => {
                if (confirm('¿Estás seguro de que quieres reiniciar la simulación y eliminar todas las órbitas?')) {
                    clearSimulation();
                }
            });

            document.getElementById('triviaButton').addEventListener('click', startTrivia);

            document.getElementById('closeTriviaButton').addEventListener('click', closeTrivia);
            
            document.getElementById('closeTooltip').addEventListener('click', hideTooltip);
        }

        // ==========================================================================================
        // INICIO DEL PROGRAMA
        // ==========================================================================================
        
        document.addEventListener('DOMContentLoaded', () => {
            init();
        });
    </script>
</body>
</html>
