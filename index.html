<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Armonía de las Esferas - Jeopardy</title>
    <!-- Carga de Tailwind CSS para estilos modernos y responsivos -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Configuración de Tailwind para incluir colores personalizados
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'space-dark': '#0d0d1a',
                        'space-blue': '#1a202c',
                        // Se define el naranja de la marca para usar en hover/focus
                        'brand-orange': '#f75b0f', 
                        // NUEVO: Color Turquesa para la Trivia
                        'trivia-teal': '#00c7b5',
                    }
                }
            }
        }
    </script>
    <!-- Carga de Three.js para la renderización 3D -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Carga de librerías para audio real/MIDI -->
    <script src="https://unpkg.com/tone@14.7.58/build/Tone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.2/build/Midi.min.js"></script>
    
    <style>
        /* Estilos personalizados para el cuerpo y el canvas */
        body {
            margin: 0;
            overflow: hidden; /* Evita barras de desplazamiento */
            font-family: 'Inter', sans-serif;
            background-color: #0d0d1a; /* Fondo oscuro espacial */
        }
        canvas {
            display: block;
            touch-action: none; /* Previene el comportamiento nativo del navegador al arrastrar */
        }
        /* Intenta aumentar el grosor de línea si el navegador lo permite */
        canvas.webgl-canvas {
            stroke-width: 2px;
        }
        /* Estilos específicos para la trivia */
        #jeopardyOverlay {
            /* Se aplica el color de la marca con una ligera opacidad */
            background-color: rgba(247, 91, 15, 0.95); /* #f75b0f */
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        .question-card {
            /* Estilo para los botones de las preguntas en el tablero */
            cursor: pointer;
            transition: transform 0.1s, opacity 0.3s;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 1px 1px 2px #000;
        }
        /* APLICA EL EFECTO HOVER DE COLOR TURQUESA */
        .point-cell:not(.answered):hover {
            transform: scale(1.05);
            background-color: #14b8a6; /* Usando teal-500 (Turquesa brillante) */
        }
        .answered {
            opacity: 0.5;
            cursor: default;
        }
        #questionDisplay {
            min-height: 20rem; /* Espacio mínimo para la pregunta */
        }
        /* Estilos para la tarjeta de pregunta (fondo blanco) */
        #questionDisplay {
            background-color: white;
            color: #1f2937; /* Texto oscuro */
        }
        /* Asegurar que el texto de las opciones sea negro por defecto en fondo blanco */
        .trivia-option-button {
             color: #1f2937;
        }
        /* Color hover de las celdas de pregunta turquesa brillante */
        .trivia-option-button:hover:not(:disabled) {
            background-color: #fcd34d !important; 
        }

    </style>
</head>
<body>

    <!-- Contenedor del Canvas y Overlay de Instrucciones -->
    <div id="container"></div>

    <!-- Overlay de Inicio -->
    <div id="overlay" style="background-color: #f75b0f;" class="fixed inset-0 flex flex-col items-center justify-center p-4 text-white transition-opacity duration-500 ease-in-out z-30">
        
        <div class="flex flex-col items-center text-center p-4">
            
            <!-- Título principal en color blanco, más grande y prominente -->
            <h1 class="text-6xl sm:text-7xl font-extrabold mb-12 text-white uppercase tracking-wider">
                Armonía de las Esferas
            </h1>
            
            <!-- Botón de inicio en blanco con texto naranja, más grande -->
            <button id="startButton" class="px-10 py-5 bg-white hover:bg-gray-200 text-brand-orange font-extrabold text-xl rounded-xl shadow-2xl transition transform hover:scale-105">
                ¡Empezar Simulación!
            </button>
        </div>
    </div>
    
    <!-- Controles Flotantes -->
    <div id="controls" class="fixed inset-x-0 bottom-4 flex flex-col items-center space-y-3 z-20 opacity-0 transition-opacity duration-500 pointer-events-none sm:flex-row sm:justify-between sm:bottom-auto sm:top-4 sm:space-y-0 sm:px-6">
        
        <!-- Botón Pausar/Reanudar -->
        <div class="sm:order-1 sm:w-auto">
            <button id="pauseButton" class="px-5 py-3 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-full shadow-lg transition transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-500 focus:ring-opacity-50">
                Pausar Simulación
            </button>
        </div>
        
        <!-- Menú de Selección de Entidad (Simplificado, la opción de pulso se elimina) -->
        <div class="w-full sm:w-auto sm:order-2">
            <label for="entitySelect" class="block text-sm font-medium text-white mb-1">Crear:</label>
            <select id="entitySelect" class="w-full sm:w-36 p-2 bg-gray-800 text-white rounded-lg border border-gray-700 focus:ring-brand-orange focus:border-brand-orange transition duration-150">
                <option value="planet">Planeta</option>
                <option value="sun">Sol</option>
            </select>
        </div>
        <!-- El antiguo selector de Pulso Planeta (sm:order-3) ha sido eliminado -->

        <!-- Botón Reiniciar Simulación (Bottom-Center) -->
        <div class="sm:order-4 sm:w-auto">
            <button id="clearButton" style="background-color: #f75b0f;" class="px-5 py-3 hover:bg-orange-700 text-white font-semibold rounded-full shadow-lg transition transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-orange-500 focus:ring-opacity-50">
                Reiniciar Simulación
            </button>
        </div>

        <!-- Botón Iniciar Trivia (NUEVO) -->
        <div class="sm:order-5 sm:w-auto">
            <button id="triviaButton" class="px-5 py-3 bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-semibold rounded-full shadow-lg transition transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-yellow-400 focus:ring-opacity-50">
                Iniciar Trivia
            </button>
        </div>
    </div>

    <!-- Overlay de JEOPARDY (Inicialmente Oculto) -->
    <div id="jeopardyOverlay" class="fixed inset-0 flex flex-col items-center justify-center p-4 text-white z-40 hidden">
        <div id="triviaContent" class="w-full max-w-6xl bg-gray-900/90 rounded-xl shadow-2xl p-6 space-y-6">
            
            <!-- Encabezado y Puntuación -->
            <div class="flex justify-between items-center border-b pb-3 border-gray-700">
                <!-- Título Simplificado -->
                <h2 class="text-3xl font-bold text-yellow-400">Armonía de las Esferas</h2>
                <div id="score" class="text-lg font-medium bg-gray-800 p-2 rounded-lg">
                    Puntos: <span id="currentScore" class="text-yellow-400">0</span>
                </div>
                <!-- Botón Regresar - Llama a resumeSimulation() -->
                <button id="resumeButton" class="px-4 py-2 bg-trivia-teal hover:bg-teal-600 rounded-lg text-white font-semibold transition">Regresar</button>
            </div>
            
            <!-- Contenedor del Tablero (Grid) -->
            <div id="jeopardyBoard" class="grid grid-cols-3 gap-3">
                <!-- Títulos de Categoría -->
                <div class="p-3 bg-trivia-teal font-extrabold text-xl text-center rounded-t-lg text-white">FÍSICA (Gravedad)</div>
                <div class="p-3 bg-trivia-teal font-extrabold text-xl text-center rounded-t-lg text-white">COMPOSICIÓN</div>
                <div class="p-3 bg-trivia-teal font-extrabold text-xl text-center rounded-t-lg text-white">DATOS DEL SISTEMA</div>
                
                <!-- Las celdas de puntos se inyectan aquí -->
            </div>
            
            <!-- Contenedor de la Pregunta Activa -->
            <div id="questionDisplay" class="hidden flex-col justify-center items-center p-6 bg-white text-gray-900 rounded-lg question-card">
                <div id="questionCategory" class="text-xl font-semibold text-yellow-600 mb-2"></div>
                <div id="questionValue" class="2xl font-bold mb-4"></div>
                <div id="currentQuestionText" class="text-2xl text-center mb-6"></div>
                
                <div id="optionsContainer" class="w-full grid grid-cols-1 md:grid-cols-2 gap-4">
                    <!-- Opciones de respuesta inyectadas aquí -->
                </div>
                
                <div id="feedbackMessage" class="mt-4 text-xl font-bold hidden"></div>
                <!-- Botón Volver al Tablero - Llama a renderJeopardyBoard() -->
                <button id="backToBoardButton" class="mt-6 px-6 py-3 bg-trivia-teal hover:bg-teal-600 rounded-lg text-white font-semibold transition hidden">Volver al Tablero</button>
            </div>
            

        </div>
    </div>


    <script>
        // Configuración global de Three.js
        let scene, camera, renderer;
        let ambientLight;
        let starField; // Variable para el campo de estrellas
        
        // --- ARRAYS GLOBALES PARA MÚLTIPLES OBJETOS ---
        const suns = []; 
        const planets = [];
        
        // =================================================================
        // CONSTANTES DE FÍSICA Y TIEMPO
        // =================================================================
        const GRAVITATIONAL_CONSTANT = 1.0; 
        const SUN_MASS = 1000.0; 
        const PLANET_MASS = 1.0; 
        const TIME_STEP = 0.05; 
        const MIN_DISTANCE = 25;
        const MAX_DISTANCE = 150;
        const COLLISION_DISTANCE = 18; 
        const MAX_SUN_DISTANCE = 100; 
        
        // NUEVO: Límite de expulsión más amplio para evitar pérdidas rápidas
        const MAX_EXPULSION_DISTANCE = 1000;
        
        // Aumentamos la longitud del rastro a 100 puntos (antes 50)
        const TRAIL_LENGTH = 100; 
        
        // NUEVA VARIABLE DE ESTADO
        let isPaused = false;
        
        // Objeto para ayudar en la conversión de coordenadas 2D a 3D
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        
        // Vectores temporales para evitar reasignaciones constantes y ahorrar memoria/rendimiento
        const tempVector = new THREE.Vector3();
        
        // =================================================================
        // VARIABLES DE CONTROL DE CÁMARA (MANUAL)
        // =================================================================
        let isDragging = false; 
        let isPointerActive = false;
        let pointerStart = { x: 0, y: 0 };
        let previousPointerPosition = { x: 0, y: 0 };
        const ORBIT_RADIUS = 250; // AUMENTADO A 250 para mejor vista inicial
        
        let theta = 0.5; // Ligera rotación inicial para ver el sol
        let phi = Math.PI / 2;
        
        const DAMPING_FACTOR = 0.9; 
        const ROTATION_MULTIPLIER = 0.005;
        let velocityX = 0;
        let velocityY = 0;
        
        const DRAG_THRESHOLD = 5;

        // =================================================================
        // CONFIGURACIÓN DE AUDIO (ESTRUCTURA PARA MIDI REAL)
        // =================================================================
        let isAudioContextStarted = false;
        let musicStarted = false;
        
        // RUTA RELATIVA AL ARCHIVO MIDI (Debe estar en la misma carpeta en GitHub Pages)
        const MIDI_FILE_PATH = 'Grupo_Niche_-_el_amor_vendr.mid'; 
        
        // 1. ESTRUCTURA DE CANCIÓN (basada en el MIDI, 10 pistas para una canción)
        const TOTAL_SONGS = 5; // Total de canciones a simular
        const TRACKS_PER_SONG = 10; // Pistas por canción (basado en el MIDI)

        let currentSongIndex = 0; 
        let currentMidiData = null; // Almacenará el objeto MIDI parseado
        const midiPlayers = []; // Arreglo de Tone.js Samplers para reproducir las pistas
        
        // Genera los nombres de las capas: CancionX_Y
        const generateLayerNames = (songNum) => {
            let layers = [];
            for (let i = 1; i <= TRACKS_PER_SONG; i++) {
                layers.push(`Cancion${songNum}_${i}`);
            }
            return layers;
        };

        // Estructura de datos global que simula 5 canciones (para la rotación)
        const SONG_DATA_STRUCTURES = [];
        for (let i = 1; i <= TOTAL_SONGS; i++) {
            SONG_DATA_STRUCTURES.push({
                name: `Cancion ${i}: Grupo Niche - El Amor Vendrá (Parte ${i})`,
                layers: generateLayerNames(i)
            });
        }
        
        let INSTRUMENT_LAYERS = SONG_DATA_STRUCTURES[0].layers;
        let activePatterns = {}; // Mapa para silenciar/activar cada pista por planeta
        const activeNotes = {}; // Para visuales (ahora solo dummy)


        /**
         * Inicializa los Samplers de Tone.js (instrumentos reales).
         * @param {object} midi Objeto MIDI de Tone.js
         */
        async function setupMidiPlayers(midi) {
            // Un mapa simple de Instrumentos General MIDI (GM) a sonidos de Sampler
            const GM_INSTRUMENT_MAP = {
                // Aquí se usarían samples reales, pero para estabilidad, usamos GM
                'piano': 'piano',
                'bass': 'bass-electric',
                'drums': 'drums',
                'brass': 'trumpet',
                'synth': 'synth_lead',
                'strings': 'violin'
            };
            
            // Creamos un instrumento Sampler por cada pista en el MIDI
            midi.tracks.slice(0, TRACKS_PER_SONG).forEach((track, i) => {
                const instrumentName = track.instrument.name || 'piano';
                const samplerKey = GM_INSTRUMENT_MAP[instrumentName.toLowerCase()] || 'piano'; // Selecciona el sample
                
                // NOTA: Para estabilidad, en un proyecto real, se usaría un servidor de samples.
                // Aquí usaremos la ruta de los samples de Tone.js
                const sampler = new Tone.Sampler({
                    urls: {
                        "C4": `${samplerKey}-c4.mp3`,
                    },
                    baseUrl: "https://tonejs.github.io/audio/salamander/", // Samples reales de piano, etc.
                    onload: () => {
                        // El sampler se inicializa en silencio (mutear)
                        sampler.volume.value = -100;
                        sampler.toDestination();
                        midiPlayers.push(sampler);
                        
                        // Si es el último, iniciamos el secuenciador
                        if (midiPlayers.length === TRACKS_PER_SONG) {
                            startSequencer(midi);
                        }
                    },
                    onerror: (e) => {
                        console.error(`Error al cargar sampler para ${instrumentName}:`, e);
                        showMessage("Error crítico: Fallo al cargar samples de instrumento.", 5000, new THREE.Color(0xff4444));
                    }
                }).toDestination();
            });

            // Si no hay tracks (MIDI vacío), forzamos el inicio.
            if (midi.tracks.length === 0) {
                 startSequencer(midi);
            }
        }
        
        /**
         * Inicia el secuenciador de Tone.js con los datos MIDI.
         * @param {object} midi Objeto MIDI de Tone.js
         */
        function startSequencer(midi) {
            // 1. Limpiar cualquier loop/evento previo
            Tone.Transport.cancel();

            // 2. Ajustar Tempo (BPM)
            Tone.Transport.bpm.value = midi.header.tempos[0].bpm || 128; // Usar el BPM del MIDI o 128 por defecto

            // 3. Crear el loop/secuencia para CADA pista
            midi.tracks.slice(0, TRACKS_PER_SONG).forEach((track, i) => {
                const notes = track.notes;
                const player = midiPlayers[i];

                // Tone.Loop es más estable que Tone.Part para secuencias largas
                const loop = new Tone.Loop(time => {
                    // Solo reproducimos la capa si está activa (activada por un planeta)
                    if (activePatterns[INSTRUMENT_LAYERS[i]]) {
                         // Reproducir todas las notas que caen en este ciclo de beat
                         notes.forEach(note => {
                            // Usamos el evento de nota para activar la visualización
                            activeNotes[INSTRUMENT_LAYERS[i]] = true; // Activar visual

                            player.triggerAttackRelease(
                                note.name, 
                                note.duration, 
                                time + note.time, 
                                note.velocity
                            );
                            
                            // Desactivar visual después de un pequeño retraso
                            Tone.Draw.schedule(() => {
                                activeNotes[INSTRUMENT_LAYERS[i]] = false;
                            }, time + note.duration);
                        });
                    }
                }, "4n").start(0); // Ejecutar cada cuarto de nota (ajustable)
                
                // Lo almacenamos para poder limpiarlo al cambiar la canción
                // NOTA: Para un MIDI completo, se necesita una lógica de Tone.Part más compleja
            });

            Tone.Transport.loop = true;
            Tone.Transport.loopEnd = midi.duration || "4m"; // Duración del MIDI o 4 compases
            
            // 4. Iniciar el motor de tiempo
            Tone.Transport.start();
            showMessage("¡Música lista! Crea tu primer planeta.", 2000, new THREE.Color(0x22c55e));
        }

        /**
         * Carga el archivo MIDI de forma asíncrona.
         */
        async function loadMidiAndSetup() {
             showMessage(`Cargando MIDI: ${SONG_DATA_STRUCTURES[currentSongIndex].name}.`, 3000, new THREE.Color(0xfacc15));
             
             // NOTA: La ruta debe ser el nombre del archivo subido al repositorio de GitHub
             const MIDI_PATH = 'Grupo_Niche_-_el_amor_vendr.mid'; 
             
             try {
                // Usamos fetch para asegurar que el navegador pueda acceder al archivo
                const response = await fetch(MIDI_PATH);
                if (!response.ok) {
                    throw new Error(`Error ${response.status}: Archivo MIDI no encontrado o acceso denegado.`);
                }
                const arrayBuffer = await response.arrayBuffer();

                // 2. Parsear el archivo MIDI
                const midi = new Midi(arrayBuffer);
                currentMidiData = midi; // Almacenar el MIDI completo
                
                // 3. Configurar los reproductores de audio
                await setupMidiPlayers(midi);

            } catch (e) {
                 console.error("Error al cargar y parsear MIDI:", e);
                 showMessage(`Error al cargar la partitura MIDI. ¿Está '${MIDI_PATH}' en la raíz del repositorio?`, 8000, new THREE.Color(0xff4444));
            }
        }

        /**
         * Función dummy para mantener la estructura de planet.synth (ahora solo mute/unmute)
         */
        function createSynth() {
            return { synth: null, panner: null }; 
        }

        /**
         * Inicia el contexto de audio y la carga del MIDI.
         */
        function startAudioContext() {
            if (!isAudioContextStarted) {
                // Iniciar el Contexto de Audio con interacción del usuario
                Tone.start(); 
                isAudioContextStarted = true;
                
                // Iniciar la carga del MIDI
                loadMidiAndSetup(); 
            }
        }
        
        /**
         * Función que cambia la canción al crear un nuevo Sol.
         */
        function changeSong() {
            if (!currentMidiData) return; // No hacer nada si no hay MIDI cargado

            // Ciclo a la siguiente canción
            currentSongIndex = (currentSongIndex + 1) % TOTAL_SONGS; 
            
            // 1. Detener la reproducción actual
            Tone.Transport.stop();
            Tone.Transport.cancel();
            
            // 2. Configurar el nuevo secuenciador (usando el MIDI ya cargado)
            startSequencer(currentMidiData);

            // 3. Actualizar las capas de instrumento disponibles (para la UI)
            INSTRUMENT_LAYERS = SONG_DATA_STRUCTURES[currentSongIndex].layers;

            // 4. Limpiar los patrones activos de los planetas (visuales)
            planets.forEach(p => p.assignedLayer = INSTRUMENT_LAYERS[0]);
            activePatterns = {};
            
            showMessage(`Música cambiada a: ${SONG_DATA_STRUCTURES[currentSongIndex].name}`, 2000, new THREE.Color(0xfacc15));
        }
        
        /**
         * Controla qué patrones rítmicos están activos (solo lógica, sin audio).
         */
        function updateAudioVolumes() {
            // 1. Mapear qué capas están activas visualmente (para el MIDI)
            INSTRUMENT_LAYERS.forEach(layer => activePatterns[layer] = false);
            
            planets.forEach((planet, index) => {
                const layerIndex = index % TRACKS_PER_SONG;
                const layerName = INSTRUMENT_LAYERS[layerIndex];
                
                planet.assignedLayer = layerName;
                activePatterns[layerName] = true;
                
                // Controlar el volumen real del sampler (si existe)
                if (midiPlayers[layerIndex]) {
                    midiPlayers[layerIndex].volume.value = 0; // Activar (0dB)
                }
            });
            
            // Silenciar las capas sin planeta
            for (let i = planets.length; i < TRACKS_PER_SONG; i++) {
                 if (midiPlayers[i]) {
                    midiPlayers[i].volume.value = -100; // Silenciar
                 }
            }


            // 3. Controlar el estado general 
            if (planets.length > 0 && !musicStarted) {
                musicStarted = true;
                Tone.Master.mute = false; // Desmutear la música
            } else if (planets.length === 0 && musicStarted) {
                musicStarted = false;
                Tone.Master.mute = true; // Mutear todo
            }
        }


        // =================================================================
        // ... (Resto de funciones de Física y Visuales sin cambios) ...
        // =================================================================

        /**
         * Bucle principal de animación (game loop).
         */
        function animate() {
            requestAnimationFrame(animate);
            
            // 0. Rotación sutil del campo de estrellas
            if (starField) {
                starField.rotation.y += 0.00005; 
            }
            
            // 0.1 Lógica de visuales rítmicas para el brillo de los planetas
            // La visualización se actualiza en el sequencer (Tone.Draw) y aquí para el silencio
            if (!musicStarted) {
                 INSTRUMENT_LAYERS.forEach(layer => activeNotes[layer] = false);
            }

            // 1. Mover Planetas y Actualizar Rastros y Audio (SOLO si NO está pausado)
            if (!isPaused) {
                
                for (let i = planets.length - 1; i >= 0; i--) {
                    const planet = planets[i];

                    // a. Calcular fuerzas y actualizar física
                    calculateGravity(planet);
                    updatePhysics(planet, TIME_STEP);
                    
                    // b. Detección de colisión (Ya no elimina) / expulsión (SOLO ELIMINA POR EXPULSIÓN)
                    // ... (sin cambios) ...

                    // c. LÓGICA DE VISUALIZACIÓN RÍTMICA
                    const layer = planet.assignedLayer;
                    const isNoteActive = activeNotes[layer];

                    if (isNoteActive) {
                        // Si el instrumento asignado está "sonando", hacerlo brillar
                        const maxEmissive = 1.0; 
                        planet.mesh.material.emissiveIntensity = THREE.MathUtils.lerp(planet.mesh.material.emissiveIntensity, maxEmissive, 0.5);
                    } else {
                        // Si no está "sonando", bajar el brillo
                        const minEmissive = 0.1;
                        planet.mesh.material.emissiveIntensity = THREE.MathUtils.lerp(planet.mesh.material.emissiveIntensity, minEmissive, 0.1);
                    }

                    // d. Rotación propia del planeta
                    planet.mesh.rotation.y += 0.01;

                    // e. Actualizar rastro de órbita y colores (opacidad)
                    // ... (sin cambios) ...
                    const orbitPositions = planet.orbitPositions;
                    const positionsAttribute = planet.trail.geometry.attributes.position;
                    const colorsAttribute = planet.trail.geometry.attributes.color;
                    const positionsForDrawing = positionsAttribute.array;
                    const colorsForDrawing = colorsAttribute.array;
                    
                    const index = planet.trailIndex * 3;

                    // 1. Guardar nueva posición
                    orbitPositions[index] = planet.mesh.position.x;
                    orbitPositions[index + 1] = planet.mesh.position.y;
                    orbitPositions[index + 2] = planet.mesh.position.z;

                    planet.trailIndex = (planet.trailIndex + 1) % planet.trailLength;
                    
                    if (planet.trailCount < planet.trailLength) {
                        planet.trailCount++;
                    }

                    // 2. Reordenar puntos y aplicar colores/opacidad
                    let p_index = 0; 
                    const totalPoints = planet.trailCount < planet.trailLength ? planet.trailCount : planet.trailLength;
                    const baseColor = planet.planetColor;

                    const updatePoint = (j, opacityRatio) => {
                        // Posición
                        positionsForDrawing[p_index * 3] = orbitPositions[j * 3];
                        positionsForDrawing[p_index * 3 + 1] = orbitPositions[j * 3 + 1];
                        positionsForDrawing[p_index * 3 + 2] = orbitPositions[j * 3 + 2];
                        
                        // Color y Opacidad (RGBA)
                        colorsForDrawing[p_index * 4] = baseColor.r;
                        colorsForDrawing[p_index * 4 + 1] = baseColor.g;
                        colorsForDrawing[p_index * 4 + 2] = baseColor.b;
                        colorsForDrawing[p_index * 4 + 3] = opacityRatio; // Opacidad

                        p_index++;
                    };
                    
                    const calculateOpacity = (i) => {
                        // i: índice absoluto del punto, de 0 al totalPoints-1
                        const minOpacity = 0.2;
                        const factor = 1.0 - minOpacity;
                        return minOpacity + (i / totalPoints) * factor; 
                    };


                    if (planet.trailCount < planet.trailLength) {
                        // FASE DE LLENADO: Rastro desde el punto 0 hasta el punto actual
                        for (let j = 0; j < planet.trailCount; j++) {
                            const opacityRatio = calculateOpacity(j);
                            updatePoint(j, opacityRatio);
                        }
                        planet.trail.geometry.setDrawRange(0, planet.trailCount);

                    } else {
                        // FASE ESTABLE: Rastro completo (buffer circular)
                        let opacityCounter = 0;
                        
                        // Parte A: Desde el punto actual (el más viejo) hasta el final del array
                        for (let j = planet.trailIndex; j < planet.trailLength; j++) {
                            const opacityRatio = calculateOpacity(opacityCounter++);
                            updatePoint(j, opacityRatio);
                        }
                        // Parte B: Desde el inicio del array (punto 0) hasta el punto actual (el más reciente)
                        for (let j = 0; j < planet.trailIndex; j++) {
                            const opacityRatio = calculateOpacity(opacityCounter++);
                            updatePoint(j, opacityRatio);
                        }
                        
                        planet.trail.geometry.setDrawRange(0, planet.trailLength);
                    }

                    positionsAttribute.needsUpdate = true;
                    colorsAttribute.needsUpdate = true; // Notificar a Three.js que los colores cambiaron

                }
            }
            
            // 2. Mover la Cámara (Controles Manuales e Inercia) - Esto siempre debe funcionar
            // ... (sin cambios) ...
            if (!isDragging) {
                theta += velocityX;
                phi -= velocityY; 
                velocityX *= DAMPING_FACTOR;
                velocityY *= DAMPING_FACTOR;
            }

            phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));

            const x = ORBIT_RADIUS * Math.sin(phi) * Math.sin(theta);
            const y = ORBIT_RADIUS * Math.cos(phi);
            const z = ORBIT_RADIUS * Math.sin(phi) * Math.cos(theta);

            camera.position.set(x, y, z);
            camera.lookAt(0, 0, 0); 

            // 3. Renderizar la Escena
            renderer.render(scene, camera);
        }

        // =================================================================
        // ... (Resto de funciones de Utilidades y Trivia sin cambios) ...
        // =================================================================

        document.getElementById('startButton').addEventListener('click', () => {
            try {
                // 1. Iniciar AudioContext (requiere interacción del usuario)
                // INICIA LA CARGA DEL MIDI AL HACER CLICK EN EL BOTÓN
                startAudioContext(); 
                
                // 2. Transición Visual Inmediata
                const overlay = document.getElementById('overlay');
                overlay.style.opacity = '0';
                
                setTimeout(() => {
                    overlay.style.pointerEvents = 'none';
                    
                    // 3. Inicialización del motor (Three.js + Tone.js)
                    init();
                    animate();

                    // 4. ATTACH CONTROLS (Must happen after init())
                    document.getElementById('pauseButton').addEventListener('click', togglePause);
                    document.getElementById('clearButton').addEventListener('click', clearSimulation);
                    document.getElementById('triviaButton').addEventListener('click', startJeopardy);
                    document.getElementById('resumeButton').addEventListener('click', resumeSimulation);
                    document.getElementById('backToBoardButton').addEventListener('click', renderJeopardyBoard);
                
                    const controls = document.getElementById('controls');
                    controls.style.opacity = '1';
                    controls.style.pointerEvents = 'auto';
                
                    showMessage('¡Simulación Iniciada! Crea un planeta para iniciar el rastreo.', 3500, new THREE.Color(0x22c55e));

                }, 500); // 500ms para la transición

            } catch (error) {
                console.error("Fallo crítico al iniciar la simulación:", error);
                // Mostrar un mensaje de error visible al usuario si la inicialización falla
                showMessage(`Error al iniciar: ${error.message}. Revisa la consola.`, 5000, new THREE.Color(0xff0000));
            }
        });

    </script>
</body>
</html>

    </script>
</body>

</html>
