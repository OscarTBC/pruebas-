<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Armon√≠a de las Esferas - Jeopardy</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Configuraci√≥n de Tailwind para incluir colores personalizados
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'space-dark': '#0d0d1a',
                        'space-blue': '#1a202c',
                        // Se define el naranja de la marca para usar en hover/focus
                        'brand-orange': '#f75b0f', 
                        // NUEVO: Color Turquesa para la Trivia
                        'trivia-teal': '#00c7b5',
                    }
                }
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/tone@14.7.58/build/Tone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.2/build/Midi.min.js"></script>
    
    <style>
        /* Estilos personalizados para el cuerpo y el canvas */
        body {
            margin: 0;
            overflow: hidden; /* Evita barras de desplazamiento */
            font-family: 'Inter', sans-serif;
            background-color: #0d0d1a; /* Fondo oscuro espacial */
        }
        canvas {
            display: block;
            touch-action: none; /* Previene el comportamiento nativo del navegador al arrastrar */
        }
        /* Intenta aumentar el grosor de l√≠nea si el navegador lo permite */
        canvas.webgl-canvas {
            stroke-width: 2px;
        }
        /* Estilos espec√≠ficos para la trivia */
        #jeopardyOverlay {
            /* Se aplica el color de la marca con una ligera opacidad */
            background-color: rgba(247, 91, 15, 0.95); /* #f75b0f */
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        .question-card {
            /* Estilo para los botones de las preguntas en el tablero */
            cursor: pointer;
            transition: transform 0.1s, opacity 0.3s;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 1px 1px 2px #000;
        }
        /* APLICA EL EFECTO HOVER DE COLOR TURQUESA */
        .point-cell:not(.answered):hover {
            transform: scale(1.05);
            background-color: #14b8a6; /* Usando teal-500 (Turquesa brillante) */
        }
        .answered {
            opacity: 0.5;
            cursor: default;
        }
        #questionDisplay {
            min-height: 20rem; /* Espacio m√≠nimo para la pregunta */
        }
        /* Estilos para la tarjeta de pregunta (fondo blanco) */
        #questionDisplay {
            background-color: white;
            color: #1f2937; /* Texto oscuro */
        }
        /* Asegurar que el texto de las opciones sea negro por defecto en fondo blanco */
        .trivia-option-button {
             color: #1f2937;
        }
        /* Color hover de las celdas de pregunta turquesa brillante */
        .trivia-option-button:hover:not(:disabled) {
            background-color: #fcd34d !important; 
        }

    </style>
</head>
<body>

    <div id="container"></div>

    <div id="overlay" style="background-color: #f75b0f;" class="fixed inset-0 flex flex-col items-center justify-center p-4 text-white transition-opacity duration-500 ease-in-out z-30">
        
        <div class="flex flex-col items-center text-center p-4">
            
            <h1 class="text-6xl sm:text-7xl font-extrabold mb-12 text-white uppercase tracking-wider">
                Armon√≠a de las Esferas
            </h1>
            
            <button id="startButton" class="px-10 py-5 bg-white hover:bg-gray-200 text-brand-orange font-extrabold text-xl rounded-xl shadow-2xl transition transform hover:scale-105">
                ¬°Empezar Simulaci√≥n!
            </button>
        </div>
    </div>
    
    <div id="controls" class="fixed inset-x-0 bottom-4 flex flex-col items-center space-y-3 z-20 opacity-0 transition-opacity duration-500 pointer-events-none sm:flex-row sm:justify-between sm:bottom-auto sm:top-4 sm:space-y-0 sm:px-6">
        
        <div class="sm:order-1 sm:w-auto">
            <button id="pauseButton" class="px-5 py-3 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-full shadow-lg transition transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-500 focus:ring-opacity-50">
                Pausar Simulaci√≥n
            </button>
        </div>
        
        <div class="w-full sm:w-auto sm:order-2">
            <label for="entitySelect" class="block text-sm font-medium text-white mb-1">Crear:</label>
            <select id="entitySelect" class="w-full sm:w-36 p-2 bg-gray-800 text-white rounded-lg border border-gray-700 focus:ring-brand-orange focus:border-brand-orange transition duration-150">
                <option value="planet">Planeta</option>
                <option value="sun">Sol</option>
            </select>
        </div>
        <div class="sm:order-4 sm:w-auto">
            <button id="clearButton" style="background-color: #f75b0f;" class="px-5 py-3 hover:bg-orange-700 text-white font-semibold rounded-full shadow-lg transition transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-orange-500 focus:ring-opacity-50">
                Reiniciar Simulaci√≥n
            </button>
        </div>

        <div class="sm:order-5 sm:w-auto">
            <button id="triviaButton" class="px-5 py-3 bg-yellow-500 hover:bg-yellow-600 text-gray-900 font-semibold rounded-full shadow-lg transition transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-yellow-400 focus:ring-opacity-50">
                Iniciar Trivia
            </button>
        </div>
    </div>

    <div id="jeopardyOverlay" class="fixed inset-0 flex flex-col items-center justify-center p-4 text-white z-40 hidden">
        <div id="triviaContent" class="w-full max-w-6xl bg-gray-900/90 rounded-xl shadow-2xl p-6 space-y-6">
            
            <div class="flex justify-between items-center border-b pb-3 border-gray-700">
                <h2 class="text-3xl font-bold text-yellow-400">Armon√≠a de las Esferas</h2>
                <div id="score" class="text-lg font-medium bg-gray-800 p-2 rounded-lg">
                    Puntos: <span id="currentScore" class="text-yellow-400">0</span>
                </div>
                <button id="resumeButton" class="px-4 py-2 bg-trivia-teal hover:bg-teal-600 rounded-lg text-white font-semibold transition">Regresar</button>
            </div>
            
            <div id="jeopardyBoard" class="grid grid-cols-3 gap-3">
                <div class="p-3 bg-trivia-teal font-extrabold text-xl text-center rounded-t-lg text-white">F√çSICA (Gravedad)</div>
                <div class="p-3 bg-trivia-teal font-extrabold text-xl text-center rounded-t-lg text-white">COMPOSICI√ìN</div>
                <div class="p-3 bg-trivia-teal font-extrabold text-xl text-center rounded-t-lg text-white">DATOS DEL SISTEMA</div>
                
                </div>
            
            <div id="questionDisplay" class="hidden flex-col justify-center items-center p-6 bg-white text-gray-900 rounded-lg question-card">
                <div id="questionCategory" class="text-xl font-semibold text-yellow-600 mb-2"></div>
                <div id="questionValue" class="2xl font-bold mb-4"></div>
                <div id="currentQuestionText" class="text-2xl text-center mb-6"></div>
                
                <div id="optionsContainer" class="w-full grid grid-cols-1 md:grid-cols-2 gap-4">
                    </div>
                
                <div id="feedbackMessage" class="mt-4 text-xl font-bold hidden"></div>
                <button id="backToBoardButton" class="mt-6 px-6 py-3 bg-trivia-teal hover:bg-teal-600 rounded-lg text-white font-semibold transition hidden">Volver al Tablero</button>
            </div>
            

        </div>
    </div>


    <script>
        // Configuraci√≥n global de Three.js
        let scene, camera, renderer;
        let ambientLight;
        let starField; // Variable para el campo de estrellas
        
        // --- ARRAYS GLOBALES PARA M√öLTIPLES OBJETOS ---
        const suns = []; 
        const planets = [];
        
        // =================================================================
        // CONSTANTES DE F√çSICA Y TIEMPO
        // =================================================================
        const GRAVITATIONAL_CONSTANT = 1.0; 
        const SUN_MASS = 1000.0; 
        const PLANET_MASS = 1.0; 
        const TIME_STEP = 0.05; 
        const MAX_EXPULSION_DISTANCE = 1000;
        const COLLISION_DISTANCE = 18; 
        const MAX_SUN_DISTANCE = 100; 
        const TRAIL_LENGTH = 100; 
        let isPaused = false;
        
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        const tempVector = new THREE.Vector3();
        
        // ... (Variables de control de c√°mara) ...
        let isDragging = false; 
        let isPointerActive = false;
        let pointerStart = { x: 0, y: 0 };
        let previousPointerPosition = { x: 0, y: 0 };
        const ORBIT_RADIUS = 250; 
        let theta = 0.5; 
        let phi = Math.PI / 2;
        const DAMPING_FACTOR = 0.9; 
        const ROTATION_MULTIPLIER = 0.005;
        let velocityX = 0;
        let velocityY = 0;
        const DRAG_THRESHOLD = 5;

        // =================================================================
        // CONFIGURACI√ìN DE AUDIO (L√≥gica de MIDI/Tone.js REAL)
        // =================================================================
        
        // üö® Configuraci√≥n Cr√≠tica: URL base para acceder a los archivos MIDI de GitHub RAW
        const GITHUB_RAW_BASE_URL = "https://raw.githubusercontent.com/OscarTBC/pruebas-/main/";
        
        let isAudioContextStarted = false;
        let musicStarted = false;

        const TOTAL_SONGS = 2; // C1 y C2
        const TRACKS_PER_SONG = 8; // M√°ximo de pistas (C1 tiene 8, C2 tiene 7)
        
        let currentSongIndex = 0; // 0 para C1, 1 para C2
        
        // Almacena los Tone.Part (los bucles de reproducci√≥n)
        const SONG_TONE_PARTS = {}; 
        
        // Sintetizador global que usar√° Tone.js para reproducir todas las notas
        let globalSynth; 

        // Genera el nombre de la pista (Ej: C1_T1)
        const getTrackName = (songNum, trackNum) => `C${songNum}_T${trackNum}`;

        // Estructura de datos global que simula 2 canciones
        const SONG_DATA_STRUCTURES = [];
        for (let i = 1; i <= TOTAL_SONGS; i++) {
            let layers = [];
            // Ajustamos las capas de la estructura para reflejar el m√°ximo de 8, 
            // aunque solo cargaremos 7 para C2.
            const totalLayers = (i === 1) ? 8 : 7;
            for (let j = 1; j <= totalLayers; j++) { 
                layers.push(getTrackName(i, j));
            }
            SONG_DATA_STRUCTURES.push({ name: `Cancion ${i}`, layers: layers });
        }
        
        let INSTRUMENT_LAYERS = SONG_DATA_STRUCTURES[0].layers;
        let activePatterns = {}; // Mapa para silenciar/activar cada pista por planeta
        const activeNotes = {}; // Para el control visual del brillo

        /**
         * Inicializa el sintetizador y carga todos los archivos MIDI de GitHub.
         * Esta funci√≥n es AS√çNCRONA.
         * @returns {Promise<void>}
         */
        async function loadMidiFiles() {
            // 1. Crear un sintetizador simple para la reproducci√≥n
            globalSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "square" },
                envelope: { attack: 0.05, decay: 0.2, sustain: 0.8, release: 1 },
            }).toDestination();

            const loadingPromises = [];
            
            for (let songNum = 1; songNum <= TOTAL_SONGS; songNum++) {
                const songKey = `C${songNum}`;
                SONG_TONE_PARTS[songKey] = {}; 

                // üö® CORRECCI√ìN MIDI: Solo cargamos las pistas que sabemos que existen.
                const tracksToLoad = (songNum === 1) ? 8 : 7;
                
                for (let trackNum = 1; trackNum <= tracksToLoad; trackNum++) {
                    const trackName = getTrackName(songNum, trackNum);
                    const fileName = `${trackName}.mid`; 
                    const fileUrl = GITHUB_RAW_BASE_URL + fileName; // URL de Contenido Crudo
                    
                    loadingPromises.push(
                        Midi.fromUrl(fileUrl)
                            .then(midi => {
                                const track = midi.tracks[0];
                                if (!track || track.notes.length === 0) {
                                     console.warn(`Pista MIDI vac√≠a o no encontrada para: ${fileUrl}`);
                                     return;
                                }

                                // Crear el Tone.Part para esta pista (inicialmente silenciado)
                                const part = new Tone.Part((time, note) => {
                                     // Reproducir la nota cuando el Part la active
                                     globalSynth.triggerAttackRelease(note.name, note.duration, time, note.velocity);
                                     
                                     // L√ìGICA VISUAL: Activar el pulso de brillo
                                     activeNotes[trackName] = true;
                                     setTimeout(() => {
                                        activeNotes[trackName] = false;
                                     }, Tone.Time(note.duration).toMilliseconds() * 0.8);

                                }, track.notes).start(0); // Inicia el loop en 0
                                
                                part.loop = true;
                                part.mute = true; // Inicia muteado
                                
                                SONG_TONE_PARTS[songKey][trackName] = part;
                            })
                            .catch(e => {
                                console.error(`Error al cargar el archivo MIDI ${fileUrl}:`, e);
                                // Devolvemos una promesa resuelta para que Promise.all no falle por un error
                                return Promise.resolve();
                            })
                    );
                }
            }
            
            await Promise.all(loadingPromises);
            console.log("‚úÖ Todos los archivos MIDI y Tone.Parts listos.");
        }


        /**
         * Funci√≥n dummy para mantener la estructura de planet.synth
         */
        function createSynth() {
            // Devuelve un objeto dummy ya que usamos globalSynth y Tone.Part
            return { synth: null, panner: null }; 
        }


        /**
         * Inicializa el contexto de audio real de Tone.js.
         */
        function startAudioContext() {
            if (!isAudioContextStarted) {
                Tone.start(); 
                Tone.Transport.bpm.value = 120; // BPM est√°ndar, aj√∫stalo si es necesario
                Tone.Transport.start();
                isAudioContextStarted = true;
                console.log("üéµ Contexto de audio de Tone.js iniciado y transporte en marcha.");
            }
        }
        
        /**
         * Funci√≥n que cambia la canci√≥n al crear un nuevo Sol.
         */
        function changeSong() {
            const oldSongKey = `C${currentSongIndex + 1}`;
            
            // 1. Mutear todas las pistas de la canci√≥n anterior
            if (SONG_TONE_PARTS[oldSongKey]) {
                Object.values(SONG_TONE_PARTS[oldSongKey]).forEach(part => part.mute = true);
            }
            
            // 2. Ciclo a la siguiente canci√≥n
            currentSongIndex = (currentSongIndex + 1) % TOTAL_SONGS;
            const newSongKey = `C${currentSongIndex + 1}`;
            
            // 3. Actualizar las capas de instrumento disponibles
            INSTRUMENT_LAYERS = SONG_DATA_STRUCTURES[currentSongIndex].layers;

            // 4. Reasignar capas a los planetas existentes
            planets.forEach((planet, index) => {
                // Usamos el n√∫mero real de capas cargadas para el m√≥dulo
                const currentLayers = SONG_DATA_STRUCTURES[currentSongIndex].layers;
                const layerIndex = index % currentLayers.length; 
                const assignedLayer = currentLayers[layerIndex];
                
                planet.assignedLayer = assignedLayer;
                planet.pulseTypeName = `Pista: ${assignedLayer}`; 
            });
            
            // 5. Forzar la actualizaci√≥n para encender las nuevas pistas
            updateAudioVolumes();
            
            showMessage(`M√∫sica cambiada a: ${SONG_DATA_STRUCTURES[currentSongIndex].name}`, 3000, new THREE.Color(0xfacc15));
        }
        
        /**
         * Controla qu√© pistas MIDI (Tone.Part) est√°n activas (mutear/desmutear).
         */
        function updateAudioVolumes() {
            const currentSongKey = `C${currentSongIndex + 1}`;
            const currentParts = SONG_TONE_PARTS[currentSongKey];

            if (!currentParts) return;

            // 1. Obtener las capas (pistas) que deber√≠an estar activas (asignadas a un planeta)
            const activeLayers = new Set(planets.map(p => p.assignedLayer));
            
            // 2. Controlar la muteaci√≥n de los Tone.Part
            Object.keys(currentParts).forEach(trackName => {
                const part = currentParts[trackName];
                
                if (activeLayers.has(trackName)) {
                    part.mute = false; // DESMUTEAR el Part MIDI
                } else {
                    part.mute = true; // MUTEAR el Part MIDI
                }
            });

            // 3. Controlar el estado general
            musicStarted = planets.length > 0;
        }


        // =================================================================
        // FUNCIONES DE F√çSICA
        // =================================================================

        /**
         * Calcula la aceleraci√≥n gravitacional neta sobre el planeta causada por todos los soles.
         * F = G * M1 * M2 / r^2
         * A = F / M2 = G * M1 / r^2
         * @param {object} planet El objeto planeta con posici√≥n, masa y aceleraci√≥n.
         */
        function calculateGravity(planet) {
            const netAcceleration = new THREE.Vector3(0, 0, 0);

            suns.forEach(sun => {
                // Vector que apunta del planeta al sol
                const direction = tempVector.copy(sun.mesh.position).sub(planet.mesh.position);
                const distanceSq = direction.lengthSq();

                // Evitar divisi√≥n por cero o fuerzas infinitas en colisi√≥n cercana
                if (distanceSq < 1) {  
                    return;
                }
                
                const distance = Math.sqrt(distanceSq);

                // Fuerza gravitacional: A = (G * M_sol / r^2) * (vector unitario)
                const magnitude = (GRAVITATIONAL_CONSTANT * SUN_MASS) / distanceSq;

                // Asegurar que la fuerza no sea demasiado grande a corta distancia
                const maxMagnitude = 5.0; // L√≠mite de aceleraci√≥n para estabilidad
                const finalMagnitude = Math.min(magnitude, maxMagnitude);

                direction.normalize().multiplyScalar(finalMagnitude);
                
                netAcceleration.add(direction);
            });

            planet.acceleration = netAcceleration;
        }

        /**
         * Aplica la integraci√≥n de Euler para actualizar la velocidad y posici√≥n.
         * @param {object} planet El objeto planeta.
         * @param {number} deltaTime El paso de tiempo.
         */
        function updatePhysics(planet, deltaTime) {
            // Velocidad = Velocidad + Aceleraci√≥n * dt
            planet.velocity.add(planet.acceleration.clone().multiplyScalar(deltaTime));
            
            // Posici√≥n = Posici√≥n + Velocidad * dt
            planet.mesh.position.add(planet.velocity.clone().multiplyScalar(deltaTime));
        }

        /**
         * Encuentra el Sol m√°s cercano al punto de click.
         * @param {THREE.Vector3} clickPosition Posici√≥n 3D del click.
         * @returns {object} El objeto Sol m√°s cercano.
         */
        function findNearestSun(clickPosition) {
            let minDistanceSq = Infinity;
            let nearestSun = null;
            
            suns.forEach(sun => {
                // Usamos subVectors y lengthSq para calcular la distancia.
                const diffVector = new THREE.Vector3().subVectors(sun.mesh.position, clickPosition);
                const distanceSq = diffVector.lengthSq(); 
                
                if (distanceSq < minDistanceSq) {
                    minDistanceSq = distanceSq;
                    nearestSun = sun;
                }
            });

            return nearestSun;
        }

        // =================================================================
        // UTILIDADES
        // =================================================================

        /**
         * Inicializa la escena, c√°mara, renderizador y luces.
         */
        function init() {
            // 1. Configuraci√≥n de la Escena
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0d0d1a, 0.003); 

            // 2. Configuraci√≥n de la C√°mara (perspectiva para 3D)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, ORBIT_RADIUS); // Posici√≥n inicial aumentada a 250
            
            // 3. Configuraci√≥n del Renderizador (WebGL)
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio > 1 ? 2 : 1);
            // A√±adir una clase para apuntar con CSS si queremos aumentar el grosor de l√≠nea
            renderer.domElement.classList.add('webgl-canvas'); 
            document.getElementById('container').appendChild(renderer.domElement);
            
            // 4. Configuraci√≥n de la Iluminaci√≥n
            ambientLight = new THREE.AmbientLight(0x404040, 0.5); 
            scene.add(ambientLight);

            // 5. Crear el Sol Central Inicial y el Fondo de Estrellas
            createInitialSun(); 
            createStarField(); 
            
            // 6. Manejadores de Eventos
            window.addEventListener('resize', onWindowResize, false);
            setupPointerControls(renderer.domElement);
        }

        /**
         * Crea el primer Sol al iniciar la simulaci√≥n.
         */
        function createInitialSun() {
            // Sol inicial ligeramente desplazado para evitar la singularidad de la √≥rbita inicial
            const center = new THREE.Vector3(5, 0, 0); 
            createSunAtPosition(center);
        }

        /**
         * Crea un objeto Sol y lo a√±ade a la escena y al array de Soles.
         * @param {THREE.Vector3} position Posici√≥n del nuevo sol.
         */
        function createSunAtPosition(position) {
            const sunRadius = 12;
            const sunGeometry = new THREE.SphereGeometry(sunRadius, 32, 32); 
            
            // üö® CORRECCI√ìN 1: Se cambia a MeshStandardMaterial para soportar la propiedad 'emissive' y evitar el fallo en el bucle.
            const sunMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, 
                emissive: 0xff8800, // Color de brillo
                emissiveIntensity: 1.0 // Intensidad
            }); 
            const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            sunMesh.position.copy(position);
            scene.add(sunMesh);
            
            const flareTexture = generateRadialTexture(); 

            const lightSprite = new THREE.Sprite(new THREE.SpriteMaterial({
                map: flareTexture,
                color: 0xff8800, 
                blending: THREE.AdditiveBlending, 
                transparent: true,
                opacity: 0.7 
            }));
            lightSprite.scale.set(50, 50, 1.0); 
            sunMesh.add(lightSprite);

            // Cada sol necesita una luz para iluminar a los planetas a su alrededor
            const sunLight = new THREE.PointLight(0xffffff, 3.0, 0, 0); 
            sunLight.position.copy(position);
            scene.add(sunLight);

            // Se almacena el mesh para acceder a su posici√≥n Vector3
            suns.push({ mesh: sunMesh, light: sunLight, mass: SUN_MASS });
            
            // --- L√ìGICA: CAMBIAR LA CANCI√ìN AL CREAR UN NUEVO SOL ---
            if (suns.length > 1 && musicStarted) {
                changeSong();
            }
        }


        /**
         * Crea un campo de estrellas aleatorias para el fondo.
         */
        function createStarField() {
            const starCount = 1500;
            const starGeometry = new THREE.BufferGeometry();
            const positions = [];
            
            const radius = 500; 

            for (let i = 0; i < starCount; i++) {
                const x = THREE.MathUtils.randFloatSpread(radius * 2);
                const y = THREE.MathUtils.randFloatSpread(radius * 2);
                const z = THREE.MathUtils.randFloatSpread(radius * 2);

                positions.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1, 
                sizeAttenuation: true 
            });

            starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }
        
        /**
         * Genera una textura circular suave con degradado para simular un brillo (flare).
         */
        function generateRadialTexture() {
            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');

            const gradient = context.createRadialGradient(
                size / 2, size / 2, 0, 
                size / 2, size / 2, size / 2 
            );
            gradient.addColorStop(0, 'rgba(255,255,255,1)'); 
            gradient.addColorStop(1, 'rgba(255,255,255,0)'); 

            context.fillStyle = gradient;
            context.fillRect(0, 0, size, size);

            return new THREE.CanvasTexture(canvas);
        }

        /**
         * Configura los eventos de mouse y touch para el control de la c√°mara.
         */
        function setupPointerControls(element) {
            element.addEventListener('pointerdown', onPointerDown, false);
            element.addEventListener('pointermove', onPointerMove, false);
            element.addEventListener('pointerup', onPointerUp, false);
            element.addEventListener('pointerleave', onPointerUp, false);
        }

        /**
         * Evento al pulsar (clic o tocar).
         */
        function onPointerDown(event) {
            if (event.buttons === 1 || event.pointerType === 'touch') { 
                isPointerActive = true; 
                isDragging = false; 
                
                pointerStart.x = event.clientX;
                pointerStart.y = event.clientY;

                previousPointerPosition.x = event.clientX;
                previousPointerPosition.y = event.clientY;
                velocityX = 0;
                velocityY = 0;
            }
        }

        /**
         * Evento al mover el puntero (arrastrar).
         */
        function onPointerMove(event) {
            
            if (!isPointerActive) return; 

            if (!isDragging) {
                const deltaMovementX = event.clientX - pointerStart.x;
                const deltaMovementY = event.clientY - pointerStart.y;
                const distance = Math.sqrt(deltaMovementX * deltaMovementX + deltaMovementY * deltaMovementY); 
                
                if (distance > DRAG_THRESHOLD) {
                    isDragging = true; 
                }
            }

            if (isDragging) { 
                const deltaX = event.clientX - previousPointerPosition.x;
                const deltaY = event.clientY - previousPointerPosition.y;

                theta += deltaX * ROTATION_MULTIPLIER;
                phi -= deltaY * ROTATION_MULTIPLIER;
                
                velocityX = deltaX * ROTATION_MULTIPLIER * 0.5;
                velocityY = deltaY * ROTATION_MULTIPLIER * 0.5;

                previousPointerPosition.x = event.clientX;
                previousPointerPosition.y = event.clientY;
            }
        }

        /**
         * Evento al soltar (dejar de arrastrar o crear entidad).
         */
        function onPointerUp(event) {
            if (isPointerActive && !isDragging) { 
                const entitySelect = document.getElementById('entitySelect');
                const selectedEntity = entitySelect ? entitySelect.value : 'planet';
                
                if (selectedEntity === 'planet') {
                    createPlanet(event);
                } else if (selectedEntity === 'sun') {
                    createSunOnClick(event);
                }
            }
            
            isDragging = false; 
            isPointerActive = false; 
        }

        /**
         * Intenta crear un Sol en la posici√≥n del click/toque.
         */
        function createSunOnClick(event) {
            // Mapeo de coordenadas de pantalla a un punto en el espacio 3D
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // Proyectar en el plano Y=0 (el "suelo" de la simulaci√≥n)
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); 
            const intersection = new THREE.Vector3();
            
            raycaster.ray.intersectPlane(plane, intersection);

            // Limitar la distancia del Sol para evitar que aparezca muy lejos
            if (intersection.length() > MAX_SUN_DISTANCE) {
                intersection.normalize().multiplyScalar(MAX_SUN_DISTANCE);
                showMessage('Sol colocado en el l√≠mite de la zona central.', 2000, new THREE.Color(0xfacc15));
            }


            createSunAtPosition(intersection);
            showMessage('¬°Nuevo Sol Creado! Ahora afecta la gravedad.', 2000, new THREE.Color(0xfacc15));
        }

        /**
         * Crea un nuevo planeta.
         * @param {PointerEvent} event El evento de puntero (contiene clientX/Y).
         */
        function createPlanet(event) {
            startAudioContext(); 

            if (suns.length === 0) {
                showMessage('No hay soles para orbitar. ¬°Crea un Sol primero!', 3000, new THREE.Color(0xef4444));
                return;
            }
            
            // Mapeo de coordenadas de pantalla a un punto en el espacio 3D
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);

            // Proyectar en el plano Y=0 (el "suelo" de la simulaci√≥n)
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); 
            const intersection = new THREE.Vector3();
            
            raycaster.ray.intersectPlane(plane, intersection);
            const initialPosition = intersection.clone();

            // --- 1. ENCONTRAR EL SOL M√ÅS CERCANO PARA INICIALIZAR LA √ìRBITA ---
            const nearestSun = findNearestSun(initialPosition);
            
            // Usamos la posici√≥n del mesh del sol para la f√≠sica
            const relativePosition = initialPosition.clone().sub(nearestSun.mesh.position);
            const distance = relativePosition.length();

            // VERIFICACI√ìN DE SEGURIDAD CR√çTICA: La distancia NO debe ser 0.
            if (distance < COLLISION_DISTANCE) {
                showMessage('Demasiado cerca del Sol. Intenta m√°s lejos.', 3000, new THREE.Color(0xfacc15));
                return;
            }

            // 2. C√ÅLCULO DE VELOCIDAD INICIAL (para √≥rbita circular aproximada alrededor del Sol m√°s cercano)
            
            // Magnitud de la velocidad orbital: v = sqrt(G*M/r)
            const orbitVelocityMag = Math.sqrt((GRAVITATIONAL_CONSTANT * SUN_MASS) / distance);
            
            // Direcci√≥n de la velocidad: perpendicular al vector posici√≥n (para iniciar la √≥rbita)
            const positionUnit = relativePosition.clone().normalize();
            
            // Crea un vector perpendicular para la velocidad inicial (Vector3 perpendicular a positionUnit y Y-axis)
            let initialVelocity = new THREE.Vector3().crossVectors(positionUnit, new THREE.Vector3(0, 1, 0));
            
            // CORRECCI√ìN CR√çTICA: Asegurar que el vector de velocidad no sea nulo si el producto cruz falla
            if (initialVelocity.lengthSq() < 0.001) {
                // Si falla (ej. el planeta est√° exactamente en el eje Y), usa una direcci√≥n arbitraria perpendicular (Eje X)
                 initialVelocity.set(1, 0, 0); 
            }
            
            // Velocidad inicial ajustada (0.99 a 1.01) para asegurar una √≥rbita estable
            initialVelocity.normalize().multiplyScalar(orbitVelocityMag * THREE.MathUtils.randFloat(0.99, 1.01));

            // A√±adir una peque√±a componente Y para dar una inclinaci√≥n 3D inicial
            initialVelocity.y = THREE.MathUtils.randFloatSpread(orbitVelocityMag * 0.1); 

            // 3. GENERAR EL RESTO DE PROPIEDADES
            const radius = THREE.MathUtils.randFloat(1, 4); 
            
            const baseColor = new THREE.Color(Math.random(), Math.random(), Math.random());
            const hsl = {};
            baseColor.getHSL(hsl);
            hsl.l = THREE.MathUtils.randFloat(0.7, 0.9);
            hsl.s = THREE.MathUtils.randFloat(0.4, 0.8); 
            const brightColor = new THREE.Color().setHSL(hsl.h, hsl.s, hsl.l);


            // 4. Configuraci√≥n de AUDIO (Asignaci√≥n de capa)
            
            // Asignaci√≥n de Capa (El instrumento al que se asigna este planeta)
            const activeLayersCount = planets.filter(p => INSTRUMENT_LAYERS.includes(p.assignedLayer)).length;
            const currentLayers = SONG_DATA_STRUCTURES[currentSongIndex].layers;
            const layerIndex = activeLayersCount % currentLayers.length;
            const assignedLayer = currentLayers[layerIndex];
            
            // Crear un objeto dummy para audio
            const { synth, panner } = createSynth(); 
            
            // 5. Malla y Rastro (similar al c√≥digo anterior)
            const planetGeometry = new THREE.SphereGeometry(radius, 32, 32);
            const planetMaterial = new THREE.MeshLambertMaterial({ 
                color: brightColor, 
                emissive: brightColor.clone().multiplyScalar(0.1) 
            });
            const planetMesh = new THREE.Mesh(planetGeometry, planetMaterial);
            planetMesh.position.copy(initialPosition);

            const orbitPositions = new Float32Array(TRAIL_LENGTH * 3); 
            const drawingPositions = new Float32Array(TRAIL_LENGTH * 3);
            
            // Creaci√≥n del Array de Colores (RGBA: 4 componentes por punto)
            const trailColors = new Float32Array(TRAIL_LENGTH * 4); 

            const trailGeometry = new THREE.BufferGeometry();
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(drawingPositions, 3)); 
            trailGeometry.setAttribute('color', new THREE.BufferAttribute(trailColors, 4)); // A√±adir atributo de color/opacidad
            
            const trailMaterial = new THREE.LineBasicMaterial({
                color: brightColor, 
                transparent: true,
                opacity: 1.0,
                vertexColors: true // Usar colores definidos por el v√©rtice
            });
            const orbitTrail = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(orbitTrail);

            // 6. Crear Objeto para el planeta (PROPIEDADES DE F√çSICA Y AUDIO)
            const planetObject = {
                mesh: planetMesh,
                trail: orbitTrail,
                orbitPositions: orbitPositions, 
                trailColors: trailColors, // Almacenar el array de colores
                planetColor: brightColor, // Color base del planeta
                trailIndex: 0,
                trailLength: TRAIL_LENGTH,
                trailCount: 0,
                // PROPIEDADES DE F√çSICA
                mass: PLANET_MASS,
                velocity: initialVelocity, // Vector3
                acceleration: new THREE.Vector3(0, 0, 0), // Vector3
                // PROPIEDADES DE AUDIO
                synth: synth,
                panner: panner, // Nuevo panner
                assignedLayer: assignedLayer, // Capa de la canci√≥n asignada (Ej: 'C1_T1')
                // PROPIEDADES DE TRIVIA
                id: planets.length + 1, // Asignar un ID para identificarlo en la trivia
                pulseTypeName: `Pista: ${assignedLayer}` // Nombre legible
            };

            scene.add(planetMesh);
            planets.push(planetObject);
            
            // --- ACTUALIZACI√ìN: Desmutear la pista asignada ---
            updateAudioVolumes();
            // ---------------------------------------------
            
            // CAMBIO AQU√ç: Simplificamos el mensaje
            showMessage(`¬°Planeta Creado! Asignado a ${assignedLayer}.`, 1500, brightColor);
        }

        /**
         * Alterna el estado de pausa de la simulaci√≥n y la m√∫sica.
         */
        function togglePause() {
            isPaused = !isPaused;
            const button = document.getElementById('pauseButton');
            
            if (isPaused) {
                // Pausar Tone.js
                Tone.Transport.pause(); 
                
                button.textContent = 'Reanudar Simulaci√≥n';
                button.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                button.classList.add('bg-green-600', 'hover:bg-green-700');
                showMessage('Simulaci√≥n PAUSADA.', 1500, new THREE.Color(0xfb923c));
            } else {
                // Reanudar Tone.js
                Tone.Transport.start();
                
                button.textContent = 'Pausar Simulaci√≥n';
                button.classList.remove('bg-green-600', 'hover:bg-green-700');
                button.classList.add('bg-blue-600', 'hover:bg-blue-700');
                showMessage('Simulaci√≥n REANUDADA.', 1500, new THREE.Color(0x22c55e));
            }
        }

        /**
         * Elimina todos los planetas, soles, sus rastros y sus sintetizadores.
         */
        function clearSimulation() {
            const initialSuns = suns.length;
            
            // Mutear todas las pistas antes de reiniciar
            const currentSongKey = `C${currentSongIndex + 1}`;
            if (SONG_TONE_PARTS[currentSongKey]) {
                Object.values(SONG_TONE_PARTS[currentSongKey]).forEach(part => part.mute = true);
            }
            
            // Limpieza de estados
            musicStarted = false;
            currentSongIndex = 0;
            INSTRUMENT_LAYERS = SONG_DATA_STRUCTURES[0].layers;


            // Limpieza de Planetas
            planets.forEach(planet => {
                scene.remove(planet.mesh);
                scene.remove(planet.trail);
            });
            planets.length = 0;

            // Limpieza de Soles
            suns.forEach(sun => {
                scene.remove(sun.mesh);
                scene.remove(sun.light);
            });
            suns.length = 0;
            
            // Vuelve a crear el sol inicial
            if (initialSuns === 0) {
                 createInitialSun(); 
            }
            
            showMessage('Simulaci√≥n Reiniciada. ¬°Crea nuevos sistemas!', 2500, new THREE.Color(0xef4444));
        }

        /**
         * Maneja el redimensionamiento de la ventana para mantener la vista correcta.
         */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /**
         * Bucle principal de animaci√≥n (game loop).
         */
        function animate() {
            requestAnimationFrame(animate);
            
            // 0. Rotaci√≥n sutil del campo de estrellas
            if (starField) {
                starField.rotation.y += 0.00005; 
            }
            
            // 1. Mover Planetas y Actualizar Rastros y Audio (SOLO si NO est√° pausado)
            if (!isPaused) {
                
                for (let i = planets.length - 1; i >= 0; i--) {
                    const planet = planets[i];

                    // a. Calcular fuerzas y actualizar f√≠sica
                    calculateGravity(planet);
                    updatePhysics(planet, TIME_STEP);
                    
                    // b. Detecci√≥n de colisi√≥n / expulsi√≥n (SOLO ELIMINA POR EXPULSI√ìN)
                    // Usa el nuevo l√≠mite MAX_EXPULSION_DISTANCE
                    if (planet.mesh.position.length() > MAX_EXPULSION_DISTANCE) {
                        // Expulsi√≥n: Eliminar planeta
                        scene.remove(planet.mesh);
                        scene.remove(planet.trail);
                        planets.splice(i, 1);
                        updateAudioVolumes(); // Reajustar el volumen despu√©s de eliminar
                        showMessage('¬°Planeta Escapado! Limpiado.', 1000, new THREE.Color(0xff4444));
                        continue; // Pasa al siguiente planeta
                    }


                    // c. L√ìGICA DE VISUALIZACI√ìN R√çTMICA (CON VERIFICACI√ìN DE SEGURIDAD)
                    const layer = planet.assignedLayer;
                    const isNoteActive = activeNotes[layer]; 

                    // üö® CORRECCI√ìN 2: Se a√±ade verificaci√≥n de seguridad antes de manipular el brillo
                    if (planet.mesh && planet.mesh.material && planet.mesh.material.emissiveIntensity !== undefined) {
                        if (isNoteActive) {
                            const maxEmissive = 1.0; 
                            planet.mesh.material.emissiveIntensity = THREE.MathUtils.lerp(planet.mesh.material.emissiveIntensity, maxEmissive, 0.5);
                        } else {
                            const minEmissive = 0.1;
                            planet.mesh.material.emissiveIntensity = THREE.MathUtils.lerp(planet.mesh.material.emissiveIntensity, minEmissive, 0.1);
                        }
                    }


                    // d. Rotaci√≥n propia del planeta
                    planet.mesh.rotation.y += 0.01;

                    // e. Actualizar rastro de √≥rbita y colores (opacidad)
                    const orbitPositions = planet.orbitPositions;
                    const positionsAttribute = planet.trail.geometry.attributes.position;
                    const colorsAttribute = planet.trail.geometry.attributes.color;
                    const positionsForDrawing = positionsAttribute.array;
                    const colorsForDrawing = colorsAttribute.array;
                    
                    const index = planet.trailIndex * 3;

                    // 1. Guardar nueva posici√≥n
                    orbitPositions[index] = planet.mesh.position.x;
                    orbitPositions[index + 1] = planet.mesh.position.y;
                    orbitPositions[index + 2] = planet.mesh.position.z;

                    planet.trailIndex = (planet.trailIndex + 1) % planet.trailLength;
                    
                    if (planet.trailCount < planet.trailLength) {
                        planet.trailCount++;
                    }

                    // 2. Reordenar puntos y aplicar colores/opacidad
                    let p_index = 0; 
                    const totalPoints = planet.trailCount < planet.trailLength ? planet.trailCount : planet.trailLength;
                    const baseColor = planet.planetColor;

                    const updatePoint = (j, opacityRatio) => {
                        // Posici√≥n
                        positionsForDrawing[p_index * 3] = orbitPositions[j * 3];
                        positionsForDrawing[p_index * 3 + 1] = orbitPositions[j * 3 + 1];
                        positionsForDrawing[p_index * 3 + 2] = orbitPositions[j * 3 + 2];
                        
                        // Color y Opacidad (RGBA)
                        colorsForDrawing[p_index * 4] = baseColor.r;
                        colorsForDrawing[p_index * 4 + 1] = baseColor.g;
                        colorsForDrawing[p_index * 4 + 2] = baseColor.b;
                        colorsForDrawing[p_index * 4 + 3] = opacityRatio; // Opacidad

                        p_index++;
                    };
                    
                    const calculateOpacity = (i) => {
                        // i: √≠ndice absoluto del punto, de 0 al totalPoints-1
                        const minOpacity = 0.2;
                        const factor = 1.0 - minOpacity;
                        return minOpacity + (i / totalPoints) * factor; 
                    };


                    if (planet.trailCount < planet.trailLength) {
                        // FASE DE LLENADO: Rastro desde el punto 0 hasta el punto actual
                        for (let j = 0; j < planet.trailCount; j++) {
                            const opacityRatio = calculateOpacity(j);
                            updatePoint(j, opacityRatio);
                        }
                        planet.trail.geometry.setDrawRange(0, planet.trailCount);

                    } else {
                        // FASE ESTABLE: Rastro completo (buffer circular)
                        let opacityCounter = 0;
                        
                        // Parte A: Desde el punto actual (el m√°s viejo) hasta el final del array
                        for (let j = planet.trailIndex; j < planet.trailLength; j++) {
                            const opacityRatio = calculateOpacity(opacityCounter++);
                            updatePoint(j, opacityRatio);
                        }
                        // Parte B: Desde el inicio del array (punto 0) hasta el punto actual (el m√°s reciente)
                        for (let j = 0; j < planet.trailIndex; j++) {
                            const opacityRatio = calculateOpacity(opacityCounter++);
                            updatePoint(j, opacityRatio);
                        }
                        
                        planet.trail.geometry.setDrawRange(0, planet.trailLength);
                    }

                    positionsAttribute.needsUpdate = true;
                    colorsAttribute.needsUpdate = true; // Notificar a Three.js que los colores cambiaron
                }
            }
            
            // 2. Mover la C√°mara (Controles Manuales e Inercia) - Esto siempre debe funcionar
            if (!isDragging) {
                theta += velocityX;
                phi -= velocityY; 
                velocityX *= DAMPING_FACTOR;
                velocityY *= DAMPING_FACTOR;
            }

            phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));

            const x = ORBIT_RADIUS * Math.sin(phi) * Math.sin(theta);
            const y = ORBIT_RADIUS * Math.cos(phi);
            const z = ORBIT_RADIUS * Math.sin(phi) * Math.cos(theta);

            camera.position.set(x, y, z);
            camera.lookAt(0, 0, 0); 

            // 3. Renderizar la Escena
            renderer.render(scene, camera);
        }

        /**
         * Muestra un mensaje temporal en la pantalla (simula un alert, but with UI).
         */
        function showMessage(text, duration, color) {
            let messageBox = document.getElementById('messageBox');
            if (!messageBox) {
                messageBox = document.createElement('div');
                messageBox.id = 'messageBox';
                // Cambiado de top-4 a bottom-20 (por encima de los controles flotantes)
                messageBox.className = 'fixed bottom-20 left-1/2 transform -translate-x-1/2 p-3 rounded-lg shadow-xl text-white font-bold transition-opacity duration-300 pointer-events-none opacity-0 z-20';
                document.body.appendChild(messageBox);
            }
            
            messageBox.style.backgroundColor = color ? '#' + color.getHexString() : '#10b981';
            messageBox.textContent = text;
            messageBox.style.opacity = '1';
            
            clearTimeout(messageBox.timer);
            messageBox.timer = setTimeout(() => {
                messageBox.style.opacity = '0';
            }, duration);
        }

        // =================================================================
        // L√ìGICA DE TRIVIA (JEOPARDY)
        // =================================================================
        let currentScore = 0;
        let availableQuestions = {};
        let activeQuestion = null;

        const JEOPARDY_POINTS = [100, 200, 300, 400, 500];
        const JEOPARDY_CATEGORIES = {
            'PHYSICS': 'F√çSICA (Gravedad)',
            'AUDIO': 'COMPOSICI√ìN',
            'VISUALS': 'DATOS DEL SISTEMA'
        };
        
        // --- BASE DE DATOS DE PREGUNTAS SOBRE EL SISTEMA SOLAR ---
        const ASTRONOMY_QUESTIONS = {
            // CATEGOR√çA: F√çSICA (Gravedad, √ìrbitas, Movimiento)
            'PHYSICS': [
                {
                    question: '¬øQu√© ley de Kepler describe que la √≥rbita de un planeta es una elipse con el Sol en uno de sus focos?',
                    answer: 'Primera Ley',
                    options: ['Primera Ley', 'Segunda Ley', 'Tercera Ley', 'Ley de Gravitaci√≥n Universal'],
                    points: 100
                },
                {
                    question: '¬øQu√© planeta tiene la gravedad superficial m√°s fuerte en el Sistema Solar?',
                    answer: 'J√∫piter',
                    options: ['Tierra', 'J√∫piter', 'Saturno', 'Sol'],
                    points: 200
                },
                {
                    question: '¬øCu√°l es el planeta que rota m√°s lentamente sobre su propio eje?',
                    answer: 'Venus',
                    options: ['Marte', 'J√∫piter', 'Venus', 'Mercurio'],
                    points: 300
                },
                {
                    question: '¬øCu√°l es el planeta m√°s caliente, a pesar de no ser el m√°s cercano al Sol?',
                    answer: 'Venus',
                    options: ['Mercurio', 'Marte', 'Venus', 'Tierra'],
                    points: 400
                },
                {
                    question: 'La influencia gravitacional de J√∫piter fue clave en la formaci√≥n de, ¬øqu√© cintur√≥n de asteroides?',
                    answer: 'Cintur√≥n de Kuiper',
                    options: ['Cintur√≥n de Kuiper', 'Cintur√≥n de Asteroides principal (entre Marte y J√∫piter)', 'Nube de Oort', 'Cintur√≥n de Van Allen'],
                    points: 500
                },
            ],

            // CATEGOR√çA: COMPOSICI√ìN (Atm√≥sfera, Lunas, Materiales)
            'AUDIO': [ // Usando AUDIO como el nombre de la categor√≠a en el c√≥digo, pero se llama COMPOSICI√ìN en el tablero
                {
                    question: '¬øQu√© planeta tiene la mayor cantidad de lunas confirmadas?',
                    answer: 'Saturno',
                    options: ['J√∫piter', 'Urano', 'Saturno', 'Neptuno'],
                    points: 100
                },
                {
                    question: '¬øCu√°l es el principal componente de las atm√≥sferas de J√∫piter y Saturno?',
                    answer: 'Hidr√≥geno y Helio',
                    options: ['Nitr√≥geno y Ox√≠geno', 'Di√≥xido de Carbono', 'Hidr√≥geno y Helio', 'Metano y Amon√≠aco'],
                    points: 200
                },
                {
                    question: '¬øQu√© luna de J√∫piter es conocida por su intensa actividad volc√°nica?',
                    answer: '√ço',
                    options: ['Europa', 'Gan√≠medes', 'Calisto', '√ço'],
                    points: 300
                },
                {
                    question: 'El n√∫cleo de la Tierra est√° compuesto principalmente de...',
                    answer: 'Hierro y N√≠quel',
                    options: ['Silicato y Magnesio', 'Hierro y N√≠quel', 'Oro y Platino', 'Agua Congelada'],
                    points: 400
                },
                {
                    question: '¬øCu√°l es el nombre del planeta enano m√°s grande conocido en el Cintur√≥n de Kuiper?',
                    answer: 'Eris',
                    options: ['Haumea', 'Plut√≥n', 'Ceres', 'Eris'],
                    points: 500
                },
            ],

            // CATEGOR√çA: VISUALES (Tama√±o, Anillos, Apariencia)
            'VISUALS': [ // Usando VISUALES como el nombre de la categor√≠a en el c√≥digo, pero se llama DATOS DEL SISTEMA en el tablero
                {
                    question: '¬øCu√°l de estos planetas no tiene anillos?',
                    answer: 'Marte',
                    options: ['Urano', 'Neptuno', 'J√∫piter', 'Marte'],
                    points: 100
                },
                {
                    question: 'El Gran Punto Rojo es una tormenta persistente en la atm√≥sfera de, ¬øqu√© planeta?',
                    answer: 'J√∫piter',
                    options: ['Marte', 'J√∫piter', 'Saturno', 'Urano'],
                    points: 200
                },
                {
                    question: '¬øCu√°l es el planeta m√°s grande del Sistema Solar?',
                    answer: 'J√∫piter',
                    options: ['Saturno', 'Tierra', 'J√∫piter', 'Urano'],
                    points: 300
                },
                {
                    question: '¬øQu√© planeta tiene un distintivo color azul verdoso debido al metano en su atm√≥sfera?',
                    answer: 'Urano',
                    options: ['Neptuno', 'Urano', 'Tierra', 'Marte'],
                    points: 400
                },
                {
                    question: '¬øC√≥mo se llama la luna de Saturno que es la √∫nica conocida por tener una atm√≥sfera densa?',
                    answer: 'Tit√°n',
                    options: ['Enc√©lado', 'Rea', 'Tit√°n', 'J√°peto'],
                    points: 500
                },
            ]
        };
        // --- FIN BASE DE DATOS DE PREGUNTAS ---

        /**
         * Inicializa las preguntas del tablero usando la base de datos de astronom√≠a.
         */
        function initializeJeopardyQuestions() {
            availableQuestions = {};

            JEOPARDY_POINTS.forEach(points => {
                availableQuestions[points] = {};
                
                Object.keys(JEOPARDY_CATEGORIES).forEach(categoryKey => {
                    // Encontrar la pregunta que corresponde a la categor√≠a y los puntos
                    const questionData = ASTRONOMY_QUESTIONS[categoryKey].find(q => q.points === points);

                    if (questionData) {
                        availableQuestions[points][categoryKey] = {
                            category: JEOPARDY_CATEGORIES[categoryKey],
                            points: points,
                            question: questionData.question,
                            answer: questionData.answer,
                            // Aseguramos que las opciones se mezclen
                            options: questionData.options.sort(() => 0.5 - Math.random()) 
                        };
                    }
                });
            });
        }


        /**
         * Muestra el tablero de Jeopardy.
         */
        function renderJeopardyBoard() {
            const boardContainer = document.getElementById('jeopardyBoard');
            const categories = Object.keys(JEOPARDY_CATEGORIES);
            
            // Ocultar la vista de pregunta individual
            document.getElementById('questionDisplay').classList.add('hidden');
            document.getElementById('questionDisplay').classList.remove('flex');
            
            // Mostrar el tablero
            boardContainer.classList.remove('hidden');

            // Limpiar las celdas anteriores (dejar los t√≠tulos de categor√≠a)
            const cellsToRemove = boardContainer.querySelectorAll('.point-cell');
            cellsToRemove.forEach(cell => cell.remove());
            
            JEOPARDY_POINTS.forEach(points => {
                categories.forEach(categoryKey => {
                    const cell = document.createElement('button');
                    // Celdas de Puntos: Turquesa y Texto Blanco
                    cell.className = 'point-cell question-card bg-trivia-teal hover:bg-teal-600 text-3xl font-extrabold rounded-lg p-3 m-1 text-white';
                    cell.textContent = `$${points}`;
                    cell.dataset.category = categoryKey;
                    cell.dataset.points = points;
                    
                    // Comprobar si la pregunta ya fue respondida
                    if (availableQuestions[points] && availableQuestions[points][categoryKey] && availableQuestions[points][categoryKey].answered) {
                        cell.classList.add('answered', 'bg-gray-700');
                        cell.textContent = ''; // Vaciar la celda
                        cell.disabled = true;
                    } else {
                         cell.addEventListener('click', () => showQuestion(categoryKey, points));
                    }

                    boardContainer.appendChild(cell);
                });
            });

            document.getElementById('questionDisplay').classList.add('hidden');
            boardContainer.classList.remove('hidden');
        }

        /**
         * Muestra la pregunta seleccionada.
         */
        function showQuestion(categoryKey, points) {
            activeQuestion = availableQuestions[points][categoryKey];

            if (!activeQuestion) {
                 showMessage('Error: Pregunta no disponible.', 2000, new THREE.Color(0xef4444));
                 renderJeopardyBoard();
                 return;
            }
            
            // Si la pregunta ya fue respondida, no hacer nada (solo deber√≠a pasar si se manipula el DOM)
            if (activeQuestion.answered) {
                renderJeopardyBoard(); 
                return;
            }


            document.getElementById('jeopardyBoard').classList.add('hidden');
            
            const display = document.getElementById('questionDisplay');
            display.classList.remove('hidden');
            display.classList.add('flex');

            // Los elementos internos de la tarjeta de pregunta son negros contra el fondo blanco
            document.getElementById('questionCategory').textContent = activeQuestion.category;
            document.getElementById('questionValue').textContent = `VALOR: $${activeQuestion.points}`;
            document.getElementById('currentQuestionText').textContent = activeQuestion.question;
            document.getElementById('feedbackMessage').classList.add('hidden');
            document.getElementById('backToBoardButton').classList.add('hidden');
            
            const optionsContainer = document.getElementById('optionsContainer');
            optionsContainer.innerHTML = activeQuestion.options.map((option, index) => `
                <button data-answer="${option}" 
                        data-category="${categoryKey}" 
                        data-points="${points}"
                        class="trivia-option-button w-full text-left p-3 bg-gray-300 hover:bg-yellow-400 text-gray-900 rounded-md transition duration-150 text-base">
                    ${String.fromCharCode(65 + index)}. ${option}
                </button>
            `).join('');

            // Enlazar evento de click a los botones de opci√≥n
            document.querySelectorAll('.trivia-option-button').forEach(button => {
                button.addEventListener('click', handleAnswer);
            });
        }


        /**
         * Maneja la respuesta del usuario.
         */
        function handleAnswer(event) {
            const button = event.target;
            const userAnswer = button.dataset.answer;
            const categoryKey = button.dataset.category;
            const points = parseInt(button.dataset.points);
            
            const question = availableQuestions[points][categoryKey];
            const correct = question.answer;

            // Deshabilitar todos los botones de opci√≥n
            document.querySelectorAll('.trivia-option-button').forEach(btn => {
                btn.disabled = true;
                btn.classList.remove('hover:bg-yellow-600');
                // Asegurar que el texto se mantenga legible en los botones de opci√≥n
                btn.classList.remove('text-gray-900'); 
                btn.classList.add('text-white');
                
                if (btn.dataset.answer === correct) {
                    btn.classList.add('bg-green-600'); // Respuesta correcta
                } else if (btn.dataset.answer === userAnswer) {
                    btn.classList.add('bg-red-600'); // Respuesta incorrecta elegida
                } else {
                    btn.classList.add('bg-gray-500'); // Opciones no seleccionadas/incorrectas
                }
            });

            const feedback = document.getElementById('feedbackMessage');
            feedback.classList.remove('hidden', 'text-green-400', 'text-red-400');
            
            // Actualizar estado de la pregunta y puntuaci√≥n
            if (userAnswer === correct) {
                currentScore += points;
                feedback.textContent = `¬°CORRECTO! Ganaste $${points} puntos.`;
                feedback.classList.add('text-green-600'); // Verde oscuro sobre fondo blanco
            } else {
                currentScore -= points;
                feedback.textContent = `INCORRECTO. Perdiste $${points} puntos. La respuesta era: ${correct}`;
                feedback.classList.add('text-red-600'); // Rojo oscuro sobre fondo blanco
            }

            // Marcar como respondida y actualizar el marcador
            question.answered = true;
            document.getElementById('currentScore').textContent = currentScore;
            
            document.getElementById('backToBoardButton').classList.remove('hidden');
        }

        /**
         * Inicia el modo trivia.
         */
        function startJeopardy() {
            // Pausar la simulaci√≥n al entrar a la Trivia
            if (!isPaused) {
                togglePause();
            }

            // Mostrar el overlay y ocultar controles
            document.getElementById('jeopardyOverlay').classList.remove('hidden');
            document.getElementById('controls').style.opacity = '0';
            document.getElementById('controls').style.pointerEvents = 'none';

            // Resetear estado de trivia
            currentScore = 0;
            document.getElementById('currentScore').textContent = 0;
            
            initializeJeopardyQuestions(); // Cargar las preguntas de astronom√≠a
            renderJeopardyBoard();
        }
        
        /**
         * Regresa a la simulaci√≥n desde el Jeopardy.
         */
        function resumeSimulation() {
            document.getElementById('jeopardyOverlay').classList.add('hidden');
            
            // Mostrar controles
            document.getElementById('controls').style.opacity = '1';
            document.getElementById('controls').style.pointerEvents = 'auto';

            // Reanudar la simulaci√≥n (si el bot√≥n de Pausa dice 'Reanudar Simulaci√≥n')
            if (document.getElementById('pauseButton').textContent === 'Reanudar Simulaci√≥n') {
                togglePause();
            }
        }


        // =================================================================
        // INICIO
        // =================================================================

        document.getElementById('startButton').addEventListener('click', async () => { 
            try {
                // 1. Iniciar AudioContext (requiere interacci√≥n del usuario)
                showMessage('Cargando recursos de audio (MIDI)...', 9000, new THREE.Color(0xfacc15));
                await loadMidiFiles(); 
                startAudioContext(); 
                
                // 2. Transici√≥n Visual Inmediata
                const overlay = document.getElementById('overlay');
                overlay.style.opacity = '0';
                
                setTimeout(() => {
                    overlay.style.pointerEvents = 'none';
                    
                    // 3. Inicializaci√≥n del motor (Three.js + Tone.js)
                    init();
                    animate();

                    // 4. ATTACH CONTROLS (Must happen after init())
                    document.getElementById('pauseButton').addEventListener('click', togglePause);
                    document.getElementById('clearButton').addEventListener('click', clearSimulation);
                    document.getElementById('triviaButton').addEventListener('click', startJeopardy);
                    document.getElementById('resumeButton').addEventListener('click', resumeSimulation);
                    document.getElementById('backToBoardButton').addEventListener('click', renderJeopardyBoard);
                    
                    const controls = document.getElementById('controls');
                    controls.style.opacity = '1';
                    controls.style.pointerEvents = 'auto';
                    
                    showMessage('¬°Simulaci√≥n Iniciada! Crea un planeta para iniciar la Armon√≠a.', 3500, new THREE.Color(0x22c55e));

                }, 500); // 500ms para la transici√≥n

            } catch (error) {
                console.error("Fallo cr√≠tico al iniciar la simulaci√≥n:", error);
                // Mostrar un mensaje de error visible al usuario si la inicializaci√≥n falla
                showMessage(`Error al iniciar: ${error.message}. Revisa la consola.`, 5000, new THREE.Color(0xff0000));
            }
        });

    </script>
</body>
</html>
